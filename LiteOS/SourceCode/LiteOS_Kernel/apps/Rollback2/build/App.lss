
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800c80  0000f784  00000818  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000784  0000f000  0000f000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000051  00800c84  00800c84  0000081c  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  0000081c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000001b  00000000  00000000  0000083c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002494  00000000  00000000  00000857  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002eb  00000000  00000000  00002ceb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000007da  00000000  00000000  00002fd6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000e0  00000000  00000000  000037b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000006cc  00000000  00000000  00003890  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000520  00000000  00000000  00003f5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  0000447c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000f000 <__vectors>:
    f000:	0c 94 46 78 	jmp	0xf08c	; 0xf08c <__ctors_end>
    f004:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f008:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f00c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f010:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f014:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f018:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f01c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f020:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f024:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f028:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f02c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f030:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f034:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f038:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f03c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f040:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f044:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f048:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f04c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f050:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f054:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f058:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f05c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f060:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f064:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f068:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f06c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f070:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f074:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f078:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f07c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f080:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f084:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f088:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>

0000f08c <__ctors_end>:
    f08c:	11 24       	eor	r1, r1
    f08e:	1f be       	out	0x3f, r1	; 63
    f090:	cc ea       	ldi	r28, 0xAC	; 172
    f092:	dd e0       	ldi	r29, 0x0D	; 13
    f094:	de bf       	out	0x3e, r29	; 62
    f096:	cd bf       	out	0x3d, r28	; 61

0000f098 <__do_copy_data>:
    f098:	1c e0       	ldi	r17, 0x0C	; 12
    f09a:	a0 e8       	ldi	r26, 0x80	; 128
    f09c:	bc e0       	ldi	r27, 0x0C	; 12
    f09e:	e4 e8       	ldi	r30, 0x84	; 132
    f0a0:	f7 ef       	ldi	r31, 0xF7	; 247
    f0a2:	00 e0       	ldi	r16, 0x00	; 0
    f0a4:	0b bf       	out	0x3b, r16	; 59
    f0a6:	02 c0       	rjmp	.+4      	; 0xf0ac <__do_copy_data+0x14>
    f0a8:	07 90       	elpm	r0, Z+
    f0aa:	0d 92       	st	X+, r0
    f0ac:	a4 38       	cpi	r26, 0x84	; 132
    f0ae:	b1 07       	cpc	r27, r17
    f0b0:	d9 f7       	brne	.-10     	; 0xf0a8 <__do_copy_data+0x10>

0000f0b2 <__do_clear_bss>:
    f0b2:	1c e0       	ldi	r17, 0x0C	; 12
    f0b4:	a4 e8       	ldi	r26, 0x84	; 132
    f0b6:	bc e0       	ldi	r27, 0x0C	; 12
    f0b8:	01 c0       	rjmp	.+2      	; 0xf0bc <.do_clear_bss_start>

0000f0ba <.do_clear_bss_loop>:
    f0ba:	1d 92       	st	X+, r1

0000f0bc <.do_clear_bss_start>:
    f0bc:	a5 3d       	cpi	r26, 0xD5	; 213
    f0be:	b1 07       	cpc	r27, r17
    f0c0:	e1 f7       	brne	.-8      	; 0xf0ba <.do_clear_bss_loop>
    f0c2:	0e 94 2f 7a 	call	0xf45e	; 0xf45e <main>
    f0c6:	0c 94 c0 7b 	jmp	0xf780	; 0xf780 <_exit>

0000f0ca <__bad_interrupt>:
    f0ca:	0c 94 00 78 	jmp	0xf000	; 0xf000 <__vectors>

0000f0ce <wakeupMeOnRequest.1548>:
}


void wakeupMeOnRequest()
{
	  currentthread->state = STATE_ACTIVE;
    f0ce:	e0 91 ac 0c 	lds	r30, 0x0CAC
    f0d2:	f0 91 ad 0c 	lds	r31, 0x0CAD
    f0d6:	82 e0       	ldi	r24, 0x02	; 2
    f0d8:	82 83       	std	Z+2, r24	; 0x02
	  iswakenup = 1; 
    f0da:	81 e0       	ldi	r24, 0x01	; 1
    f0dc:	80 93 a9 0c 	sts	0x0CA9, r24


void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    f0e0:	e8 e6       	ldi	r30, 0x68	; 104
    f0e2:	fa ee       	ldi	r31, 0xEA	; 234
    f0e4:	09 95       	icall
    syscall_postThreadTask();
}
    f0e6:	08 95       	ret

0000f0e8 <getCurrentThread.1326>:

thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f0e8:	4f 93       	push	r20
    f0ea:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f0ec:	ec e0       	ldi	r30, 0x0C	; 12
    f0ee:	fa ee       	ldi	r31, 0xEA	; 234
    f0f0:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f0f2:	24 2f       	mov	r18, r20
    f0f4:	35 2f       	mov	r19, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f0f6:	5f 91       	pop	r21
    f0f8:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}
    f0fa:	c9 01       	movw	r24, r18
    f0fc:	08 95       	ret

0000f0fe <getCurrentThreadIndex.1327>:
uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f0fe:	4f 93       	push	r20
    f100:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f102:	ec e1       	ldi	r30, 0x1C	; 28
    f104:	fa ee       	ldi	r31, 0xEA	; 234
    f106:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f108:	84 2f       	mov	r24, r20
    f10a:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f10c:	5f 91       	pop	r21
    f10e:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}
    f110:	08 95       	ret

0000f112 <mfseek.1477>:




void mfseek(MYFILE *fp, int offset, int position)
{
    f112:	af 92       	push	r10
    f114:	bf 92       	push	r11
    f116:	cf 92       	push	r12
    f118:	df 92       	push	r13
    f11a:	ef 92       	push	r14
    f11c:	ff 92       	push	r15
    f11e:	0f 93       	push	r16
    f120:	1f 93       	push	r17
    f122:	b8 2e       	mov	r11, r24
    f124:	a9 2e       	mov	r10, r25
    f126:	7b 01       	movw	r14, r22
    f128:	6a 01       	movw	r12, r20
   uint8_t currentthreadindex;
   thread** current_thread;

   current_thread = getCurrentThread();
    f12a:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f12e:	8c 01       	movw	r16, r24
   currentthreadindex = getCurrentThreadIndex();
    f130:	0e 94 7f 78 	call	0xf0fe	; 0xf0fe <getCurrentThreadIndex.1327>

   (*current_thread)->filedata.fileseekstate.fileptr = (uint8_t*)fp;
    f134:	d8 01       	movw	r26, r16
    f136:	ed 91       	ld	r30, X+
    f138:	fc 91       	ld	r31, X
    f13a:	11 97       	sbiw	r26, 0x01	; 1
    f13c:	8b 2d       	mov	r24, r11
    f13e:	9a 2d       	mov	r25, r10
    f140:	90 a3       	std	Z+32, r25	; 0x20
    f142:	87 8f       	std	Z+31, r24	; 0x1f
   (*current_thread)->filedata.fileseekstate.offset = offset;
    f144:	ed 91       	ld	r30, X+
    f146:	fc 91       	ld	r31, X
    f148:	11 97       	sbiw	r26, 0x01	; 1
    f14a:	f2 a2       	std	Z+34, r15	; 0x22
    f14c:	e1 a2       	std	Z+33, r14	; 0x21
   (*current_thread)->filedata.fileseekstate.position = position;
    f14e:	ed 91       	ld	r30, X+
    f150:	fc 91       	ld	r31, X
    f152:	d4 a2       	std	Z+36, r13	; 0x24
    f154:	c3 a2       	std	Z+35, r12	; 0x23


void seekFileSysCall()
{
 void (*filefp)() = (void (*)(void))SEEK_FILE_SYSCALL;
 filefp();
    f156:	ec e3       	ldi	r30, 0x3C	; 60
    f158:	fa ee       	ldi	r31, 0xEA	; 234
    f15a:	09 95       	icall

   return;



}
    f15c:	1f 91       	pop	r17
    f15e:	0f 91       	pop	r16
    f160:	ff 90       	pop	r15
    f162:	ef 90       	pop	r14
    f164:	df 90       	pop	r13
    f166:	cf 90       	pop	r12
    f168:	bf 90       	pop	r11
    f16a:	af 90       	pop	r10
    f16c:	08 95       	ret

0000f16e <getFileMutexAddress.1409>:

mutex *getFileMutexAddress()
{
   mutex *mfile;   
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_MUTEX_ADDRESS; 
   asm volatile("push r20" "\n\t"
    f16e:	4f 93       	push	r20
    f170:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f172:	e8 e2       	ldi	r30, 0x28	; 40
    f174:	fa ee       	ldi	r31, 0xEA	; 234
    f176:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f178:	24 2f       	mov	r18, r20
    f17a:	35 2f       	mov	r19, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (mfile)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f17c:	5f 91       	pop	r21
    f17e:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return mfile; 
}
    f180:	c9 01       	movw	r24, r18
    f182:	08 95       	ret

0000f184 <Barrier_block.1408>:


 


void Barrier_block(uint8_t type, uint8_t id){
    f184:	ff 92       	push	r15
    f186:	0f 93       	push	r16
    f188:	1f 93       	push	r17
    f18a:	18 2f       	mov	r17, r24
    f18c:	f6 2e       	mov	r15, r22
   
    _atomic_t currentatomic;
	thread **current_thread; 

     
	current_thread = getCurrentThread(); 
    f18e:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f192:	dc 01       	movw	r26, r24
volatile uint16_t * old_stack_ptr ;


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
    f194:	0f b7       	in	r16, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
    f196:	f8 94       	cli

    currentatomic = _atomic_start();
    
      (*current_thread)->state = STATE_IO;
    f198:	ed 91       	ld	r30, X+
    f19a:	fc 91       	ld	r31, X
    f19c:	11 97       	sbiw	r26, 0x01	; 1
    f19e:	86 e0       	ldi	r24, 0x06	; 6
    f1a0:	82 83       	std	Z+2, r24	; 0x02
      (*current_thread)->data.iostate.type = type;
    f1a2:	ed 91       	ld	r30, X+
    f1a4:	fc 91       	ld	r31, X
    f1a6:	11 97       	sbiw	r26, 0x01	; 1
    f1a8:	13 8f       	std	Z+27, r17	; 0x1b
      (*current_thread)->data.iostate.id = id;
    f1aa:	ed 91       	ld	r30, X+
    f1ac:	fc 91       	ld	r31, X
    f1ae:	f4 8e       	std	Z+28, r15	; 0x1c


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f1b0:	e0 e0       	ldi	r30, 0x00	; 0
    f1b2:	fa ee       	ldi	r31, 0xEA	; 234
    f1b4:	09 95       	icall



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
    f1b6:	0f bf       	out	0x3f, r16	; 63
      yield();
    
    _atomic_end(currentatomic);
}
    f1b8:	1f 91       	pop	r17
    f1ba:	0f 91       	pop	r16
    f1bc:	ff 90       	pop	r15
    f1be:	08 95       	ret

0000f1c0 <mfwrite.1473>:
}



void mfwrite(MYFILE *fp, void *buffer, int nBytes)
{
    f1c0:	af 92       	push	r10
    f1c2:	bf 92       	push	r11
    f1c4:	cf 92       	push	r12
    f1c6:	df 92       	push	r13
    f1c8:	ef 92       	push	r14
    f1ca:	ff 92       	push	r15
    f1cc:	0f 93       	push	r16
    f1ce:	1f 93       	push	r17
    f1d0:	f8 2e       	mov	r15, r24
    f1d2:	e9 2e       	mov	r14, r25
    f1d4:	d6 2e       	mov	r13, r22
    f1d6:	c7 2e       	mov	r12, r23
    f1d8:	b4 2e       	mov	r11, r20
    f1da:	a5 2e       	mov	r10, r21
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
    f1dc:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f1e0:	8c 01       	movw	r16, r24
   currentthreadindex = getCurrentThreadIndex();
    f1e2:	0e 94 7f 78 	call	0xf0fe	; 0xf0fe <getCurrentThreadIndex.1327>
   mfile = getFileMutexAddress();
    f1e6:	0e 94 b7 78 	call	0xf16e	; 0xf16e <getFileMutexAddress.1409>
     
	// (*current_thread)->ecbptr->remainenergy -= (uint16_t)FILE_WRITE * (uint16_t)nBytes;          


  // Mutex_lock(mfile);
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
    f1ea:	d8 01       	movw	r26, r16
    f1ec:	ed 91       	ld	r30, X+
    f1ee:	fc 91       	ld	r31, X
    f1f0:	11 97       	sbiw	r26, 0x01	; 1
    f1f2:	8f 2d       	mov	r24, r15
    f1f4:	9e 2d       	mov	r25, r14
    f1f6:	90 a3       	std	Z+32, r25	; 0x20
    f1f8:	87 8f       	std	Z+31, r24	; 0x1f
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
    f1fa:	ed 91       	ld	r30, X+
    f1fc:	fc 91       	ld	r31, X
    f1fe:	11 97       	sbiw	r26, 0x01	; 1
    f200:	8d 2d       	mov	r24, r13
    f202:	9c 2d       	mov	r25, r12
    f204:	92 a3       	std	Z+34, r25	; 0x22
    f206:	81 a3       	std	Z+33, r24	; 0x21
   (*current_thread)->filedata.filestate.bytes = nBytes;
    f208:	ed 91       	ld	r30, X+
    f20a:	fc 91       	ld	r31, X
    f20c:	8b 2d       	mov	r24, r11
    f20e:	9a 2d       	mov	r25, r10
    f210:	94 a3       	std	Z+36, r25	; 0x24
    f212:	83 a3       	std	Z+35, r24	; 0x23


void writeFileSysCall()
{
 void (*filefp)() = (void (*)(void))WRITE_FILE_SYSCALL;
 filefp();
    f214:	e8 e3       	ldi	r30, 0x38	; 56
    f216:	fa ee       	ldi	r31, 0xEA	; 234
    f218:	09 95       	icall
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   (*current_thread)->filedata.filestate.bytes = nBytes;

   writeFileSysCall();

   Barrier_block(7, 4);
    f21a:	87 e0       	ldi	r24, 0x07	; 7
    f21c:	64 e0       	ldi	r22, 0x04	; 4
    f21e:	0e 94 c2 78 	call	0xf184	; 0xf184 <Barrier_block.1408>
  // Mutex_unlock(mfile);
   
   //sleepThread(20);

   return;
}
    f222:	1f 91       	pop	r17
    f224:	0f 91       	pop	r16
    f226:	ff 90       	pop	r15
    f228:	ef 90       	pop	r14
    f22a:	df 90       	pop	r13
    f22c:	cf 90       	pop	r12
    f22e:	bf 90       	pop	r11
    f230:	af 90       	pop	r10
    f232:	08 95       	ret

0000f234 <Mutex_lock.1401>:
#include "system.h"
#include "thread.h"
#include "liteoscommon.h"

void Mutex_lock(mutex *m)
{
    f234:	ef 92       	push	r14
    f236:	ff 92       	push	r15
    f238:	0f 93       	push	r16
    f23a:	1f 93       	push	r17
    f23c:	cf 93       	push	r28
    f23e:	df 93       	push	r29
    f240:	ec 01       	movw	r28, r24
    uint8_t threadindex; 
    

	_atomic_t currentatomic;
    
	current_thread = getCurrentThread(); 
    f242:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f246:	8c 01       	movw	r16, r24
	threadindex = getCurrentThreadIndex(); 
    f248:	0e 94 7f 78 	call	0xf0fe	; 0xf0fe <getCurrentThreadIndex.1327>
    f24c:	e8 2e       	mov	r14, r24
volatile uint16_t * old_stack_ptr ;


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
    f24e:	ff b6       	in	r15, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
    f250:	f8 94       	cli

	currentatomic = _atomic_start();
	
    if(m->lock){  
    f252:	88 81       	ld	r24, Y
    f254:	88 23       	and	r24, r24
    f256:	99 f0       	breq	.+38     	; 0xf27e <Mutex_lock.1401+0x4a>
        (*current_thread)->state = STATE_BLOCKED;
    f258:	d8 01       	movw	r26, r16
    f25a:	ed 91       	ld	r30, X+
    f25c:	fc 91       	ld	r31, X
    f25e:	11 97       	sbiw	r26, 0x01	; 1
    f260:	83 e0       	ldi	r24, 0x03	; 3
    f262:	82 83       	std	Z+2, r24	; 0x02
        (*current_thread)->data.m = m;
    f264:	ed 91       	ld	r30, X+
    f266:	fc 91       	ld	r31, X
    f268:	d4 8f       	std	Z+28, r29	; 0x1c
    f26a:	c3 8f       	std	Z+27, r28	; 0x1b
        
      
        m->waiting++;
    f26c:	89 81       	ldd	r24, Y+1	; 0x01
    f26e:	8f 5f       	subi	r24, 0xFF	; 255
    f270:	89 83       	std	Y+1, r24	; 0x01
    f272:	e0 e0       	ldi	r30, 0x00	; 0
    f274:	fa ee       	ldi	r31, 0xEA	; 234
    f276:	09 95       	icall
       
        yield();
     
        m->waiting--;
    f278:	89 81       	ldd	r24, Y+1	; 0x01
    f27a:	81 50       	subi	r24, 0x01	; 1
    f27c:	89 83       	std	Y+1, r24	; 0x01
      }
      m->lock = 1;
    f27e:	81 e0       	ldi	r24, 0x01	; 1
    f280:	88 83       	st	Y, r24
      m->lockingthreadid = threadindex; 
    f282:	ea 82       	std	Y+2, r14	; 0x02



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
    f284:	ff be       	out	0x3f, r15	; 63
      
    _atomic_end(currentatomic);  


}
    f286:	df 91       	pop	r29
    f288:	cf 91       	pop	r28
    f28a:	1f 91       	pop	r17
    f28c:	0f 91       	pop	r16
    f28e:	ff 90       	pop	r15
    f290:	ef 90       	pop	r14
    f292:	08 95       	ret

0000f294 <mfread.1469>:
   return;

}

void mfread(MYFILE *fp, void *buffer, int nBytes)
{
    f294:	8f 92       	push	r8
    f296:	9f 92       	push	r9
    f298:	af 92       	push	r10
    f29a:	bf 92       	push	r11
    f29c:	cf 92       	push	r12
    f29e:	df 92       	push	r13
    f2a0:	ef 92       	push	r14
    f2a2:	ff 92       	push	r15
    f2a4:	0f 93       	push	r16
    f2a6:	1f 93       	push	r17
    f2a8:	d8 2e       	mov	r13, r24
    f2aa:	c9 2e       	mov	r12, r25
    f2ac:	b6 2e       	mov	r11, r22
    f2ae:	a7 2e       	mov	r10, r23
    f2b0:	94 2e       	mov	r9, r20
    f2b2:	85 2e       	mov	r8, r21
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
    f2b4:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f2b8:	8c 01       	movw	r16, r24
   currentthreadindex = getCurrentThreadIndex();
    f2ba:	0e 94 7f 78 	call	0xf0fe	; 0xf0fe <getCurrentThreadIndex.1327>
   mfile = getFileMutexAddress();
    f2be:	0e 94 b7 78 	call	0xf16e	; 0xf16e <getFileMutexAddress.1409>
    f2c2:	7c 01       	movw	r14, r24


   Mutex_lock(mfile);
    f2c4:	0e 94 1a 79 	call	0xf234	; 0xf234 <Mutex_lock.1401>
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
    f2c8:	d8 01       	movw	r26, r16
    f2ca:	ed 91       	ld	r30, X+
    f2cc:	fc 91       	ld	r31, X
    f2ce:	11 97       	sbiw	r26, 0x01	; 1
    f2d0:	8d 2d       	mov	r24, r13
    f2d2:	9c 2d       	mov	r25, r12
    f2d4:	90 a3       	std	Z+32, r25	; 0x20
    f2d6:	87 8f       	std	Z+31, r24	; 0x1f
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
    f2d8:	ed 91       	ld	r30, X+
    f2da:	fc 91       	ld	r31, X
    f2dc:	11 97       	sbiw	r26, 0x01	; 1
    f2de:	8b 2d       	mov	r24, r11
    f2e0:	9a 2d       	mov	r25, r10
    f2e2:	92 a3       	std	Z+34, r25	; 0x22
    f2e4:	81 a3       	std	Z+33, r24	; 0x21
   (*current_thread)->filedata.filestate.bytes = nBytes;
    f2e6:	ed 91       	ld	r30, X+
    f2e8:	fc 91       	ld	r31, X
    f2ea:	89 2d       	mov	r24, r9
    f2ec:	98 2d       	mov	r25, r8
    f2ee:	94 a3       	std	Z+36, r25	; 0x24
    f2f0:	83 a3       	std	Z+35, r24	; 0x23


void readFileSysCall()
{
 void (*filefp)() = (void (*)(void))READ_FILE_SYSCALL;
 filefp();
    f2f2:	e4 e3       	ldi	r30, 0x34	; 52
    f2f4:	fa ee       	ldi	r31, 0xEA	; 234
    f2f6:	09 95       	icall
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   (*current_thread)->filedata.filestate.bytes = nBytes;

   readFileSysCall();

   Barrier_block(7, 3);
    f2f8:	87 e0       	ldi	r24, 0x07	; 7
    f2fa:	63 e0       	ldi	r22, 0x03	; 3
    f2fc:	0e 94 c2 78 	call	0xf184	; 0xf184 <Barrier_block.1408>

void Mutex_unlock(mutex *m)
{
     
   void (*getaddrfp)(void) = (void (*)(void))MUTEX_UNLOCK_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f300:	4f 93       	push	r20
    f302:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
      
   asm volatile(" mov r20, %A0" "\n\t"
    f304:	4e 2d       	mov	r20, r14
    f306:	5f 2d       	mov	r21, r15
	              " mov r21, %B0" "\n\t"
				 :
				 :"r" (m)
                );

   getaddrfp();
    f308:	e8 e1       	ldi	r30, 0x18	; 24
    f30a:	fa ee       	ldi	r31, 0xEA	; 234
    f30c:	09 95       	icall
   asm volatile( "pop r21" "\n\t"
    f30e:	5f 91       	pop	r21
    f310:	4f 91       	pop	r20
   Mutex_unlock(mfile);

   return;

}
    f312:	1f 91       	pop	r17
    f314:	0f 91       	pop	r16
    f316:	ff 90       	pop	r15
    f318:	ef 90       	pop	r14
    f31a:	df 90       	pop	r13
    f31c:	cf 90       	pop	r12
    f31e:	bf 90       	pop	r11
    f320:	af 90       	pop	r10
    f322:	9f 90       	pop	r9
    f324:	8f 90       	pop	r8
    f326:	08 95       	ret

0000f328 <mfclose.1465>:
}



void mfclose(MYFILE *fp)
{
    f328:	cf 92       	push	r12
    f32a:	df 92       	push	r13
    f32c:	ef 92       	push	r14
    f32e:	ff 92       	push	r15
    f330:	0f 93       	push	r16
    f332:	1f 93       	push	r17
    f334:	d8 2e       	mov	r13, r24
    f336:	c9 2e       	mov	r12, r25
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
    f338:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f33c:	8c 01       	movw	r16, r24
   currentthreadindex = getCurrentThreadIndex();
    f33e:	0e 94 7f 78 	call	0xf0fe	; 0xf0fe <getCurrentThreadIndex.1327>
   mfile = getFileMutexAddress();
    f342:	0e 94 b7 78 	call	0xf16e	; 0xf16e <getFileMutexAddress.1409>
    f346:	7c 01       	movw	r14, r24

   Mutex_lock(mfile);
    f348:	0e 94 1a 79 	call	0xf234	; 0xf234 <Mutex_lock.1401>

   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
    f34c:	d8 01       	movw	r26, r16
    f34e:	ed 91       	ld	r30, X+
    f350:	fc 91       	ld	r31, X
    f352:	8d 2d       	mov	r24, r13
    f354:	9c 2d       	mov	r25, r12
    f356:	90 a3       	std	Z+32, r25	; 0x20
    f358:	87 8f       	std	Z+31, r24	; 0x1f


void closeFileSysCall()
{
 void (*filefp)() = (void (*)(void))CLOSE_FILE_SYSCALL;
 filefp();
    f35a:	e0 e3       	ldi	r30, 0x30	; 48
    f35c:	fa ee       	ldi	r31, 0xEA	; 234
    f35e:	09 95       	icall
   Mutex_lock(mfile);

   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   closeFileSysCall();

   Barrier_block(7, 2);
    f360:	87 e0       	ldi	r24, 0x07	; 7
    f362:	62 e0       	ldi	r22, 0x02	; 2
    f364:	0e 94 c2 78 	call	0xf184	; 0xf184 <Barrier_block.1408>

void Mutex_unlock(mutex *m)
{
     
   void (*getaddrfp)(void) = (void (*)(void))MUTEX_UNLOCK_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f368:	4f 93       	push	r20
    f36a:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
      
   asm volatile(" mov r20, %A0" "\n\t"
    f36c:	4e 2d       	mov	r20, r14
    f36e:	5f 2d       	mov	r21, r15
	              " mov r21, %B0" "\n\t"
				 :
				 :"r" (m)
                );

   getaddrfp();
    f370:	e8 e1       	ldi	r30, 0x18	; 24
    f372:	fa ee       	ldi	r31, 0xEA	; 234
    f374:	09 95       	icall
   asm volatile( "pop r21" "\n\t"
    f376:	5f 91       	pop	r21
    f378:	4f 91       	pop	r20
   Mutex_unlock(mfile);

   return;

}
    f37a:	1f 91       	pop	r17
    f37c:	0f 91       	pop	r16
    f37e:	ff 90       	pop	r15
    f380:	ef 90       	pop	r14
    f382:	df 90       	pop	r13
    f384:	cf 90       	pop	r12
    f386:	08 95       	ret

0000f388 <mfopen.1463>:




MYFILE *mfopen(const char *pathname, const char *mode)
{
    f388:	8f 92       	push	r8
    f38a:	9f 92       	push	r9
    f38c:	af 92       	push	r10
    f38e:	bf 92       	push	r11
    f390:	cf 92       	push	r12
    f392:	df 92       	push	r13
    f394:	ef 92       	push	r14
    f396:	ff 92       	push	r15
    f398:	0f 93       	push	r16
    f39a:	1f 93       	push	r17
    f39c:	cf 93       	push	r28
    f39e:	df 93       	push	r29
    f3a0:	6c 01       	movw	r12, r24
    f3a2:	5b 01       	movw	r10, r22

   thread** current_thread;

   mutex *mfile;

   current_thread = getCurrentThread();
    f3a4:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f3a8:	4c 01       	movw	r8, r24

   currentthreadindex = getCurrentThreadIndex();
    f3aa:	0e 94 7f 78 	call	0xf0fe	; 0xf0fe <getCurrentThreadIndex.1327>

char *getFilePathAddress()
{
   char *pathaddr;
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_PATH_ADDRESS;
   asm volatile("push r20" "\n\t"
    f3ae:	4f 93       	push	r20
    f3b0:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
    f3b2:	e0 e2       	ldi	r30, 0x20	; 32
    f3b4:	fa ee       	ldi	r31, 0xEA	; 234
    f3b6:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f3b8:	c4 2f       	mov	r28, r20
    f3ba:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (pathaddr)
				 :);
    asm volatile("pop r21" "\n\t"
    f3bc:	5f 91       	pop	r21
    f3be:	4f 91       	pop	r20
char *getFileModeAddress()

{
   char *modeaddr;
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_MODE_ADDRESS;
   asm volatile("push r20" "\n\t"
    f3c0:	4f 93       	push	r20
    f3c2:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
    f3c4:	e4 e2       	ldi	r30, 0x24	; 36
    f3c6:	fa ee       	ldi	r31, 0xEA	; 234
    f3c8:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f3ca:	e4 2e       	mov	r14, r20
    f3cc:	f5 2e       	mov	r15, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (modeaddr)
				 :);
    asm volatile("pop r21" "\n\t"
    f3ce:	5f 91       	pop	r21
    f3d0:	4f 91       	pop	r20

   commonpathnameaddr =  getFilePathAddress();

   commonmodeaddr = getFileModeAddress();

   mfile = getFileMutexAddress();
    f3d2:	0e 94 b7 78 	call	0xf16e	; 0xf16e <getFileMutexAddress.1409>
    f3d6:	8c 01       	movw	r16, r24


   Mutex_lock(mfile);
    f3d8:	0e 94 1a 79 	call	0xf234	; 0xf234 <Mutex_lock.1401>
    f3dc:	80 e0       	ldi	r24, 0x00	; 0
    f3de:	90 e0       	ldi	r25, 0x00	; 0
    f3e0:	02 c0       	rjmp	.+4      	; 0xf3e6 <mfopen.1463+0x5e>
void mystrcpy(char *dest, const char *src)
{
	int i;
	i = 0;
	while (src[i]!='\0')
	{ dest[i] = src[i];
    f3e2:	ec 93       	st	X, r30
	i++;
    f3e4:	01 96       	adiw	r24, 0x01	; 1

void mystrcpy(char *dest, const char *src)
{
	int i;
	i = 0;
	while (src[i]!='\0')
    f3e6:	f6 01       	movw	r30, r12
    f3e8:	e8 0f       	add	r30, r24
    f3ea:	f9 1f       	adc	r31, r25
    f3ec:	e0 81       	ld	r30, Z
    f3ee:	de 01       	movw	r26, r28
    f3f0:	a8 0f       	add	r26, r24
    f3f2:	b9 1f       	adc	r27, r25
    f3f4:	ee 23       	and	r30, r30
    f3f6:	a9 f7       	brne	.-22     	; 0xf3e2 <mfopen.1463+0x5a>
	{ dest[i] = src[i];
	i++;
	}
	dest[i] = '\0';
    f3f8:	1c 92       	st	X, r1
    f3fa:	80 e0       	ldi	r24, 0x00	; 0
    f3fc:	90 e0       	ldi	r25, 0x00	; 0
    f3fe:	02 c0       	rjmp	.+4      	; 0xf404 <mfopen.1463+0x7c>
void mystrcpy(char *dest, const char *src)
{
	int i;
	i = 0;
	while (src[i]!='\0')
	{ dest[i] = src[i];
    f400:	ec 93       	st	X, r30
	i++;
    f402:	01 96       	adiw	r24, 0x01	; 1

void mystrcpy(char *dest, const char *src)
{
	int i;
	i = 0;
	while (src[i]!='\0')
    f404:	f5 01       	movw	r30, r10
    f406:	e8 0f       	add	r30, r24
    f408:	f9 1f       	adc	r31, r25
    f40a:	e0 81       	ld	r30, Z
    f40c:	d7 01       	movw	r26, r14
    f40e:	a8 0f       	add	r26, r24
    f410:	b9 1f       	adc	r27, r25
    f412:	ee 23       	and	r30, r30
    f414:	a9 f7       	brne	.-22     	; 0xf400 <mfopen.1463+0x78>
	{ dest[i] = src[i];
	i++;
	}
	dest[i] = '\0';
    f416:	1c 92       	st	X, r1


void openFileSysCall()
{
 void (*filefp)() = (void (*)(void))OPEN_FILE_SYSCALL;
 filefp();
    f418:	ec e2       	ldi	r30, 0x2C	; 44
    f41a:	fa ee       	ldi	r31, 0xEA	; 234
    f41c:	09 95       	icall
   mystrcpy(commonpathnameaddr, pathname);
   mystrcpy(commonmodeaddr, mode);

   openFileSysCall();

   Barrier_block(7, 1);
    f41e:	87 e0       	ldi	r24, 0x07	; 7
    f420:	61 e0       	ldi	r22, 0x01	; 1
    f422:	0e 94 c2 78 	call	0xf184	; 0xf184 <Barrier_block.1408>

void Mutex_unlock(mutex *m)
{
     
   void (*getaddrfp)(void) = (void (*)(void))MUTEX_UNLOCK_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f426:	4f 93       	push	r20
    f428:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
      
   asm volatile(" mov r20, %A0" "\n\t"
    f42a:	40 2f       	mov	r20, r16
    f42c:	51 2f       	mov	r21, r17
	              " mov r21, %B0" "\n\t"
				 :
				 :"r" (m)
                );

   getaddrfp();
    f42e:	e8 e1       	ldi	r30, 0x18	; 24
    f430:	fa ee       	ldi	r31, 0xEA	; 234
    f432:	09 95       	icall
   asm volatile( "pop r21" "\n\t"
    f434:	5f 91       	pop	r21
    f436:	4f 91       	pop	r20
   Mutex_unlock(mfile);

   return (MYFILE *)((*current_thread)->filedata.filestate.fileptr);
    f438:	d4 01       	movw	r26, r8
    f43a:	ed 91       	ld	r30, X+
    f43c:	fc 91       	ld	r31, X
    f43e:	27 8d       	ldd	r18, Z+31	; 0x1f
    f440:	30 a1       	ldd	r19, Z+32	; 0x20
}
    f442:	c9 01       	movw	r24, r18
    f444:	df 91       	pop	r29
    f446:	cf 91       	pop	r28
    f448:	1f 91       	pop	r17
    f44a:	0f 91       	pop	r16
    f44c:	ff 90       	pop	r15
    f44e:	ef 90       	pop	r14
    f450:	df 90       	pop	r13
    f452:	cf 90       	pop	r12
    f454:	bf 90       	pop	r11
    f456:	af 90       	pop	r10
    f458:	9f 90       	pop	r9
    f45a:	8f 90       	pop	r8
    f45c:	08 95       	ret

0000f45e <main>:
	filename[6] = '\0'; 
}


void main()
{
    f45e:	ff 92       	push	r15
    f460:	0f 93       	push	r16
    f462:	1f 93       	push	r17
    f464:	cf 93       	push	r28
    f466:	df 93       	push	r29
    f468:	ee eb       	ldi	r30, 0xBE	; 190
    f46a:	fc e0       	ldi	r31, 0x0C	; 12


void initSnapshotTable(){
  int i;
  for (i=0; i<8; i++)
    seqtable[i] = 0; 
    f46c:	11 92       	st	Z+, r1
    f46e:	11 92       	st	Z+, r1



void initSnapshotTable(){
  int i;
  for (i=0; i<8; i++)
    f470:	8c e0       	ldi	r24, 0x0C	; 12
    f472:	ee 3c       	cpi	r30, 0xCE	; 206
    f474:	f8 07       	cpc	r31, r24
    f476:	d1 f7       	brne	.-12     	; 0xf46c <main+0xe>



void initFileName()
{
	filename[0] = '_';
    f478:	8f e5       	ldi	r24, 0x5F	; 95
    f47a:	80 93 b6 0c 	sts	0x0CB6, r24
	filename[1] = 'f';
    f47e:	86 e6       	ldi	r24, 0x66	; 102
    f480:	80 93 b7 0c 	sts	0x0CB7, r24
	filename[2] = 'i';
    f484:	89 e6       	ldi	r24, 0x69	; 105
    f486:	80 93 b8 0c 	sts	0x0CB8, r24
	filename[3] = 'l';
    f48a:	8c e6       	ldi	r24, 0x6C	; 108
    f48c:	80 93 b9 0c 	sts	0x0CB9, r24
	filename[4] = 'e';
    f490:	85 e6       	ldi	r24, 0x65	; 101
    f492:	80 93 ba 0c 	sts	0x0CBA, r24
	filename[6] = '\0'; 
    f496:	10 92 bc 0c 	sts	0x0CBC, r1

     
    initSnapshotTable();
    initFileName();
    
    thiscurrentthread = getCurrentThread();
    f49a:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f49e:	fc 01       	movw	r30, r24
    f4a0:	90 93 ab 0c 	sts	0x0CAB, r25
    f4a4:	80 93 aa 0c 	sts	0x0CAA, r24
    currentthread = *thiscurrentthread;
    f4a8:	80 81       	ld	r24, Z
    f4aa:	91 81       	ldd	r25, Z+1	; 0x01
    f4ac:	90 93 ad 0c 	sts	0x0CAD, r25
    f4b0:	80 93 ac 0c 	sts	0x0CAC, r24
{
   radiohandletype *currentradioinfo;

   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_HANDLE_ADDR;

   asm volatile("push r20" "\n\t"
    f4b4:	4f 93       	push	r20
    f4b6:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
    f4b8:	e0 e6       	ldi	r30, 0x60	; 96
    f4ba:	fa ee       	ldi	r31, 0xEA	; 234
    f4bc:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f4be:	e4 2f       	mov	r30, r20
    f4c0:	f5 2f       	mov	r31, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f4c2:	5f 91       	pop	r21
    f4c4:	4f 91       	pop	r20
    _atomic_t currentatomic;
    radiohandletype *radiohandleaddr;
    void (*getaddrfp) (void) = (void (*)(void))REGISTER_RADIO_RECEIVE_EVENT;

    radiohandleaddr = getCurrentRadioHandleAddr();
    incomingRequestLength = 0;
    f4c6:	10 92 a4 0c 	sts	0x0CA4, r1
    //set up the radiohandleaddr data structures
    radiohandleaddr->port = 65;
    f4ca:	81 e4       	ldi	r24, 0x41	; 65
    f4cc:	90 e0       	ldi	r25, 0x00	; 0
    f4ce:	91 83       	std	Z+1, r25	; 0x01
    f4d0:	80 83       	st	Z, r24
    radiohandleaddr->maxLength = 16;
    f4d2:	80 e1       	ldi	r24, 0x10	; 16
    f4d4:	82 83       	std	Z+2, r24	; 0x02
    radiohandleaddr->dataReady = &incomingRequestLength;
    f4d6:	84 ea       	ldi	r24, 0xA4	; 164
    f4d8:	9c e0       	ldi	r25, 0x0C	; 12
    f4da:	94 83       	std	Z+4, r25	; 0x04
    f4dc:	83 83       	std	Z+3, r24	; 0x03
    radiohandleaddr->data = incomingRequest;
    f4de:	84 e8       	ldi	r24, 0x84	; 132
    f4e0:	9c e0       	ldi	r25, 0x0C	; 12
    f4e2:	96 83       	std	Z+6, r25	; 0x06
    f4e4:	85 83       	std	Z+5, r24	; 0x05
    radiohandleaddr->packetinfo = incomingRequestPacketInfo;
    f4e6:	85 ea       	ldi	r24, 0xA5	; 165
    f4e8:	9c e0       	ldi	r25, 0x0C	; 12
    f4ea:	90 87       	std	Z+8, r25	; 0x08
    f4ec:	87 83       	std	Z+7, r24	; 0x07
    radiohandleaddr->handlefunc = wakeupMeOnRequest;
    f4ee:	87 e6       	ldi	r24, 0x67	; 103
    f4f0:	98 e7       	ldi	r25, 0x78	; 120
    f4f2:	93 87       	std	Z+11, r25	; 0x0b
    f4f4:	82 87       	std	Z+10, r24	; 0x0a
volatile uint16_t * old_stack_ptr ;


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
    f4f6:	1f b7       	in	r17, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
    f4f8:	f8 94       	cli
    //close the interrupt     
    currentatomic = _atomic_start();
    //call the radio handle set to store the data structure into the handle vectors 
    getaddrfp();
    f4fa:	e4 e6       	ldi	r30, 0x64	; 100
    f4fc:	fa ee       	ldi	r31, 0xEA	; 234
    f4fe:	09 95       	icall



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
    f500:	1f bf       	out	0x3f, r17	; 63
               else if (requestType == 2)
            	  {
            	  thread_table_start = getCurrentThread();
            		filename[5] = '1' +  lookupTable(seq); 
               
                threadsize = sizeof(struct thread);
    f502:	17 e2       	ldi	r17, 0x27	; 39
               mfread(fp, &thread_table_start[indexThread], threadsize);
               mfseek(fp, threadsize, 1);
               mfread(fp, internal_ram_start, threadramsize);
               mfclose(fp);	

			   thread_table_start[indexThread].state =  STATE_ACTIVE; 
    f504:	02 e0       	ldi	r16, 0x02	; 2
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
    f506:	95 e0       	ldi	r25, 0x05	; 5
    f508:	f9 2e       	mov	r15, r25


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f50a:	c0 e0       	ldi	r28, 0x00	; 0
    f50c:	da ee       	ldi	r29, 0xEA	; 234
    
    registerHandleRequest();
    
    while (1)
    {
         if (iswakenup == 1)
    f50e:	80 91 a9 0c 	lds	r24, 0x0CA9
    f512:	81 30       	cpi	r24, 0x01	; 1
    f514:	09 f0       	breq	.+2      	; 0xf518 <main+0xba>
    f516:	20 c1       	rjmp	.+576    	; 0xf758 <main+0x2fa>
         	{
         		iswakenup = 0;
    f518:	10 92 a9 0c 	sts	0x0CA9, r1
            seq = *(uint16_t *)(&incomingRequest[0]);
    f51c:	80 91 84 0c 	lds	r24, 0x0C84
    f520:	90 91 85 0c 	lds	r25, 0x0C85
    f524:	90 93 b1 0c 	sts	0x0CB1, r25
    f528:	80 93 b0 0c 	sts	0x0CB0, r24
            requestType = incomingRequest[2];
    f52c:	90 91 86 0c 	lds	r25, 0x0C86
    f530:	90 93 b2 0c 	sts	0x0CB2, r25
            indexThread = incomingRequest[3];
    f534:	80 91 87 0c 	lds	r24, 0x0C87
    f538:	80 93 b3 0c 	sts	0x0CB3, r24
            
            if (requestType == 1)
    f53c:	91 30       	cpi	r25, 0x01	; 1
    f53e:	09 f0       	breq	.+2      	; 0xf542 <main+0xe4>
    f540:	87 c0       	rjmp	.+270    	; 0xf650 <main+0x1f2>
            	{
            		thread_table_start = getCurrentThread();
    f542:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f546:	90 93 af 0c 	sts	0x0CAF, r25
    f54a:	80 93 ae 0c 	sts	0x0CAE, r24
								insertTable(seq); 
    f54e:	20 91 b0 0c 	lds	r18, 0x0CB0
    f552:	30 91 b1 0c 	lds	r19, 0x0CB1
    f556:	ae eb       	ldi	r26, 0xBE	; 190
    f558:	bc e0       	ldi	r27, 0x0C	; 12
    f55a:	e0 e0       	ldi	r30, 0x00	; 0
    f55c:	f0 e0       	ldi	r31, 0x00	; 0

void insertTable(uint16_t seq)
{
   int i;
   for (i=0;i<8;i++)
   {  if (seqtable[i] == 0)
    f55e:	8d 91       	ld	r24, X+
    f560:	9c 91       	ld	r25, X
    f562:	11 97       	sbiw	r26, 0x01	; 1
    f564:	89 2b       	or	r24, r25
    f566:	29 f0       	breq	.+10     	; 0xf572 <main+0x114>


void insertTable(uint16_t seq)
{
   int i;
   for (i=0;i<8;i++)
    f568:	31 96       	adiw	r30, 0x01	; 1
    f56a:	12 96       	adiw	r26, 0x02	; 2
    f56c:	e8 30       	cpi	r30, 0x08	; 8
    f56e:	f1 05       	cpc	r31, r1
    f570:	b1 f7       	brne	.-20     	; 0xf55e <main+0x100>
   {  if (seqtable[i] == 0)
	  break;
   }
     seqtable[i] = seq; 
    f572:	ee 0f       	add	r30, r30
    f574:	ff 1f       	adc	r31, r31
    f576:	e2 54       	subi	r30, 0x42	; 66
    f578:	f3 4f       	sbci	r31, 0xF3	; 243
    f57a:	31 83       	std	Z+1, r19	; 0x01
    f57c:	20 83       	st	Z, r18
            
            if (requestType == 1)
            	{
            		thread_table_start = getCurrentThread();
								insertTable(seq); 
            		filename[5] = '1' +  lookupTable(seq); 
    f57e:	40 91 b0 0c 	lds	r20, 0x0CB0
    f582:	50 91 b1 0c 	lds	r21, 0x0CB1
    f586:	ee eb       	ldi	r30, 0xBE	; 190
    f588:	fc e0       	ldi	r31, 0x0C	; 12
    f58a:	20 e0       	ldi	r18, 0x00	; 0
    f58c:	30 e0       	ldi	r19, 0x00	; 0

int lookupTable(uint16_t seq) { 
  int i;
  for (i=0; i<8; i++)
   {
     if (seqtable[i] == seq)
    f58e:	80 81       	ld	r24, Z
    f590:	91 81       	ldd	r25, Z+1	; 0x01
    f592:	84 17       	cp	r24, r20
    f594:	95 07       	cpc	r25, r21
    f596:	41 f0       	breq	.+16     	; 0xf5a8 <main+0x14a>
   return 100; 
}

int lookupTable(uint16_t seq) { 
  int i;
  for (i=0; i<8; i++)
    f598:	2f 5f       	subi	r18, 0xFF	; 255
    f59a:	3f 4f       	sbci	r19, 0xFF	; 255
    f59c:	32 96       	adiw	r30, 0x02	; 2
    f59e:	28 30       	cpi	r18, 0x08	; 8
    f5a0:	31 05       	cpc	r19, r1
    f5a2:	a9 f7       	brne	.-22     	; 0xf58e <main+0x130>
    f5a4:	24 e6       	ldi	r18, 0x64	; 100
    f5a6:	30 e0       	ldi	r19, 0x00	; 0
            
            if (requestType == 1)
            	{
            		thread_table_start = getCurrentThread();
								insertTable(seq); 
            		filename[5] = '1' +  lookupTable(seq); 
    f5a8:	82 2f       	mov	r24, r18
    f5aa:	8f 5c       	subi	r24, 0xCF	; 207
    f5ac:	80 93 bb 0c 	sts	0x0CBB, r24
               
                threadsize = sizeof(struct thread);
    f5b0:	10 93 ce 0c 	sts	0x0CCE, r17
                threadramsize =
    f5b4:	80 91 b3 0c 	lds	r24, 0x0CB3
    f5b8:	81 9f       	mul	r24, r17
    f5ba:	c0 01       	movw	r24, r0
    f5bc:	11 24       	eor	r1, r1
    f5be:	e0 91 ae 0c 	lds	r30, 0x0CAE
    f5c2:	f0 91 af 0c 	lds	r31, 0x0CAF
    f5c6:	e8 0f       	add	r30, r24
    f5c8:	f9 1f       	adc	r31, r25
    f5ca:	83 89       	ldd	r24, Z+19	; 0x13
    f5cc:	94 89       	ldd	r25, Z+20	; 0x14
    f5ce:	01 96       	adiw	r24, 0x01	; 1
    f5d0:	21 89       	ldd	r18, Z+17	; 0x11
    f5d2:	32 89       	ldd	r19, Z+18	; 0x12
    f5d4:	82 1b       	sub	r24, r18
    f5d6:	93 0b       	sbc	r25, r19
    f5d8:	90 93 d0 0c 	sts	0x0CD0, r25
    f5dc:	80 93 cf 0c 	sts	0x0CCF, r24
                (uint16_t) ((uint8_t *) thread_table_start[indexThread].ramend -
                (uint8_t *) thread_table_start[indexThread].ramstart + 1);
                internal_ram_start = 
    f5e0:	30 93 d2 0c 	sts	0x0CD2, r19
    f5e4:	20 93 d1 0c 	sts	0x0CD1, r18
                (uint8_t *) thread_table_start[indexThread].ramstart;
               fp = mfopen((char *)filename, "w");
    f5e8:	86 eb       	ldi	r24, 0xB6	; 182
    f5ea:	9c e0       	ldi	r25, 0x0C	; 12
    f5ec:	60 e8       	ldi	r22, 0x80	; 128
    f5ee:	7c e0       	ldi	r23, 0x0C	; 12
    f5f0:	0e 94 c4 79 	call	0xf388	; 0xf388 <mfopen.1463>
    f5f4:	90 93 b5 0c 	sts	0x0CB5, r25
    f5f8:	80 93 b4 0c 	sts	0x0CB4, r24
               mfwrite(fp, &thread_table_start[indexThread], threadsize);
    f5fc:	20 91 b3 0c 	lds	r18, 0x0CB3
    f600:	21 9f       	mul	r18, r17
    f602:	90 01       	movw	r18, r0
    f604:	11 24       	eor	r1, r1
    f606:	60 91 ae 0c 	lds	r22, 0x0CAE
    f60a:	70 91 af 0c 	lds	r23, 0x0CAF
    f60e:	62 0f       	add	r22, r18
    f610:	73 1f       	adc	r23, r19
    f612:	40 91 ce 0c 	lds	r20, 0x0CCE
    f616:	50 e0       	ldi	r21, 0x00	; 0
    f618:	0e 94 e0 78 	call	0xf1c0	; 0xf1c0 <mfwrite.1473>
               mfseek(fp, threadsize, 1);
    f61c:	60 91 ce 0c 	lds	r22, 0x0CCE
    f620:	80 91 b4 0c 	lds	r24, 0x0CB4
    f624:	90 91 b5 0c 	lds	r25, 0x0CB5
    f628:	70 e0       	ldi	r23, 0x00	; 0
    f62a:	41 e0       	ldi	r20, 0x01	; 1
    f62c:	50 e0       	ldi	r21, 0x00	; 0
    f62e:	0e 94 89 78 	call	0xf112	; 0xf112 <mfseek.1477>
               mfwrite(fp, internal_ram_start, threadramsize);
    f632:	60 91 d1 0c 	lds	r22, 0x0CD1
    f636:	70 91 d2 0c 	lds	r23, 0x0CD2
    f63a:	40 91 cf 0c 	lds	r20, 0x0CCF
    f63e:	50 91 d0 0c 	lds	r21, 0x0CD0
    f642:	80 91 b4 0c 	lds	r24, 0x0CB4
    f646:	90 91 b5 0c 	lds	r25, 0x0CB5
    f64a:	0e 94 e0 78 	call	0xf1c0	; 0xf1c0 <mfwrite.1473>
    f64e:	71 c0       	rjmp	.+226    	; 0xf732 <main+0x2d4>
               mfclose(fp);
               
               thread_table_start[indexThread].state =  STATE_ACTIVE; 
              }  
               else if (requestType == 2)
    f650:	92 30       	cpi	r25, 0x02	; 2
    f652:	09 f0       	breq	.+2      	; 0xf656 <main+0x1f8>
    f654:	5c cf       	rjmp	.-328    	; 0xf50e <main+0xb0>
            	  {
            	  thread_table_start = getCurrentThread();
    f656:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f65a:	90 93 af 0c 	sts	0x0CAF, r25
    f65e:	80 93 ae 0c 	sts	0x0CAE, r24
            		filename[5] = '1' +  lookupTable(seq); 
    f662:	40 91 b0 0c 	lds	r20, 0x0CB0
    f666:	50 91 b1 0c 	lds	r21, 0x0CB1
    f66a:	ee eb       	ldi	r30, 0xBE	; 190
    f66c:	fc e0       	ldi	r31, 0x0C	; 12
    f66e:	20 e0       	ldi	r18, 0x00	; 0
    f670:	30 e0       	ldi	r19, 0x00	; 0

int lookupTable(uint16_t seq) { 
  int i;
  for (i=0; i<8; i++)
   {
     if (seqtable[i] == seq)
    f672:	80 81       	ld	r24, Z
    f674:	91 81       	ldd	r25, Z+1	; 0x01
    f676:	84 17       	cp	r24, r20
    f678:	95 07       	cpc	r25, r21
    f67a:	41 f0       	breq	.+16     	; 0xf68c <main+0x22e>
   return 100; 
}

int lookupTable(uint16_t seq) { 
  int i;
  for (i=0; i<8; i++)
    f67c:	2f 5f       	subi	r18, 0xFF	; 255
    f67e:	3f 4f       	sbci	r19, 0xFF	; 255
    f680:	32 96       	adiw	r30, 0x02	; 2
    f682:	28 30       	cpi	r18, 0x08	; 8
    f684:	31 05       	cpc	r19, r1
    f686:	a9 f7       	brne	.-22     	; 0xf672 <main+0x214>
    f688:	24 e6       	ldi	r18, 0x64	; 100
    f68a:	30 e0       	ldi	r19, 0x00	; 0
               thread_table_start[indexThread].state =  STATE_ACTIVE; 
              }  
               else if (requestType == 2)
            	  {
            	  thread_table_start = getCurrentThread();
            		filename[5] = '1' +  lookupTable(seq); 
    f68c:	82 2f       	mov	r24, r18
    f68e:	8f 5c       	subi	r24, 0xCF	; 207
    f690:	80 93 bb 0c 	sts	0x0CBB, r24
               
                threadsize = sizeof(struct thread);
    f694:	10 93 ce 0c 	sts	0x0CCE, r17
                threadramsize =
    f698:	80 91 b3 0c 	lds	r24, 0x0CB3
    f69c:	81 9f       	mul	r24, r17
    f69e:	c0 01       	movw	r24, r0
    f6a0:	11 24       	eor	r1, r1
    f6a2:	e0 91 ae 0c 	lds	r30, 0x0CAE
    f6a6:	f0 91 af 0c 	lds	r31, 0x0CAF
    f6aa:	e8 0f       	add	r30, r24
    f6ac:	f9 1f       	adc	r31, r25
    f6ae:	83 89       	ldd	r24, Z+19	; 0x13
    f6b0:	94 89       	ldd	r25, Z+20	; 0x14
    f6b2:	01 96       	adiw	r24, 0x01	; 1
    f6b4:	21 89       	ldd	r18, Z+17	; 0x11
    f6b6:	32 89       	ldd	r19, Z+18	; 0x12
    f6b8:	82 1b       	sub	r24, r18
    f6ba:	93 0b       	sbc	r25, r19
    f6bc:	90 93 d0 0c 	sts	0x0CD0, r25
    f6c0:	80 93 cf 0c 	sts	0x0CCF, r24
                 (uint16_t) ((uint8_t *) thread_table_start[indexThread].ramend -
                    (uint8_t *) thread_table_start[indexThread].ramstart + 1);
                internal_ram_start = 
    f6c4:	30 93 d2 0c 	sts	0x0CD2, r19
    f6c8:	20 93 d1 0c 	sts	0x0CD1, r18
                (uint8_t *) thread_table_start[indexThread].ramstart;
               fp = mfopen((char *)filename, "r");
    f6cc:	86 eb       	ldi	r24, 0xB6	; 182
    f6ce:	9c e0       	ldi	r25, 0x0C	; 12
    f6d0:	62 e8       	ldi	r22, 0x82	; 130
    f6d2:	7c e0       	ldi	r23, 0x0C	; 12
    f6d4:	0e 94 c4 79 	call	0xf388	; 0xf388 <mfopen.1463>
    f6d8:	90 93 b5 0c 	sts	0x0CB5, r25
    f6dc:	80 93 b4 0c 	sts	0x0CB4, r24
               mfread(fp, &thread_table_start[indexThread], threadsize);
    f6e0:	20 91 b3 0c 	lds	r18, 0x0CB3
    f6e4:	21 9f       	mul	r18, r17
    f6e6:	90 01       	movw	r18, r0
    f6e8:	11 24       	eor	r1, r1
    f6ea:	60 91 ae 0c 	lds	r22, 0x0CAE
    f6ee:	70 91 af 0c 	lds	r23, 0x0CAF
    f6f2:	62 0f       	add	r22, r18
    f6f4:	73 1f       	adc	r23, r19
    f6f6:	40 91 ce 0c 	lds	r20, 0x0CCE
    f6fa:	50 e0       	ldi	r21, 0x00	; 0
    f6fc:	0e 94 4a 79 	call	0xf294	; 0xf294 <mfread.1469>
               mfseek(fp, threadsize, 1);
    f700:	60 91 ce 0c 	lds	r22, 0x0CCE
    f704:	80 91 b4 0c 	lds	r24, 0x0CB4
    f708:	90 91 b5 0c 	lds	r25, 0x0CB5
    f70c:	70 e0       	ldi	r23, 0x00	; 0
    f70e:	41 e0       	ldi	r20, 0x01	; 1
    f710:	50 e0       	ldi	r21, 0x00	; 0
    f712:	0e 94 89 78 	call	0xf112	; 0xf112 <mfseek.1477>
               mfread(fp, internal_ram_start, threadramsize);
    f716:	60 91 d1 0c 	lds	r22, 0x0CD1
    f71a:	70 91 d2 0c 	lds	r23, 0x0CD2
    f71e:	40 91 cf 0c 	lds	r20, 0x0CCF
    f722:	50 91 d0 0c 	lds	r21, 0x0CD0
    f726:	80 91 b4 0c 	lds	r24, 0x0CB4
    f72a:	90 91 b5 0c 	lds	r25, 0x0CB5
    f72e:	0e 94 4a 79 	call	0xf294	; 0xf294 <mfread.1469>
               mfclose(fp);	
    f732:	80 91 b4 0c 	lds	r24, 0x0CB4
    f736:	90 91 b5 0c 	lds	r25, 0x0CB5
    f73a:	0e 94 94 79 	call	0xf328	; 0xf328 <mfclose.1465>

			   thread_table_start[indexThread].state =  STATE_ACTIVE; 
    f73e:	80 91 b3 0c 	lds	r24, 0x0CB3
    f742:	81 9f       	mul	r24, r17
    f744:	c0 01       	movw	r24, r0
    f746:	11 24       	eor	r1, r1
    f748:	e0 91 ae 0c 	lds	r30, 0x0CAE
    f74c:	f0 91 af 0c 	lds	r31, 0x0CAF
    f750:	e8 0f       	add	r30, r24
    f752:	f9 1f       	adc	r31, r25
    f754:	02 83       	std	Z+2, r16	; 0x02
    f756:	db ce       	rjmp	.-586    	; 0xf50e <main+0xb0>

void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    f758:	0e 94 74 78 	call	0xf0e8	; 0xf0e8 <getCurrentThread.1326>
    f75c:	fc 01       	movw	r30, r24
     
   (*current_thread)->state = 5; 
    f75e:	01 90       	ld	r0, Z+
    f760:	f0 81       	ld	r31, Z
    f762:	e0 2d       	mov	r30, r0
    f764:	f2 82       	std	Z+2, r15	; 0x02


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f766:	fe 01       	movw	r30, r28
    f768:	09 95       	icall
    f76a:	d1 ce       	rjmp	.-606    	; 0xf50e <main+0xb0>

0000f76c <wakeupMe.3704>:

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
    f76c:	e0 91 d3 0c 	lds	r30, 0x0CD3
    f770:	f0 91 d4 0c 	lds	r31, 0x0CD4
    f774:	82 e0       	ldi	r24, 0x02	; 2
    f776:	82 83       	std	Z+2, r24	; 0x02


void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    f778:	e8 e6       	ldi	r30, 0x68	; 104
    f77a:	fa ee       	ldi	r31, 0xEA	; 234
    f77c:	09 95       	icall
  syscall_postThreadTask();
}
    f77e:	08 95       	ret

0000f780 <_exit>:
    f780:	f8 94       	cli

0000f782 <__stop_program>:
    f782:	ff cf       	rjmp	.-2      	; 0xf782 <__stop_program>
