
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000017a  00017200  00017200  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000004  00800b72  00800b72  000001ee  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  000001f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  000005f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  0000067c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  0000069c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000012b9  00000000  00000000  000006b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000001ba  00000000  00000000  00001970  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001ef  00000000  00000000  00001b2a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000050  00000000  00000000  00001d19  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000002da  00000000  00000000  00001d69  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000006e  00000000  00000000  00002043  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  000020b1  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00017200 <__vectors>:
   17200:	0c 94 46 b9 	jmp	0x1728c
   17204:	0c 94 63 b9 	jmp	0x172c6
   17208:	0c 94 63 b9 	jmp	0x172c6
   1720c:	0c 94 63 b9 	jmp	0x172c6
   17210:	0c 94 63 b9 	jmp	0x172c6
   17214:	0c 94 63 b9 	jmp	0x172c6
   17218:	0c 94 63 b9 	jmp	0x172c6
   1721c:	0c 94 63 b9 	jmp	0x172c6
   17220:	0c 94 63 b9 	jmp	0x172c6
   17224:	0c 94 63 b9 	jmp	0x172c6
   17228:	0c 94 63 b9 	jmp	0x172c6
   1722c:	0c 94 63 b9 	jmp	0x172c6
   17230:	0c 94 63 b9 	jmp	0x172c6
   17234:	0c 94 63 b9 	jmp	0x172c6
   17238:	0c 94 63 b9 	jmp	0x172c6
   1723c:	0c 94 63 b9 	jmp	0x172c6
   17240:	0c 94 63 b9 	jmp	0x172c6
   17244:	0c 94 63 b9 	jmp	0x172c6
   17248:	0c 94 63 b9 	jmp	0x172c6
   1724c:	0c 94 63 b9 	jmp	0x172c6
   17250:	0c 94 63 b9 	jmp	0x172c6
   17254:	0c 94 63 b9 	jmp	0x172c6
   17258:	0c 94 63 b9 	jmp	0x172c6
   1725c:	0c 94 63 b9 	jmp	0x172c6
   17260:	0c 94 63 b9 	jmp	0x172c6
   17264:	0c 94 63 b9 	jmp	0x172c6
   17268:	0c 94 63 b9 	jmp	0x172c6
   1726c:	0c 94 63 b9 	jmp	0x172c6
   17270:	0c 94 63 b9 	jmp	0x172c6
   17274:	0c 94 63 b9 	jmp	0x172c6
   17278:	0c 94 63 b9 	jmp	0x172c6
   1727c:	0c 94 63 b9 	jmp	0x172c6
   17280:	0c 94 63 b9 	jmp	0x172c6
   17284:	0c 94 63 b9 	jmp	0x172c6
   17288:	0c 94 63 b9 	jmp	0x172c6

0001728c <__ctors_end>:
   1728c:	11 24       	eor	r1, r1
   1728e:	1f be       	out	0x3f, r1	; 63
   17290:	c2 e6       	ldi	r28, 0x62	; 98
   17292:	dc e0       	ldi	r29, 0x0C	; 12
   17294:	de bf       	out	0x3e, r29	; 62
   17296:	cd bf       	out	0x3d, r28	; 61

00017298 <__do_copy_data>:
   17298:	1b e0       	ldi	r17, 0x0B	; 11
   1729a:	a2 e7       	ldi	r26, 0x72	; 114
   1729c:	bb e0       	ldi	r27, 0x0B	; 11
   1729e:	ea e7       	ldi	r30, 0x7A	; 122
   172a0:	f3 e7       	ldi	r31, 0x73	; 115
   172a2:	01 e0       	ldi	r16, 0x01	; 1
   172a4:	0b bf       	out	0x3b, r16	; 59
   172a6:	02 c0       	rjmp	.+4      	; 0x172ac
   172a8:	07 90       	elpm	r0, Z+
   172aa:	0d 92       	st	X+, r0
   172ac:	a2 37       	cpi	r26, 0x72	; 114
   172ae:	b1 07       	cpc	r27, r17
   172b0:	d9 f7       	brne	.-10     	; 0x172a8

000172b2 <__do_clear_bss>:
   172b2:	1b e0       	ldi	r17, 0x0B	; 11
   172b4:	a2 e7       	ldi	r26, 0x72	; 114
   172b6:	bb e0       	ldi	r27, 0x0B	; 11
   172b8:	01 c0       	rjmp	.+2      	; 0x172bc

000172ba <.do_clear_bss_loop>:
   172ba:	1d 92       	st	X+, r1

000172bc <.do_clear_bss_start>:
   172bc:	a6 37       	cpi	r26, 0x76	; 118
   172be:	b1 07       	cpc	r27, r17
   172c0:	e1 f7       	brne	.-8      	; 0x172ba
   172c2:	0c 94 65 b9 	jmp	0x172ca

000172c6 <__bad_interrupt>:
   172c6:	0c 94 00 b9 	jmp	0x17200

000172ca <main>:
 uint16_t index;
 uint8_t index2; 
  thread** current_thread;
 
 __asm__ __volatile__("sei" ::); 
   172ca:	78 94       	sei
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   172cc:	4f 93       	push	r20
   172ce:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   172d0:	ec e0       	ldi	r30, 0x0C	; 12
   172d2:	fa ee       	ldi	r31, 0xEA	; 234
   172d4:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   172d6:	a4 2f       	mov	r26, r20
   172d8:	b5 2f       	mov	r27, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   172da:	5f 91       	pop	r21
   172dc:	4f 91       	pop	r20
 

	  
    current_thread = getCurrentThread();  
    
   (*current_thread)->ecbptr->share = 500; 
   172de:	ed 91       	ld	r30, X+
   172e0:	fc 91       	ld	r31, X
   172e2:	11 97       	sbiw	r26, 0x01	; 1
   172e4:	05 a0       	ldd	r0, Z+37	; 0x25
   172e6:	f6 a1       	ldd	r31, Z+38	; 0x26
   172e8:	e0 2d       	mov	r30, r0
   172ea:	84 ef       	ldi	r24, 0xF4	; 244
   172ec:	81 83       	std	Z+1, r24	; 0x01
   (*current_thread)->ecbptr->totalenergy =  7500000; 
   172ee:	ed 91       	ld	r30, X+
   172f0:	fc 91       	ld	r31, X
   172f2:	05 a0       	ldd	r0, Z+37	; 0x25
   172f4:	f6 a1       	ldd	r31, Z+38	; 0x26
   172f6:	e0 2d       	mov	r30, r0
   172f8:	80 ee       	ldi	r24, 0xE0	; 224
   172fa:	90 e7       	ldi	r25, 0x70	; 112
   172fc:	a2 e7       	ldi	r26, 0x72	; 114
   172fe:	b0 e0       	ldi	r27, 0x00	; 0
   17300:	83 83       	std	Z+3, r24	; 0x03
   17302:	94 83       	std	Z+4, r25	; 0x04
   17304:	a5 83       	std	Z+5, r26	; 0x05
   17306:	b6 83       	std	Z+6, r27	; 0x06
   (*current_thread)->ecbptr->remainenergy = 7500000; 
   17308:	87 83       	std	Z+7, r24	; 0x07
   1730a:	90 87       	std	Z+8, r25	; 0x08
   1730c:	a1 87       	std	Z+9, r26	; 0x09
   1730e:	b2 87       	std	Z+10, r27	; 0x0a
     
   sbi(MCUCR, SM0);
   17310:	85 b7       	in	r24, 0x35	; 53
   17312:	88 60       	ori	r24, 0x08	; 8
   17314:	85 bf       	out	0x35, r24	; 53

   sbi(MCUCR, SM1);
   17316:	85 b7       	in	r24, 0x35	; 53
   17318:	80 61       	ori	r24, 0x10	; 16
   1731a:	85 bf       	out	0x35, r24	; 53
   cbi(MCUCR, SM2); 
   1731c:	85 b7       	in	r24, 0x35	; 53
   1731e:	8b 7f       	andi	r24, 0xFB	; 251
   17320:	85 bf       	out	0x35, r24	; 53
   sbi(MCUCR, SE);
   17322:	85 b7       	in	r24, 0x35	; 53
   17324:	80 62       	ori	r24, 0x20	; 32
   17326:	85 bf       	out	0x35, r24	; 53
   17328:	20 e0       	ldi	r18, 0x00	; 0
   1732a:	30 e0       	ldi	r19, 0x00	; 0
   1732c:	0e c0       	rjmp	.+28     	; 0x1734a
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}


void **getKernelStackPtr()
	{
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
}







uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
   1732e:	e0 e0       	ldi	r30, 0x00	; 0
   17330:	fa ee       	ldi	r31, 0xEA	; 234
   17332:	09 95       	icall
   17334:	f9 cf       	rjmp	.-14     	; 0x17328
   
   
   while(1)
   	{
	   
	   for (index=0;index<1200;index++)
	    for (index2=0;index2<123;index2++)
	        {
	        	__asm__ __volatile__("nop" ::); 
   17336:	00 00       	nop
   17338:	8f 5f       	subi	r24, 0xFF	; 255
   1733a:	8b 37       	cpi	r24, 0x7B	; 123
   1733c:	e1 f7       	brne	.-8      	; 0x17336
   1733e:	2f 5f       	subi	r18, 0xFF	; 255
   17340:	3f 4f       	sbci	r19, 0xFF	; 255
   17342:	84 e0       	ldi	r24, 0x04	; 4
   17344:	20 3b       	cpi	r18, 0xB0	; 176
   17346:	38 07       	cpc	r19, r24
   17348:	91 f3       	breq	.-28     	; 0x1732e
   1734a:	80 e0       	ldi	r24, 0x00	; 0
   1734c:	f4 cf       	rjmp	.-24     	; 0x17336

0001734e <syscall_postThreadTask.1410>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
   1734e:	e8 e6       	ldi	r30, 0x68	; 104
   17350:	fa ee       	ldi	r31, 0xEA	; 234
   17352:	09 95       	icall
   17354:	08 95       	ret

00017356 <wakeupMe.3689>:
//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
   17356:	e0 91 72 0b 	lds	r30, 0x0B72
   1735a:	f0 91 73 0b 	lds	r31, 0x0B73
   1735e:	82 e0       	ldi	r24, 0x02	; 2
   17360:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   17362:	0e 94 a7 b9 	call	0x1734e
   17366:	08 95       	ret

00017368 <wakeupMeSerial.4024>:
//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE;
   17368:	e0 91 74 0b 	lds	r30, 0x0B74
   1736c:	f0 91 75 0b 	lds	r31, 0x0B75
   17370:	82 e0       	ldi	r24, 0x02	; 2
   17372:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   17374:	0e 94 a7 b9 	call	0x1734e
   17378:	08 95       	ret
