
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000498  0000f000  0000f000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000062  00800c80  00800c80  0000050c  2**0
                  ALLOC
  2 .debug_aranges 00000020  00000000  00000000  0000050c  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 0000001b  00000000  00000000  0000052c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000019c8  00000000  00000000  00000547  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000002be  00000000  00000000  00001f0f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000004cd  00000000  00000000  000021cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000080  00000000  00000000  0000269c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000646  00000000  00000000  0000271c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000022a  00000000  00000000  00002d62  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000090  00000000  00000000  00002f8c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000f000 <__vectors>:
    f000:	0c 94 46 78 	jmp	0xf08c	; 0xf08c <__ctors_end>
    f004:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f008:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f00c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f010:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f014:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f018:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f01c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f020:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f024:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f028:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f02c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f030:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f034:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f038:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f03c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f040:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f044:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f048:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f04c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f050:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f054:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f058:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f05c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f060:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f064:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f068:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f06c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f070:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f074:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f078:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f07c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f080:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f084:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f088:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>

0000f08c <__ctors_end>:
    f08c:	11 24       	eor	r1, r1
    f08e:	1f be       	out	0x3f, r1	; 63
    f090:	cc ea       	ldi	r28, 0xAC	; 172
    f092:	dd e0       	ldi	r29, 0x0D	; 13
    f094:	de bf       	out	0x3e, r29	; 62
    f096:	cd bf       	out	0x3d, r28	; 61

0000f098 <__do_copy_data>:
    f098:	1c e0       	ldi	r17, 0x0C	; 12
    f09a:	a0 e8       	ldi	r26, 0x80	; 128
    f09c:	bc e0       	ldi	r27, 0x0C	; 12
    f09e:	e8 e9       	ldi	r30, 0x98	; 152
    f0a0:	f4 ef       	ldi	r31, 0xF4	; 244
    f0a2:	00 e0       	ldi	r16, 0x00	; 0
    f0a4:	0b bf       	out	0x3b, r16	; 59
    f0a6:	02 c0       	rjmp	.+4      	; 0xf0ac <__do_copy_data+0x14>
    f0a8:	07 90       	elpm	r0, Z+
    f0aa:	0d 92       	st	X+, r0
    f0ac:	a0 38       	cpi	r26, 0x80	; 128
    f0ae:	b1 07       	cpc	r27, r17
    f0b0:	d9 f7       	brne	.-10     	; 0xf0a8 <__do_copy_data+0x10>

0000f0b2 <__do_clear_bss>:
    f0b2:	1c e0       	ldi	r17, 0x0C	; 12
    f0b4:	a0 e8       	ldi	r26, 0x80	; 128
    f0b6:	bc e0       	ldi	r27, 0x0C	; 12
    f0b8:	01 c0       	rjmp	.+2      	; 0xf0bc <.do_clear_bss_start>

0000f0ba <.do_clear_bss_loop>:
    f0ba:	1d 92       	st	X+, r1

0000f0bc <.do_clear_bss_start>:
    f0bc:	a2 3e       	cpi	r26, 0xE2	; 226
    f0be:	b1 07       	cpc	r27, r17
    f0c0:	e1 f7       	brne	.-8      	; 0xf0ba <.do_clear_bss_loop>
    f0c2:	0e 94 e7 78 	call	0xf1ce	; 0xf1ce <main>
    f0c6:	0c 94 4a 7a 	jmp	0xf494	; 0xf494 <_exit>

0000f0ca <__bad_interrupt>:
    f0ca:	0c 94 00 78 	jmp	0xf000	; 0xf000 <__vectors>

0000f0ce <inserthistorytable.1522>:


void inserthistorytable(uint16_t nodeid, uint16_t randomid)
{

   historypackettable[indexOfPackets].valid = 1; 
    f0ce:	20 91 df 0c 	lds	r18, 0x0CDF
    f0d2:	30 e0       	ldi	r19, 0x00	; 0
    f0d4:	f9 01       	movw	r30, r18
    f0d6:	ee 0f       	add	r30, r30
    f0d8:	ff 1f       	adc	r31, r31
    f0da:	ee 0f       	add	r30, r30
    f0dc:	ff 1f       	adc	r31, r31
    f0de:	e2 0f       	add	r30, r18
    f0e0:	f3 1f       	adc	r31, r19
    f0e2:	e0 58       	subi	r30, 0x80	; 128
    f0e4:	f3 4f       	sbci	r31, 0xF3	; 243
    f0e6:	41 e0       	ldi	r20, 0x01	; 1
    f0e8:	44 83       	std	Z+4, r20	; 0x04
   historypackettable[indexOfPackets].nodeid = nodeid; 
    f0ea:	93 83       	std	Z+3, r25	; 0x03
    f0ec:	82 83       	std	Z+2, r24	; 0x02
   historypackettable[indexOfPackets].randomsig = randomid; 
    f0ee:	71 83       	std	Z+1, r23	; 0x01
    f0f0:	60 83       	st	Z, r22
   indexOfPackets = (indexOfPackets + 1)%HISTORYBUFFERSIZE;
    f0f2:	c9 01       	movw	r24, r18
    f0f4:	01 96       	adiw	r24, 0x01	; 1
    f0f6:	6a e0       	ldi	r22, 0x0A	; 10
    f0f8:	70 e0       	ldi	r23, 0x00	; 0
    f0fa:	0e 94 23 7a 	call	0xf446	; 0xf446 <__divmodhi4>
    f0fe:	80 93 df 0c 	sts	0x0CDF, r24
   return;  
}
    f102:	08 95       	ret

0000f104 <wakeupMeOnDataMsg.1532>:


//Handles incoming data msg. This usually wakesup the current thread 
void wakeupMeOnDataMsg() {

   thisthread->state = STATE_ACTIVE;
    f104:	e0 91 dd 0c 	lds	r30, 0x0CDD
    f108:	f0 91 de 0c 	lds	r31, 0x0CDE
    f10c:	82 e0       	ldi	r24, 0x02	; 2
    f10e:	82 83       	std	Z+2, r24	; 0x02


void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    f110:	e8 e6       	ldi	r30, 0x68	; 104
    f112:	fa ee       	ldi	r31, 0xEA	; 234
    f114:	09 95       	icall
   syscall_postThreadTask();    
}
    f116:	08 95       	ret

0000f118 <getCurrentThread.1326>:

thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f118:	4f 93       	push	r20
    f11a:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f11c:	ec e0       	ldi	r30, 0x0C	; 12
    f11e:	fa ee       	ldi	r31, 0xEA	; 234
    f120:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f122:	24 2f       	mov	r18, r20
    f124:	35 2f       	mov	r19, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f126:	5f 91       	pop	r21
    f128:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}
    f12a:	c9 01       	movw	r24, r18
    f12c:	08 95       	ret

0000f12e <sleepThread.1324>:
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
    f12e:	0f 93       	push	r16
    f130:	1f 93       	push	r17
    f132:	18 2f       	mov	r17, r24
    f134:	09 2f       	mov	r16, r25
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    f136:	0e 94 8c 78 	call	0xf118	; 0xf118 <getCurrentThread.1326>
    f13a:	dc 01       	movw	r26, r24
     
   (*current_thread)->state = 4;
    f13c:	ed 91       	ld	r30, X+
    f13e:	fc 91       	ld	r31, X
    f140:	11 97       	sbiw	r26, 0x01	; 1
    f142:	84 e0       	ldi	r24, 0x04	; 4
    f144:	82 83       	std	Z+2, r24	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    f146:	ed 91       	ld	r30, X+
    f148:	fc 91       	ld	r31, X
    f14a:	81 2f       	mov	r24, r17
    f14c:	90 2f       	mov	r25, r16
    f14e:	94 8f       	std	Z+28, r25	; 0x1c
    f150:	83 8f       	std	Z+27, r24	; 0x1b


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f152:	e0 e0       	ldi	r30, 0x00	; 0
    f154:	fa ee       	ldi	r31, 0xEA	; 234
    f156:	09 95       	icall
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}
    f158:	1f 91       	pop	r17
    f15a:	0f 91       	pop	r16
    f15c:	08 95       	ret

0000f15e <radioSend.1408>:




void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
    f15e:	bf 92       	push	r11
    f160:	cf 92       	push	r12
    f162:	df 92       	push	r13
    f164:	ef 92       	push	r14
    f166:	ff 92       	push	r15
    f168:	0f 93       	push	r16
    f16a:	1f 93       	push	r17
    f16c:	8c 01       	movw	r16, r24
    f16e:	7b 01       	movw	r14, r22
    f170:	b4 2e       	mov	r11, r20
    f172:	69 01       	movw	r12, r18

mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GET_RADIO_MUTEX_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f174:	4f 93       	push	r20
    f176:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f178:	e0 e1       	ldi	r30, 0x10	; 16
    f17a:	fa ee       	ldi	r31, 0xEA	; 234
    f17c:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f17e:	84 2f       	mov	r24, r20
    f180:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f182:	5f 91       	pop	r21
    f184:	4f 91       	pop	r20
   radioinfotype *radioinfoaddr;



   msend = getRadioMutexAddress();
   current_thread = getCurrentThread();
    f186:	0e 94 8c 78 	call	0xf118	; 0xf118 <getCurrentThread.1326>

radioinfotype *getCurrentRadioInfoAddr()
{
   radioinfotype *currentradioinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_INFO_ADDR;
   asm volatile("push r20" "\n\t"
    f18a:	4f 93       	push	r20
    f18c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
    f18e:	ec e5       	ldi	r30, 0x5C	; 92
    f190:	fa ee       	ldi	r31, 0xEA	; 234
    f192:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f194:	e4 2f       	mov	r30, r20
    f196:	f5 2f       	mov	r31, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f198:	5f 91       	pop	r21
    f19a:	4f 91       	pop	r20
   current_thread = getCurrentThread();
   radioinfoaddr = getCurrentRadioInfoAddr();

  // Mutex_lock(msend);

   radioinfoaddr-> socket_port = port;
    f19c:	11 83       	std	Z+1, r17	; 0x01
    f19e:	00 83       	st	Z, r16
   radioinfoaddr->socket_addr = address;
    f1a0:	f3 82       	std	Z+3, r15	; 0x03
    f1a2:	e2 82       	std	Z+2, r14	; 0x02
   radioinfoaddr->socket_msg_len  = length;
    f1a4:	b4 82       	std	Z+4, r11	; 0x04
   radioinfoaddr->socket_msg  = msg;
    f1a6:	d6 82       	std	Z+6, r13	; 0x06
    f1a8:	c5 82       	std	Z+5, r12	; 0x05
thread* mythread;

void sendRadioMsg()
{
 void (*radiosendfp)() = (void (*)(void))SOCKET_RADIO_SEND_FUNCTION;
 radiosendfp();
    f1aa:	e4 e1       	ldi	r30, 0x14	; 20
    f1ac:	fa ee       	ldi	r31, 0xEA	; 234
    f1ae:	09 95       	icall
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg();

   sleepThread(20);
    f1b0:	84 e1       	ldi	r24, 0x14	; 20
    f1b2:	90 e0       	ldi	r25, 0x00	; 0
    f1b4:	0e 94 97 78 	call	0xf12e	; 0xf12e <sleepThread.1324>
void disableRadioState()
{

   void (*disableradiofp)(void) = (void (*)(void))RESTORE_RADIO_STATE;

   disableradiofp();
    f1b8:	e8 eb       	ldi	r30, 0xB8	; 184
    f1ba:	fa ee       	ldi	r31, 0xEA	; 234
    f1bc:	09 95       	icall
   disableRadioState();

 //  Mutex_unlock(msend);

   return;
}
    f1be:	1f 91       	pop	r17
    f1c0:	0f 91       	pop	r16
    f1c2:	ff 90       	pop	r15
    f1c4:	ef 90       	pop	r14
    f1c6:	df 90       	pop	r13
    f1c8:	cf 90       	pop	r12
    f1ca:	bf 90       	pop	r11
    f1cc:	08 95       	ret

0000f1ce <main>:



//This is the entry point. It broadcasts neighbor exchanges perodically, or handles incoming packets (non-update neighbor)

int main() {
    f1ce:	2f 92       	push	r2
    f1d0:	3f 92       	push	r3
    f1d2:	4f 92       	push	r4
    f1d4:	5f 92       	push	r5
    f1d6:	6f 92       	push	r6
    f1d8:	7f 92       	push	r7
    f1da:	8f 92       	push	r8
    f1dc:	9f 92       	push	r9
    f1de:	af 92       	push	r10
    f1e0:	bf 92       	push	r11
    f1e2:	cf 92       	push	r12
    f1e4:	df 92       	push	r13
    f1e6:	ef 92       	push	r14
    f1e8:	ff 92       	push	r15
    f1ea:	0f 93       	push	r16
    f1ec:	1f 93       	push	r17
    f1ee:	df 93       	push	r29
    f1f0:	cf 93       	push	r28
    f1f2:	00 d0       	rcall	.+0      	; 0xf1f4 <main+0x26>
    f1f4:	0f 92       	push	r0
    f1f6:	cd b7       	in	r28, 0x3d	; 61
    f1f8:	de b7       	in	r29, 0x3e	; 62
    f1fa:	e4 e8       	ldi	r30, 0x84	; 132
    f1fc:	fc e0       	ldi	r31, 0x0C	; 12

//This function initlizes the neighhood table 
void initTable() {
   int i;
   for ( i = 0; i < HISTORYBUFFERSIZE; i ++ ) {
      historypackettable[ i ].valid = 0;
    f1fe:	10 82       	st	Z, r1
    f200:	35 96       	adiw	r30, 0x05	; 5


//This function initlizes the neighhood table 
void initTable() {
   int i;
   for ( i = 0; i < HISTORYBUFFERSIZE; i ++ ) {
    f202:	2c e0       	ldi	r18, 0x0C	; 12
    f204:	e6 3b       	cpi	r30, 0xB6	; 182
    f206:	f2 07       	cpc	r31, r18
    f208:	d1 f7       	brne	.-12     	; 0xf1fe <main+0x30>
      historypackettable[ i ].valid = 0;
   } 
   indexOfPackets = 0;
    f20a:	10 92 df 0c 	sts	0x0CDF, r1
uint16_t getnodeID()
	{

	   int ret;
	   void (*fp)(void) = (void (*)(void))GET_NODE_ID_FUNCTION;
	   asm volatile("push r20" "\n\t"
    f20e:	4f 93       	push	r20
    f210:	5f 93       	push	r21
					"push r21" "\n\t"
					::);
	   fp();
    f212:	ec ec       	ldi	r30, 0xCC	; 204
    f214:	fa ee       	ldi	r31, 0xEA	; 234
    f216:	09 95       	icall
	   asm volatile(" mov %A0, r20" "\n\t"
    f218:	e4 2e       	mov	r14, r20
    f21a:	f5 2e       	mov	r15, r21
					  "mov %B0, r21" "\n\t"
					 :"=r" (ret)
					 :
					);
	   asm volatile("pop r21" "\n\t"
    f21c:	5f 91       	pop	r21
    f21e:	4f 91       	pop	r20
   initTable();
   nodeid = getnodeID();
   
   //register both the negibhorhood update and the message incoming 

   thiscurrentthread = getCurrentThread(); 
    f220:	0e 94 8c 78 	call	0xf118	; 0xf118 <getCurrentThread.1326>
    f224:	fc 01       	movw	r30, r24
    f226:	90 93 dc 0c 	sts	0x0CDC, r25
    f22a:	80 93 db 0c 	sts	0x0CDB, r24
   thisthread = *thiscurrentthread; 
    f22e:	80 81       	ld	r24, Z
    f230:	91 81       	ldd	r25, Z+1	; 0x01
    f232:	90 93 de 0c 	sts	0x0CDE, r25
    f236:	80 93 dd 0c 	sts	0x0CDD, r24
{
   radiohandletype *currentradioinfo;

   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_HANDLE_ADDR;

   asm volatile("push r20" "\n\t"
    f23a:	4f 93       	push	r20
    f23c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
    f23e:	e0 e6       	ldi	r30, 0x60	; 96
    f240:	fa ee       	ldi	r31, 0xEA	; 234
    f242:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f244:	e4 2f       	mov	r30, r20
    f246:	f5 2f       	mov	r31, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f248:	5f 91       	pop	r21
    f24a:	4f 91       	pop	r20
   void (*getaddrfp)(void) = (void (*)(void))REGISTER_RADIO_RECEIVE_EVENT; 

   //Finds the radio handle, so that when this code is ported to be externally used, it will be obtained via a system call 
   radiohandleaddr =  getCurrentRadioHandleAddr();

   incomingDataLength = 0;
    f24c:	10 92 d2 0c 	sts	0x0CD2, r1
   
   //set up the radiohandleaddr data structures
   radiohandleaddr->port = 20;
    f250:	84 e1       	ldi	r24, 0x14	; 20
    f252:	90 e0       	ldi	r25, 0x00	; 0
    f254:	91 83       	std	Z+1, r25	; 0x01
    f256:	80 83       	st	Z, r24
   radiohandleaddr->maxLength = 32;
    f258:	80 e2       	ldi	r24, 0x20	; 32
    f25a:	82 83       	std	Z+2, r24	; 0x02
   radiohandleaddr->dataReady = &incomingDataLength;
    f25c:	82 ed       	ldi	r24, 0xD2	; 210
    f25e:	9c e0       	ldi	r25, 0x0C	; 12
    f260:	94 83       	std	Z+4, r25	; 0x04
    f262:	83 83       	std	Z+3, r24	; 0x03
   radiohandleaddr->data = incomingMsg;
    f264:	82 eb       	ldi	r24, 0xB2	; 178
    f266:	9c e0       	ldi	r25, 0x0C	; 12
    f268:	96 83       	std	Z+6, r25	; 0x06
    f26a:	85 83       	std	Z+5, r24	; 0x05
   radiohandleaddr->packetinfo = incomingPacketInfo;
    f26c:	83 ed       	ldi	r24, 0xD3	; 211
    f26e:	9c e0       	ldi	r25, 0x0C	; 12
    f270:	90 87       	std	Z+8, r25	; 0x08
    f272:	87 83       	std	Z+7, r24	; 0x07
   radiohandleaddr->handlefunc = wakeupMeOnDataMsg;
    f274:	82 e8       	ldi	r24, 0x82	; 130
    f276:	98 e7       	ldi	r25, 0x78	; 120
    f278:	93 87       	std	Z+11, r25	; 0x0b
    f27a:	82 87       	std	Z+10, r24	; 0x0a
volatile uint16_t * old_stack_ptr ;


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
    f27c:	1f b7       	in	r17, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
    f27e:	f8 94       	cli

   //close the interrupt     
   currentatomic = _atomic_start();
   
   //call the radio handle set to store the data structure into the handle vectors 
   getaddrfp();     
    f280:	e4 e6       	ldi	r30, 0x64	; 100
    f282:	fa ee       	ldi	r31, 0xEA	; 234
    f284:	09 95       	icall



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
    f286:	1f bf       	out	0x3f, r17	; 63
   thiscurrentthread = getCurrentThread(); 
   thisthread = *thiscurrentthread; 
      
   registerDataPacket();

   packetsreceived = packetsdelivered = 0; 
    f288:	10 92 da 0c 	sts	0x0CDA, r1
    f28c:	10 92 d9 0c 	sts	0x0CD9, r1
    f290:	10 92 d8 0c 	sts	0x0CD8, r1
    f294:	10 92 d7 0c 	sts	0x0CD7, r1

		 if ((nodeid == incomingnodeid)&&(historycheck(incomingnodeid, randomsig) == 0))
		 	{
    		 	inserthistorytable(incomingnodeid, randomsig); 
				incomingMsg[5] = nodeid%256; 
				incomingMsg[6] = nodeid/256; 
    f298:	f9 82       	std	Y+1, r15	; 0x01


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f29a:	21 2c       	mov	r2, r1
    f29c:	6a ee       	ldi	r22, 0xEA	; 234
    f29e:	36 2e       	mov	r3, r22
	 int ret;
   void (*getrandomfp)(void) = (void (*)(void))GET_RANDOM_NUMBER_FUNCTION;
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getrandomfp();
    f2a0:	5c eb       	ldi	r21, 0xBC	; 188
    f2a2:	45 2e       	mov	r4, r21
    f2a4:	5a ee       	ldi	r21, 0xEA	; 234
    f2a6:	55 2e       	mov	r5, r21

		 else if (historycheck(incomingnodeid, randomsig) == 0)
		 	{
             
				comingnodeid = incomingMsg[5];
				if ((comingnodeid != nodeid -1 )&&( comingnodeid!=nodeid+1))
    f2a8:	37 01       	movw	r6, r14
    f2aa:	08 94       	sec
    f2ac:	61 08       	sbc	r6, r1
    f2ae:	71 08       	sbc	r7, r1
    f2b0:	47 01       	movw	r8, r14
    f2b2:	08 94       	sec
    f2b4:	81 1c       	adc	r8, r1
    f2b6:	91 1c       	adc	r9, r1

void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    f2b8:	0e 94 8c 78 	call	0xf118	; 0xf118 <getCurrentThread.1326>
    f2bc:	fc 01       	movw	r30, r24
     
   (*current_thread)->state = 5; 
    f2be:	01 90       	ld	r0, Z+
    f2c0:	f0 81       	ld	r31, Z
    f2c2:	e0 2d       	mov	r30, r0
    f2c4:	35 e0       	ldi	r19, 0x05	; 5
    f2c6:	32 83       	std	Z+2, r19	; 0x02


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f2c8:	f1 01       	movw	r30, r2
    f2ca:	09 95       	icall

		 temp  = incomingMsg[ 0 ];
		 
		 incomingnodeid += ((uint16_t)temp); 
		 temp = incomingMsg[ 1 ];
		 incomingnodeid += ((uint16_t)temp) * 256;
    f2cc:	b0 90 b3 0c 	lds	r11, 0x0CB3
    f2d0:	aa 24       	eor	r10, r10
    f2d2:	80 91 b2 0c 	lds	r24, 0x0CB2
    f2d6:	85 01       	movw	r16, r10
    f2d8:	08 0f       	add	r16, r24
    f2da:	11 1d       	adc	r17, r1
         randomsig = 0; 
		 temp = incomingMsg[ 2 ];
		 randomsig += ((uint16_t)temp);

   	     temp = incomingMsg[ 3 ];
		 randomsig += ((uint16_t)temp) * 256;
    f2dc:	d0 90 b5 0c 	lds	r13, 0x0CB5
    f2e0:	cc 24       	eor	r12, r12
    f2e2:	80 91 b4 0c 	lds	r24, 0x0CB4
    f2e6:	a6 01       	movw	r20, r12
    f2e8:	48 0f       	add	r20, r24
    f2ea:	51 1d       	adc	r21, r1
    f2ec:	5b 83       	std	Y+3, r21	; 0x03
    f2ee:	4a 83       	std	Y+2, r20	; 0x02

		 portnum = incomingMsg[4]; 
    f2f0:	20 91 b6 0c 	lds	r18, 0x0CB6

		 if ((nodeid == incomingnodeid)&&(historycheck(incomingnodeid, randomsig) == 0))
    f2f4:	e0 16       	cp	r14, r16
    f2f6:	f1 06       	cpc	r15, r17
    f2f8:	b9 f4       	brne	.+46     	; 0xf328 <main+0x15a>
    f2fa:	e0 e8       	ldi	r30, 0x80	; 128
    f2fc:	fc e0       	ldi	r31, 0x0C	; 12

uint8_t historycheck(uint16_t nodeid, uint16_t randomid)
{
   uint8_t i; 
   for (i=0; i < HISTORYBUFFERSIZE; i++) {
   	 if (historypackettable[i].valid == 0)
    f2fe:	84 81       	ldd	r24, Z+4	; 0x04
    f300:	88 23       	and	r24, r24
    f302:	61 f0       	breq	.+24     	; 0xf31c <main+0x14e>
	 	continue;
	 if ((historypackettable[i].randomsig == randomid ) && (historypackettable[i].nodeid == nodeid))
    f304:	80 81       	ld	r24, Z
    f306:	91 81       	ldd	r25, Z+1	; 0x01
    f308:	4a 81       	ldd	r20, Y+2	; 0x02
    f30a:	5b 81       	ldd	r21, Y+3	; 0x03
    f30c:	84 17       	cp	r24, r20
    f30e:	95 07       	cpc	r25, r21
    f310:	29 f4       	brne	.+10     	; 0xf31c <main+0x14e>
    f312:	82 81       	ldd	r24, Z+2	; 0x02
    f314:	93 81       	ldd	r25, Z+3	; 0x03
    f316:	8e 15       	cp	r24, r14
    f318:	9f 05       	cpc	r25, r15
    f31a:	31 f0       	breq	.+12     	; 0xf328 <main+0x15a>
    f31c:	35 96       	adiw	r30, 0x05	; 5


uint8_t historycheck(uint16_t nodeid, uint16_t randomid)
{
   uint8_t i; 
   for (i=0; i < HISTORYBUFFERSIZE; i++) {
    f31e:	5c e0       	ldi	r21, 0x0C	; 12
    f320:	e2 3b       	cpi	r30, 0xB2	; 178
    f322:	f5 07       	cpc	r31, r21
    f324:	61 f7       	brne	.-40     	; 0xf2fe <main+0x130>
    f326:	50 c0       	rjmp	.+160    	; 0xf3c8 <main+0x1fa>
    f328:	e0 e8       	ldi	r30, 0x80	; 128
    f32a:	fc e0       	ldi	r31, 0x0C	; 12
   	 if (historypackettable[i].valid == 0)
    f32c:	84 81       	ldd	r24, Z+4	; 0x04
    f32e:	88 23       	and	r24, r24
    f330:	69 f0       	breq	.+26     	; 0xf34c <main+0x17e>
	 	continue;
	 if ((historypackettable[i].randomsig == randomid ) && (historypackettable[i].nodeid == nodeid))
    f332:	80 81       	ld	r24, Z
    f334:	91 81       	ldd	r25, Z+1	; 0x01
    f336:	4a 81       	ldd	r20, Y+2	; 0x02
    f338:	5b 81       	ldd	r21, Y+3	; 0x03
    f33a:	84 17       	cp	r24, r20
    f33c:	95 07       	cpc	r25, r21
    f33e:	31 f4       	brne	.+12     	; 0xf34c <main+0x17e>
    f340:	82 81       	ldd	r24, Z+2	; 0x02
    f342:	93 81       	ldd	r25, Z+3	; 0x03
    f344:	80 17       	cp	r24, r16
    f346:	91 07       	cpc	r25, r17
    f348:	09 f4       	brne	.+2      	; 0xf34c <main+0x17e>
    f34a:	b6 cf       	rjmp	.-148    	; 0xf2b8 <main+0xea>
    f34c:	35 96       	adiw	r30, 0x05	; 5


uint8_t historycheck(uint16_t nodeid, uint16_t randomid)
{
   uint8_t i; 
   for (i=0; i < HISTORYBUFFERSIZE; i++) {
    f34e:	5c e0       	ldi	r21, 0x0C	; 12
    f350:	e2 3b       	cpi	r30, 0xB2	; 178
    f352:	f5 07       	cpc	r31, r21
    f354:	59 f7       	brne	.-42     	; 0xf32c <main+0x15e>
    f356:	65 c0       	rjmp	.+202    	; 0xf422 <main+0x254>

		 else if (historycheck(incomingnodeid, randomsig) == 0)
		 	{
             
				comingnodeid = incomingMsg[5];
				if ((comingnodeid != nodeid -1 )&&( comingnodeid!=nodeid+1))
    f358:	88 15       	cp	r24, r8
    f35a:	99 05       	cpc	r25, r9
    f35c:	09 f0       	breq	.+2      	; 0xf360 <main+0x192>
    f35e:	ac cf       	rjmp	.-168    	; 0xf2b8 <main+0xea>
					{
					}
				else
					{
                radioSend(portnum, 0, incomingDataLength, incomingMsg); 
    f360:	82 2f       	mov	r24, r18
    f362:	90 e0       	ldi	r25, 0x00	; 0
    f364:	60 e0       	ldi	r22, 0x00	; 0
    f366:	70 e0       	ldi	r23, 0x00	; 0
    f368:	40 91 d2 0c 	lds	r20, 0x0CD2
    f36c:	22 eb       	ldi	r18, 0xB2	; 178
    f36e:	3c e0       	ldi	r19, 0x0C	; 12
    f370:	0e 94 af 78 	call	0xf15e	; 0xf15e <radioSend.1408>
				
				inserthistorytable(incomingnodeid, randomsig); 
    f374:	c8 01       	movw	r24, r16
    f376:	6a 81       	ldd	r22, Y+2	; 0x02
    f378:	7b 81       	ldd	r23, Y+3	; 0x03
    f37a:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <inserthistorytable.1522>

				incomingMsg[5] = nodeid%256;
    f37e:	e0 92 b7 0c 	sts	0x0CB7, r14
int rnd()
{

	 int ret;
   void (*getrandomfp)(void) = (void (*)(void))GET_RANDOM_NUMBER_FUNCTION;
   asm volatile("push r20" "\n\t"
    f382:	4f 93       	push	r20
    f384:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getrandomfp();
    f386:	f2 01       	movw	r30, r4
    f388:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f38a:	84 2f       	mov	r24, r20
    f38c:	95 2f       	mov	r25, r21
	              "mov %B0, r21" "\n\t"
				 :"=r" (ret)
				 :
                );
   asm volatile("pop r21" "\n\t"
    f38e:	5f 91       	pop	r21
    f390:	4f 91       	pop	r20
				
				jitter = rnd()%20;
				sleepThread(jitter); 
    f392:	64 e1       	ldi	r22, 0x14	; 20
    f394:	70 e0       	ldi	r23, 0x00	; 0
    f396:	0e 94 23 7a 	call	0xf446	; 0xf446 <__divmodhi4>
    f39a:	90 e0       	ldi	r25, 0x00	; 0
    f39c:	0e 94 97 78 	call	0xf12e	; 0xf12e <sleepThread.1324>
				radioSend(20, 0xffff, incomingDataLength, incomingMsg);
    f3a0:	84 e1       	ldi	r24, 0x14	; 20
    f3a2:	90 e0       	ldi	r25, 0x00	; 0
    f3a4:	6f ef       	ldi	r22, 0xFF	; 255
    f3a6:	7f ef       	ldi	r23, 0xFF	; 255
    f3a8:	40 91 d2 0c 	lds	r20, 0x0CD2
    f3ac:	22 eb       	ldi	r18, 0xB2	; 178
    f3ae:	3c e0       	ldi	r19, 0x0C	; 12
    f3b0:	0e 94 af 78 	call	0xf15e	; 0xf15e <radioSend.1408>
				packetsdelivered++; 
    f3b4:	80 91 d9 0c 	lds	r24, 0x0CD9
    f3b8:	90 91 da 0c 	lds	r25, 0x0CDA
    f3bc:	01 96       	adiw	r24, 0x01	; 1
    f3be:	90 93 da 0c 	sts	0x0CDA, r25
    f3c2:	80 93 d9 0c 	sts	0x0CD9, r24
    f3c6:	78 cf       	rjmp	.-272    	; 0xf2b8 <main+0xea>

		 portnum = incomingMsg[4]; 

		 if ((nodeid == incomingnodeid)&&(historycheck(incomingnodeid, randomsig) == 0))
		 	{
    		 	inserthistorytable(incomingnodeid, randomsig); 
    f3c8:	c7 01       	movw	r24, r14
    f3ca:	6a 81       	ldd	r22, Y+2	; 0x02
    f3cc:	7b 81       	ldd	r23, Y+3	; 0x03
    f3ce:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <inserthistorytable.1522>
				incomingMsg[5] = nodeid%256; 
    f3d2:	e0 92 b7 0c 	sts	0x0CB7, r14
				incomingMsg[6] = nodeid/256; 
    f3d6:	89 81       	ldd	r24, Y+1	; 0x01
    f3d8:	80 93 b8 0c 	sts	0x0CB8, r24
int rnd()
{

	 int ret;
   void (*getrandomfp)(void) = (void (*)(void))GET_RANDOM_NUMBER_FUNCTION;
   asm volatile("push r20" "\n\t"
    f3dc:	4f 93       	push	r20
    f3de:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getrandomfp();
    f3e0:	f2 01       	movw	r30, r4
    f3e2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f3e4:	84 2f       	mov	r24, r20
    f3e6:	95 2f       	mov	r25, r21
	              "mov %B0, r21" "\n\t"
				 :"=r" (ret)
				 :
                );
   asm volatile("pop r21" "\n\t"
    f3e8:	5f 91       	pop	r21
    f3ea:	4f 91       	pop	r20
				
				jitter = rnd()%20;
				sleepThread(jitter); 
    f3ec:	64 e1       	ldi	r22, 0x14	; 20
    f3ee:	70 e0       	ldi	r23, 0x00	; 0
    f3f0:	0e 94 23 7a 	call	0xf446	; 0xf446 <__divmodhi4>
    f3f4:	90 e0       	ldi	r25, 0x00	; 0
    f3f6:	0e 94 97 78 	call	0xf12e	; 0xf12e <sleepThread.1324>
				radioSend(20, 0xffff, incomingDataLength, incomingMsg);
    f3fa:	84 e1       	ldi	r24, 0x14	; 20
    f3fc:	90 e0       	ldi	r25, 0x00	; 0
    f3fe:	6f ef       	ldi	r22, 0xFF	; 255
    f400:	7f ef       	ldi	r23, 0xFF	; 255
    f402:	40 91 d2 0c 	lds	r20, 0x0CD2
    f406:	22 eb       	ldi	r18, 0xB2	; 178
    f408:	3c e0       	ldi	r19, 0x0C	; 12
    f40a:	0e 94 af 78 	call	0xf15e	; 0xf15e <radioSend.1408>
				packetsreceived ++; 
    f40e:	80 91 d7 0c 	lds	r24, 0x0CD7
    f412:	90 91 d8 0c 	lds	r25, 0x0CD8
    f416:	01 96       	adiw	r24, 0x01	; 1
    f418:	90 93 d8 0c 	sts	0x0CD8, r25
    f41c:	80 93 d7 0c 	sts	0x0CD7, r24
    f420:	4b cf       	rjmp	.-362    	; 0xf2b8 <main+0xea>
		 

		 else if (historycheck(incomingnodeid, randomsig) == 0)
		 	{
             
				comingnodeid = incomingMsg[5];
    f422:	80 91 b7 0c 	lds	r24, 0x0CB7
    f426:	90 e0       	ldi	r25, 0x00	; 0
				if ((comingnodeid != nodeid -1 )&&( comingnodeid!=nodeid+1))
    f428:	86 15       	cp	r24, r6
    f42a:	97 05       	cpc	r25, r7
    f42c:	09 f0       	breq	.+2      	; 0xf430 <main+0x262>
    f42e:	94 cf       	rjmp	.-216    	; 0xf358 <main+0x18a>
    f430:	97 cf       	rjmp	.-210    	; 0xf360 <main+0x192>

0000f432 <wakeupMe.3678>:

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
    f432:	e0 91 e0 0c 	lds	r30, 0x0CE0
    f436:	f0 91 e1 0c 	lds	r31, 0x0CE1
    f43a:	82 e0       	ldi	r24, 0x02	; 2
    f43c:	82 83       	std	Z+2, r24	; 0x02


void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    f43e:	e8 e6       	ldi	r30, 0x68	; 104
    f440:	fa ee       	ldi	r31, 0xEA	; 234
    f442:	09 95       	icall
  syscall_postThreadTask();
}
    f444:	08 95       	ret

0000f446 <__divmodhi4>:
    f446:	97 fb       	bst	r25, 7
    f448:	09 2e       	mov	r0, r25
    f44a:	07 26       	eor	r0, r23
    f44c:	0a d0       	rcall	.+20     	; 0xf462 <__divmodhi4_neg1>
    f44e:	77 fd       	sbrc	r23, 7
    f450:	04 d0       	rcall	.+8      	; 0xf45a <__divmodhi4_neg2>
    f452:	0c d0       	rcall	.+24     	; 0xf46c <__udivmodhi4>
    f454:	06 d0       	rcall	.+12     	; 0xf462 <__divmodhi4_neg1>
    f456:	00 20       	and	r0, r0
    f458:	1a f4       	brpl	.+6      	; 0xf460 <__divmodhi4_exit>

0000f45a <__divmodhi4_neg2>:
    f45a:	70 95       	com	r23
    f45c:	61 95       	neg	r22
    f45e:	7f 4f       	sbci	r23, 0xFF	; 255

0000f460 <__divmodhi4_exit>:
    f460:	08 95       	ret

0000f462 <__divmodhi4_neg1>:
    f462:	f6 f7       	brtc	.-4      	; 0xf460 <__divmodhi4_exit>
    f464:	90 95       	com	r25
    f466:	81 95       	neg	r24
    f468:	9f 4f       	sbci	r25, 0xFF	; 255
    f46a:	08 95       	ret

0000f46c <__udivmodhi4>:
    f46c:	aa 1b       	sub	r26, r26
    f46e:	bb 1b       	sub	r27, r27
    f470:	51 e1       	ldi	r21, 0x11	; 17
    f472:	07 c0       	rjmp	.+14     	; 0xf482 <__udivmodhi4_ep>

0000f474 <__udivmodhi4_loop>:
    f474:	aa 1f       	adc	r26, r26
    f476:	bb 1f       	adc	r27, r27
    f478:	a6 17       	cp	r26, r22
    f47a:	b7 07       	cpc	r27, r23
    f47c:	10 f0       	brcs	.+4      	; 0xf482 <__udivmodhi4_ep>
    f47e:	a6 1b       	sub	r26, r22
    f480:	b7 0b       	sbc	r27, r23

0000f482 <__udivmodhi4_ep>:
    f482:	88 1f       	adc	r24, r24
    f484:	99 1f       	adc	r25, r25
    f486:	5a 95       	dec	r21
    f488:	a9 f7       	brne	.-22     	; 0xf474 <__udivmodhi4_loop>
    f48a:	80 95       	com	r24
    f48c:	90 95       	com	r25
    f48e:	bc 01       	movw	r22, r24
    f490:	cd 01       	movw	r24, r26
    f492:	08 95       	ret

0000f494 <_exit>:
    f494:	f8 94       	cli

0000f496 <__stop_program>:
    f496:	ff cf       	rjmp	.-2      	; 0xf496 <__stop_program>
