
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800c80  0000f352  000003e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000352  0000f000  0000f000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000016  00800ca0  00800ca0  00000406  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00000406  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000001b  00000000  00000000  00000426  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001553  00000000  00000000  00000441  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002d0  00000000  00000000  00001994  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000484  00000000  00000000  00001c64  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000060  00000000  00000000  000020e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000051c  00000000  00000000  00002148  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000159  00000000  00000000  00002664  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001c8  00000000  00000000  000027bd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000f000 <__vectors>:
    f000:	0c 94 46 78 	jmp	0xf08c	; 0xf08c <__ctors_end>
    f004:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f008:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f00c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f010:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f014:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f018:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f01c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f020:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f024:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f028:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f02c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f030:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f034:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f038:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f03c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f040:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f044:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f048:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f04c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f050:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f054:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f058:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f05c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f060:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f064:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f068:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f06c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f070:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f074:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f078:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f07c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f080:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f084:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f088:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>

0000f08c <__ctors_end>:
    f08c:	11 24       	eor	r1, r1
    f08e:	1f be       	out	0x3f, r1	; 63
    f090:	cc ea       	ldi	r28, 0xAC	; 172
    f092:	dd e0       	ldi	r29, 0x0D	; 13
    f094:	de bf       	out	0x3e, r29	; 62
    f096:	cd bf       	out	0x3d, r28	; 61

0000f098 <__do_copy_data>:
    f098:	1c e0       	ldi	r17, 0x0C	; 12
    f09a:	a0 e8       	ldi	r26, 0x80	; 128
    f09c:	bc e0       	ldi	r27, 0x0C	; 12
    f09e:	e2 e5       	ldi	r30, 0x52	; 82
    f0a0:	f3 ef       	ldi	r31, 0xF3	; 243
    f0a2:	00 e0       	ldi	r16, 0x00	; 0
    f0a4:	0b bf       	out	0x3b, r16	; 59
    f0a6:	02 c0       	rjmp	.+4      	; 0xf0ac <__do_copy_data+0x14>
    f0a8:	07 90       	elpm	r0, Z+
    f0aa:	0d 92       	st	X+, r0
    f0ac:	a0 3a       	cpi	r26, 0xA0	; 160
    f0ae:	b1 07       	cpc	r27, r17
    f0b0:	d9 f7       	brne	.-10     	; 0xf0a8 <__do_copy_data+0x10>

0000f0b2 <__do_clear_bss>:
    f0b2:	1c e0       	ldi	r17, 0x0C	; 12
    f0b4:	a0 ea       	ldi	r26, 0xA0	; 160
    f0b6:	bc e0       	ldi	r27, 0x0C	; 12
    f0b8:	01 c0       	rjmp	.+2      	; 0xf0bc <.do_clear_bss_start>

0000f0ba <.do_clear_bss_loop>:
    f0ba:	1d 92       	st	X+, r1

0000f0bc <.do_clear_bss_start>:
    f0bc:	a6 3b       	cpi	r26, 0xB6	; 182
    f0be:	b1 07       	cpc	r27, r17
    f0c0:	e1 f7       	brne	.-8      	; 0xf0ba <.do_clear_bss_loop>
    f0c2:	0e 94 b8 78 	call	0xf170	; 0xf170 <main>
    f0c6:	0c 94 a7 79 	jmp	0xf34e	; 0xf34e <_exit>

0000f0ca <__bad_interrupt>:
    f0ca:	0c 94 00 78 	jmp	0xf000	; 0xf000 <__vectors>

0000f0ce <getCurrentThread.1326>:

thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f0ce:	4f 93       	push	r20
    f0d0:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f0d2:	ec e0       	ldi	r30, 0x0C	; 12
    f0d4:	fa ee       	ldi	r31, 0xEA	; 234
    f0d6:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f0d8:	24 2f       	mov	r18, r20
    f0da:	35 2f       	mov	r19, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f0dc:	5f 91       	pop	r21
    f0de:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}
    f0e0:	c9 01       	movw	r24, r18
    f0e2:	08 95       	ret

0000f0e4 <wakeupMe.3550>:

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
    f0e4:	e0 91 b3 0c 	lds	r30, 0x0CB3
    f0e8:	f0 91 b4 0c 	lds	r31, 0x0CB4
    f0ec:	82 e0       	ldi	r24, 0x02	; 2
    f0ee:	82 83       	std	Z+2, r24	; 0x02


void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    f0f0:	e8 e6       	ldi	r30, 0x68	; 104
    f0f2:	fa ee       	ldi	r31, 0xEA	; 234
    f0f4:	09 95       	icall
  syscall_postThreadTask();
}
    f0f6:	08 95       	ret

0000f0f8 <usartPrint.1431>:
    status = 0;
}

//-------------------------------------------------------------------------
void usartPrint(uint8_t c)
{
    f0f8:	28 2f       	mov	r18, r24
volatile uint16_t * old_stack_ptr ;


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
    f0fa:	9f b7       	in	r25, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
    f0fc:	f8 94       	cli

   flag = _atomic_start();
    f0fe:	90 93 b5 0c 	sts	0x0CB5, r25
     

    if (cFlag == 0)
    f102:	80 91 a0 0c 	lds	r24, 0x0CA0
    f106:	88 23       	and	r24, r24
    f108:	a1 f4       	brne	.+40     	; 0xf132 <usartPrint.1431+0x3a>

//No need to be called from main 
//This function is called when the system is being initilized and prints system start 
void initUSART()
{
    UBRR0H = 0;
    f10a:	10 92 90 00 	sts	0x0090, r1
    UBRR0L = 15;
    f10e:	8f e0       	ldi	r24, 0x0F	; 15
    f110:	89 b9       	out	0x09, r24	; 9
    UCSR0A |= _BV(U2X0);        // double speed
    f112:	59 9a       	sbi	0x0b, 1	; 11
    UCSR0C |= _BV(UCSZ01) | _BV(UCSZ00);        // 8 data-bits, 1 stop-bit
    f114:	80 91 95 00 	lds	r24, 0x0095
    f118:	86 60       	ori	r24, 0x06	; 6
    f11a:	80 93 95 00 	sts	0x0095, r24
    UCSR0B |= _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
    f11e:	8a b1       	in	r24, 0x0a	; 10
    f120:	88 69       	ori	r24, 0x98	; 152
    f122:	8a b9       	out	0x0a, r24	; 10
    // Enable recieve/transmit/interrupts
    cFlag = 1;
    f124:	81 e0       	ldi	r24, 0x01	; 1
    f126:	80 93 a0 0c 	sts	0x0CA0, r24
    previous = 0;
    f12a:	10 92 a1 0c 	sts	0x0CA1, r1
    status = 0;
    f12e:	10 92 a2 0c 	sts	0x0CA2, r1

    if (cFlag == 0)
    {
        initUSART();
    }
    while ((UCSR0A & (1 << UDRE0)) == 0)
    f132:	5d 9b       	sbis	0x0b, 5	; 11
    f134:	fe cf       	rjmp	.-4      	; 0xf132 <usartPrint.1431+0x3a>
        ;
    UDR0 = c;
    f136:	2c b9       	out	0x0c, r18	; 12



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
    f138:	9f bf       	out	0x3f, r25	; 63
	
    _atomic_end(flag);
}
    f13a:	08 95       	ret

0000f13c <printString.4277>:
}


//-------------------------------------------------------------------------
void printString(char *p)
{
    f13c:	cf 93       	push	r28
    f13e:	df 93       	push	r29
    f140:	ec 01       	movw	r28, r24
volatile uint16_t * old_stack_ptr ;


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
    f142:	8f b7       	in	r24, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
    f144:	f8 94       	cli
   
   flag = _atomic_start();
    f146:	80 93 b5 0c 	sts	0x0CB5, r24
   
    usartPrint(0xFC);
    f14a:	8c ef       	ldi	r24, 0xFC	; 252
    f14c:	0e 94 7c 78 	call	0xf0f8	; 0xf0f8 <usartPrint.1431>
    f150:	03 c0       	rjmp	.+6      	; 0xf158 <printString.4277+0x1c>
    while ((*p) != '\0')
    {
        usartPrint(*p);
    f152:	0e 94 7c 78 	call	0xf0f8	; 0xf0f8 <usartPrint.1431>
        p++;
    f156:	21 96       	adiw	r28, 0x01	; 1
{
   
   flag = _atomic_start();
   
    usartPrint(0xFC);
    while ((*p) != '\0')
    f158:	88 81       	ld	r24, Y
    f15a:	88 23       	and	r24, r24
    f15c:	d1 f7       	brne	.-12     	; 0xf152 <printString.4277+0x16>
    {
        usartPrint(*p);
        p++;
    }
    usartPrint(0xFC);
    f15e:	8c ef       	ldi	r24, 0xFC	; 252
    f160:	0e 94 7c 78 	call	0xf0f8	; 0xf0f8 <usartPrint.1431>
  
    _atomic_end(flag);
    f164:	80 91 b5 0c 	lds	r24, 0x0CB5



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
    f168:	8f bf       	out	0x3f, r24	; 63
	
}
    f16a:	df 91       	pop	r29
    f16c:	cf 91       	pop	r28
    f16e:	08 95       	ret

0000f170 <main>:




int main()
{
    f170:	2f 92       	push	r2
    f172:	3f 92       	push	r3
    f174:	4f 92       	push	r4
    f176:	5f 92       	push	r5
    f178:	6f 92       	push	r6
    f17a:	7f 92       	push	r7
    f17c:	8f 92       	push	r8
    f17e:	9f 92       	push	r9
    f180:	af 92       	push	r10
    f182:	bf 92       	push	r11
    f184:	cf 92       	push	r12
    f186:	df 92       	push	r13
    f188:	ef 92       	push	r14
    f18a:	ff 92       	push	r15
    f18c:	0f 93       	push	r16
    f18e:	1f 93       	push	r17
    f190:	cf 93       	push	r28
    f192:	df 93       	push	r29
   radioinfoaddr = getCurrentRadioInfoAddr();

  // Mutex_lock(msend);

   radioinfoaddr-> socket_port = port;
   radioinfoaddr->socket_addr = address;
    f194:	22 24       	eor	r2, r2
    f196:	2a 94       	dec	r2
    f198:	32 2c       	mov	r3, r2
thread* mythread;

void sendRadioMsg()
{
 void (*radiosendfp)() = (void (*)(void))SOCKET_RADIO_SEND_FUNCTION;
 radiosendfp();
    f19a:	64 e1       	ldi	r22, 0x14	; 20
    f19c:	46 2e       	mov	r4, r22
    f19e:	6a ee       	ldi	r22, 0xEA	; 234
    f1a0:	56 2e       	mov	r5, r22
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    f1a2:	54 e1       	ldi	r21, 0x14	; 20
    f1a4:	65 2e       	mov	r6, r21
    f1a6:	71 2c       	mov	r7, r1


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f1a8:	e1 2c       	mov	r14, r1
    f1aa:	4a ee       	ldi	r20, 0xEA	; 234
    f1ac:	f4 2e       	mov	r15, r20
void disableRadioState()
{

   void (*disableradiofp)(void) = (void (*)(void))RESTORE_RADIO_STATE;

   disableradiofp();
    f1ae:	38 eb       	ldi	r19, 0xB8	; 184
    f1b0:	83 2e       	mov	r8, r19
    f1b2:	3a ee       	ldi	r19, 0xEA	; 234
    f1b4:	93 2e       	mov	r9, r19
	   int ret;
	   void (*fp)(void) = (void (*)(void))GET_NODE_ID_FUNCTION;
	   asm volatile("push r20" "\n\t"
					"push r21" "\n\t"
					::);
	   fp();
    f1b6:	2c ec       	ldi	r18, 0xCC	; 204
    f1b8:	a2 2e       	mov	r10, r18
    f1ba:	2a ee       	ldi	r18, 0xEA	; 234
    f1bc:	b2 2e       	mov	r11, r18
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    f1be:	98 ee       	ldi	r25, 0xE8	; 232
    f1c0:	c9 2e       	mov	r12, r25
    f1c2:	93 e0       	ldi	r25, 0x03	; 3
    f1c4:	d9 2e       	mov	r13, r25
#include "liteoscommon.h"

void greenToggle()
{
 void (*greenfp)() = (void (*)(void))GREEN_LED_TOGGLE_FUNCTION; 
 greenfp();                              
    f1c6:	e4 e0       	ldi	r30, 0x04	; 4
    f1c8:	fa ee       	ldi	r31, 0xEA	; 234
    f1ca:	09 95       	icall
 */ 
      
	while (1)
	{
  greenToggle();
  radioSend_string("Hello, world!\n"); 
    f1cc:	e0 e8       	ldi	r30, 0x80	; 128
    f1ce:	fc e0       	ldi	r31, 0x0C	; 12
    f1d0:	20 e0       	ldi	r18, 0x00	; 0
    f1d2:	30 e0       	ldi	r19, 0x00	; 0
    f1d4:	02 c0       	rjmp	.+4      	; 0xf1da <main+0x6a>


int String_length(char* s) {
	int count=0;
	while(s[count] != '\0')
		count++;
    f1d6:	2f 5f       	subi	r18, 0xFF	; 255
    f1d8:	3f 4f       	sbci	r19, 0xFF	; 255
}


int String_length(char* s) {
	int count=0;
	while(s[count] != '\0')
    f1da:	81 91       	ld	r24, Z+
    f1dc:	88 23       	and	r24, r24
    f1de:	d9 f7       	brne	.-10     	; 0xf1d6 <main+0x66>

//This function sends out a string

void radioSend_string(uint8_t *msg)
{
    uint8_t temp = (uint8_t)String_length((char *)msg);
    f1e0:	12 2f       	mov	r17, r18
void radioSend_energywrapper(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg){
	 
	  
	    thread** current_thread;
	  
      current_thread = getCurrentThread();      
    f1e2:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1326>
    f1e6:	fc 01       	movw	r30, r24
      
     // if ((*current_thread)->ecbptr->remainenergy > (uint16_t)RADIO_ENERGY_CONSUMPTION_PER_BIT * (uint16_t)length)
      	//{
      		 (*current_thread)->ecbptr->remainenergy -= (uint16_t)RADIO_SEND * (uint16_t)length;           
    f1e8:	01 90       	ld	r0, Z+
    f1ea:	f0 81       	ld	r31, Z
    f1ec:	e0 2d       	mov	r30, r0
    f1ee:	05 a0       	ldd	r0, Z+37	; 0x25
    f1f0:	f6 a1       	ldd	r31, Z+38	; 0x26
    f1f2:	e0 2d       	mov	r30, r0
    f1f4:	87 ea       	ldi	r24, 0xA7	; 167
    f1f6:	18 9f       	mul	r17, r24
    f1f8:	90 01       	movw	r18, r0
    f1fa:	11 24       	eor	r1, r1
    f1fc:	40 e0       	ldi	r20, 0x00	; 0
    f1fe:	50 e0       	ldi	r21, 0x00	; 0
    f200:	87 81       	ldd	r24, Z+7	; 0x07
    f202:	90 85       	ldd	r25, Z+8	; 0x08
    f204:	a1 85       	ldd	r26, Z+9	; 0x09
    f206:	b2 85       	ldd	r27, Z+10	; 0x0a
    f208:	82 1b       	sub	r24, r18
    f20a:	93 0b       	sbc	r25, r19
    f20c:	a4 0b       	sbc	r26, r20
    f20e:	b5 0b       	sbc	r27, r21
    f210:	87 83       	std	Z+7, r24	; 0x07
    f212:	90 87       	std	Z+8, r25	; 0x08
    f214:	a1 87       	std	Z+9, r26	; 0x09
    f216:	b2 87       	std	Z+10, r27	; 0x0a

mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GET_RADIO_MUTEX_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f218:	4f 93       	push	r20
    f21a:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f21c:	e0 e1       	ldi	r30, 0x10	; 16
    f21e:	fa ee       	ldi	r31, 0xEA	; 234
    f220:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f222:	84 2f       	mov	r24, r20
    f224:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f226:	5f 91       	pop	r21
    f228:	4f 91       	pop	r20
   radioinfotype *radioinfoaddr;



   msend = getRadioMutexAddress();
   current_thread = getCurrentThread();
    f22a:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1326>

radioinfotype *getCurrentRadioInfoAddr()
{
   radioinfotype *currentradioinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_INFO_ADDR;
   asm volatile("push r20" "\n\t"
    f22e:	4f 93       	push	r20
    f230:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
    f232:	ec e5       	ldi	r30, 0x5C	; 92
    f234:	fa ee       	ldi	r31, 0xEA	; 234
    f236:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f238:	e4 2f       	mov	r30, r20
    f23a:	f5 2f       	mov	r31, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f23c:	5f 91       	pop	r21
    f23e:	4f 91       	pop	r20
   current_thread = getCurrentThread();
   radioinfoaddr = getCurrentRadioInfoAddr();

  // Mutex_lock(msend);

   radioinfoaddr-> socket_port = port;
    f240:	81 e0       	ldi	r24, 0x01	; 1
    f242:	90 e0       	ldi	r25, 0x00	; 0
    f244:	91 83       	std	Z+1, r25	; 0x01
    f246:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address;
    f248:	33 82       	std	Z+3, r3	; 0x03
    f24a:	22 82       	std	Z+2, r2	; 0x02
   radioinfoaddr->socket_msg_len  = length;
    f24c:	14 83       	std	Z+4, r17	; 0x04
   radioinfoaddr->socket_msg  = msg;
    f24e:	80 e8       	ldi	r24, 0x80	; 128
    f250:	9c e0       	ldi	r25, 0x0C	; 12
    f252:	96 83       	std	Z+6, r25	; 0x06
    f254:	85 83       	std	Z+5, r24	; 0x05
thread* mythread;

void sendRadioMsg()
{
 void (*radiosendfp)() = (void (*)(void))SOCKET_RADIO_SEND_FUNCTION;
 radiosendfp();
    f256:	f2 01       	movw	r30, r4
    f258:	09 95       	icall
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    f25a:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1326>
    f25e:	dc 01       	movw	r26, r24
     
   (*current_thread)->state = 4;
    f260:	ed 91       	ld	r30, X+
    f262:	fc 91       	ld	r31, X
    f264:	11 97       	sbiw	r26, 0x01	; 1
    f266:	94 e0       	ldi	r25, 0x04	; 4
    f268:	92 83       	std	Z+2, r25	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    f26a:	ed 91       	ld	r30, X+
    f26c:	fc 91       	ld	r31, X
    f26e:	74 8e       	std	Z+28, r7	; 0x1c
    f270:	63 8e       	std	Z+27, r6	; 0x1b


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f272:	f7 01       	movw	r30, r14
    f274:	09 95       	icall
void disableRadioState()
{

   void (*disableradiofp)(void) = (void (*)(void))RESTORE_RADIO_STATE;

   disableradiofp();
    f276:	f4 01       	movw	r30, r8
    f278:	09 95       	icall
uint16_t getnodeID()
	{

	   int ret;
	   void (*fp)(void) = (void (*)(void))GET_NODE_ID_FUNCTION;
	   asm volatile("push r20" "\n\t"
    f27a:	4f 93       	push	r20
    f27c:	5f 93       	push	r21
					"push r21" "\n\t"
					::);
	   fp();
    f27e:	f5 01       	movw	r30, r10
    f280:	09 95       	icall
	   asm volatile(" mov %A0, r20" "\n\t"
    f282:	84 2f       	mov	r24, r20
    f284:	95 2f       	mov	r25, r21
					  "mov %B0, r21" "\n\t"
					 :"=r" (ret)
					 :
					);
	   asm volatile("pop r21" "\n\t"
    f286:	5f 91       	pop	r21
    f288:	4f 91       	pop	r20
					 "pop r20" "\n\t"
					  ::);
	   return ret;
    f28a:	9c 01       	movw	r18, r24


void printfstring(char *p)
{     
      
	  itoa(getnodeID(), localbuffer, 10);
    f28c:	00 e0       	ldi	r16, 0x00	; 0
    f28e:	10 e0       	ldi	r17, 0x00	; 0
    int  pos = 0;
    char ch  = '!' ;
    int i; 
    do
    {
        rem    = value % radix ;
    f290:	c9 01       	movw	r24, r18
    f292:	6a e0       	ldi	r22, 0x0A	; 10
    f294:	70 e0       	ldi	r23, 0x00	; 0
    f296:	0e 94 93 79 	call	0xf326	; 0xf326 <__udivmodhi4>
    f29a:	48 2f       	mov	r20, r24
        value /= radix;
    f29c:	c9 01       	movw	r24, r18
    f29e:	6a e0       	ldi	r22, 0x0A	; 10
    f2a0:	70 e0       	ldi	r23, 0x00	; 0
    f2a2:	0e 94 93 79 	call	0xf326	; 0xf326 <__udivmodhi4>
    f2a6:	9b 01       	movw	r18, r22
                }
            }
        }
        if( '!' == ch )
        {
            str[pos++] = (char) ( rem + 0x30 );
    f2a8:	f8 01       	movw	r30, r16
    f2aa:	ed 55       	subi	r30, 0x5D	; 93
    f2ac:	f3 4f       	sbci	r31, 0xF3	; 243
    f2ae:	40 5d       	subi	r20, 0xD0	; 208
    f2b0:	40 83       	st	Z, r20
    f2b2:	0f 5f       	subi	r16, 0xFF	; 255
    f2b4:	1f 4f       	sbci	r17, 0xFF	; 255
        }
        else
        {
            str[pos++] = ch ;
        }
    }while( value != 0 );
    f2b6:	61 15       	cp	r22, r1
    f2b8:	71 05       	cpc	r23, r1
    f2ba:	51 f7       	brne	.-44     	; 0xf290 <main+0x120>
   // str[pos] = '\0' ;
    
    i=0; 
    
    while (i<pos/2)
    f2bc:	a8 01       	movw	r20, r16
    f2be:	55 95       	asr	r21
    f2c0:	47 95       	ror	r20
    f2c2:	c3 ea       	ldi	r28, 0xA3	; 163
    f2c4:	dc e0       	ldi	r29, 0x0C	; 12




int main()
{
    f2c6:	f8 01       	movw	r30, r16
    f2c8:	ec 0f       	add	r30, r28
    f2ca:	fd 1f       	adc	r31, r29
    f2cc:	df 01       	movw	r26, r30
    f2ce:	20 e0       	ldi	r18, 0x00	; 0
    f2d0:	30 e0       	ldi	r19, 0x00	; 0
    f2d2:	08 c0       	rjmp	.+16     	; 0xf2e4 <main+0x174>
    {
        *(str+pos) = *(str+i);       //uses the null character as the temporary storage.
    f2d4:	88 81       	ld	r24, Y
    f2d6:	80 83       	st	Z, r24
        *(str+i) = *(str + pos - i -1);
    f2d8:	8c 91       	ld	r24, X
    f2da:	89 93       	st	Y+, r24
        *(str+pos-i-1) = *(str+pos);
    f2dc:	80 81       	ld	r24, Z
    f2de:	8c 93       	st	X, r24
        i++;
    f2e0:	2f 5f       	subi	r18, 0xFF	; 255
    f2e2:	3f 4f       	sbci	r19, 0xFF	; 255
    f2e4:	11 97       	sbiw	r26, 0x01	; 1
    }while( value != 0 );
   // str[pos] = '\0' ;
    
    i=0; 
    
    while (i<pos/2)
    f2e6:	24 17       	cp	r18, r20
    f2e8:	35 07       	cpc	r19, r21
    f2ea:	a4 f3       	brlt	.-24     	; 0xf2d4 <main+0x164>
        *(str+i) = *(str + pos - i -1);
        *(str+pos-i-1) = *(str+pos);
        i++;
    }
   
    *(str+pos) = '\0';
    f2ec:	10 82       	st	Z, r1

void printfstring(char *p)
{     
      
	  itoa(getnodeID(), localbuffer, 10);
    printString(localbuffer);
    f2ee:	83 ea       	ldi	r24, 0xA3	; 163
    f2f0:	9c e0       	ldi	r25, 0x0C	; 12
    f2f2:	0e 94 9e 78 	call	0xf13c	; 0xf13c <printString.4277>
	  printString(": ");	
    f2f6:	8f e8       	ldi	r24, 0x8F	; 143
    f2f8:	9c e0       	ldi	r25, 0x0C	; 12
    f2fa:	0e 94 9e 78 	call	0xf13c	; 0xf13c <printString.4277>
	  printString(p); 
    f2fe:	82 e9       	ldi	r24, 0x92	; 146
    f300:	9c e0       	ldi	r25, 0x0C	; 12
    f302:	0e 94 9e 78 	call	0xf13c	; 0xf13c <printString.4277>
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    f306:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1326>
    f30a:	fc 01       	movw	r30, r24
     
   (*current_thread)->state = 4;
    f30c:	a0 81       	ld	r26, Z
    f30e:	b1 81       	ldd	r27, Z+1	; 0x01
    f310:	84 e0       	ldi	r24, 0x04	; 4
    f312:	12 96       	adiw	r26, 0x02	; 2
    f314:	8c 93       	st	X, r24
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    f316:	01 90       	ld	r0, Z+
    f318:	f0 81       	ld	r31, Z
    f31a:	e0 2d       	mov	r30, r0
    f31c:	d4 8e       	std	Z+28, r13	; 0x1c
    f31e:	c3 8e       	std	Z+27, r12	; 0x1b


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f320:	f7 01       	movw	r30, r14
    f322:	09 95       	icall
    f324:	50 cf       	rjmp	.-352    	; 0xf1c6 <main+0x56>

0000f326 <__udivmodhi4>:
    f326:	aa 1b       	sub	r26, r26
    f328:	bb 1b       	sub	r27, r27
    f32a:	51 e1       	ldi	r21, 0x11	; 17
    f32c:	07 c0       	rjmp	.+14     	; 0xf33c <__udivmodhi4_ep>

0000f32e <__udivmodhi4_loop>:
    f32e:	aa 1f       	adc	r26, r26
    f330:	bb 1f       	adc	r27, r27
    f332:	a6 17       	cp	r26, r22
    f334:	b7 07       	cpc	r27, r23
    f336:	10 f0       	brcs	.+4      	; 0xf33c <__udivmodhi4_ep>
    f338:	a6 1b       	sub	r26, r22
    f33a:	b7 0b       	sbc	r27, r23

0000f33c <__udivmodhi4_ep>:
    f33c:	88 1f       	adc	r24, r24
    f33e:	99 1f       	adc	r25, r25
    f340:	5a 95       	dec	r21
    f342:	a9 f7       	brne	.-22     	; 0xf32e <__udivmodhi4_loop>
    f344:	80 95       	com	r24
    f346:	90 95       	com	r25
    f348:	bc 01       	movw	r22, r24
    f34a:	cd 01       	movw	r24, r26
    f34c:	08 95       	ret

0000f34e <_exit>:
    f34e:	f8 94       	cli

0000f350 <__stop_program>:
    f350:	ff cf       	rjmp	.-2      	; 0xf350 <__stop_program>
