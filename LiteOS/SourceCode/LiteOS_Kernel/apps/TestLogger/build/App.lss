
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800a5a  0000fec6  0000055a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004c6  0000fa00  0000fa00  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b2  00800a66  00800a66  00000566  2**0
                  ALLOC
  3 .stab         00000408  00000000  00000000  00000568  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000084  00000000  00000000  00000970  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  000009f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000001b  00000000  00000000  00000a14  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001d20  00000000  00000000  00000a2f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000002b6  00000000  00000000  0000274f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000627  00000000  00000000  00002a05  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000d0  00000000  00000000  0000302c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000056f  00000000  00000000  000030fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000224  00000000  00000000  0000366b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  0000388f  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

0000fa00 <__vectors>:
    fa00:	0c 94 46 7d 	jmp	0xfa8c	; 0xfa8c <__ctors_end>
    fa04:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa08:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa0c:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa10:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa14:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa18:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa1c:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa20:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa24:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa28:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa2c:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa30:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa34:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa38:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa3c:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa40:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa44:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa48:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa4c:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa50:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa54:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa58:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa5c:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa60:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa64:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa68:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa6c:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa70:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa74:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa78:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa7c:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa80:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa84:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>
    fa88:	0c 94 63 7d 	jmp	0xfac6	; 0xfac6 <__bad_interrupt>

0000fa8c <__ctors_end>:
    fa8c:	11 24       	eor	r1, r1
    fa8e:	1f be       	out	0x3f, r1	; 63
    fa90:	ca ee       	ldi	r28, 0xEA	; 234
    fa92:	db e0       	ldi	r29, 0x0B	; 11
    fa94:	de bf       	out	0x3e, r29	; 62
    fa96:	cd bf       	out	0x3d, r28	; 61

0000fa98 <__do_copy_data>:
    fa98:	1a e0       	ldi	r17, 0x0A	; 10
    fa9a:	aa e5       	ldi	r26, 0x5A	; 90
    fa9c:	ba e0       	ldi	r27, 0x0A	; 10
    fa9e:	e6 ec       	ldi	r30, 0xC6	; 198
    faa0:	fe ef       	ldi	r31, 0xFE	; 254
    faa2:	00 e0       	ldi	r16, 0x00	; 0
    faa4:	0b bf       	out	0x3b, r16	; 59
    faa6:	02 c0       	rjmp	.+4      	; 0xfaac <__do_copy_data+0x14>
    faa8:	07 90       	elpm	r0, Z+
    faaa:	0d 92       	st	X+, r0
    faac:	a6 36       	cpi	r26, 0x66	; 102
    faae:	b1 07       	cpc	r27, r17
    fab0:	d9 f7       	brne	.-10     	; 0xfaa8 <__do_copy_data+0x10>

0000fab2 <__do_clear_bss>:
    fab2:	1b e0       	ldi	r17, 0x0B	; 11
    fab4:	a6 e6       	ldi	r26, 0x66	; 102
    fab6:	ba e0       	ldi	r27, 0x0A	; 10
    fab8:	01 c0       	rjmp	.+2      	; 0xfabc <.do_clear_bss_start>

0000faba <.do_clear_bss_loop>:
    faba:	1d 92       	st	X+, r1

0000fabc <.do_clear_bss_start>:
    fabc:	a8 31       	cpi	r26, 0x18	; 24
    fabe:	b1 07       	cpc	r27, r17
    fac0:	e1 f7       	brne	.-8      	; 0xfaba <.do_clear_bss_loop>
    fac2:	0c 94 70 7e 	jmp	0xfce0	; 0xfce0 <main>

0000fac6 <__bad_interrupt>:
    fac6:	0c 94 00 7d 	jmp	0xfa00	; 0xfa00 <__vectors>

0000faca <getCurrentThread.1405>:

//Warning: this returns the address of the currentthread pointer. 

thread **getCurrentThread()
{
    faca:	4f 93       	push	r20
    facc:	5f 93       	push	r21
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    face:	ec e0       	ldi	r30, 0x0C	; 12
    fad0:	fa ee       	ldi	r31, 0xEA	; 234
    fad2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    fad4:	84 2f       	mov	r24, r20
    fad6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
    fad8:	5f 91       	pop	r21
    fada:	4f 91       	pop	r20
    fadc:	08 95       	ret

0000fade <cleanUpTraceFunction.1624>:
}


void cleanUpTraceFunction()
{disableTracing();}
    fade:	e8 ee       	ldi	r30, 0xE8	; 232
    fae0:	fa ee       	ldi	r31, 0xEA	; 234
    fae2:	09 95       	icall
    fae4:	08 95       	ret

0000fae6 <tracingcontrol.1598>:
    fae6:	1f 93       	push	r17
    fae8:	cf 93       	push	r28
    faea:	df 93       	push	r29


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
    faec:	1f b7       	in	r17, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
    faee:	f8 94       	cli
    faf0:	a0 91 ef 0a 	lds	r26, 0x0AEF
    faf4:	b0 91 f0 0a 	lds	r27, 0x0AF0
    faf8:	8c 91       	ld	r24, X
    fafa:	82 30       	cpi	r24, 0x02	; 2
    fafc:	78 f1       	brcs	.+94     	; 0xfb5c <tracingcontrol.1598+0x76>
    fafe:	90 91 ee 0a 	lds	r25, 0x0AEE
    fb02:	e9 2f       	mov	r30, r25
    fb04:	ff 27       	eor	r31, r31
    fb06:	e2 59       	subi	r30, 0x92	; 146
    fb08:	f5 4f       	sbci	r31, 0xF5	; 245
    fb0a:	81 e0       	ldi	r24, 0x01	; 1
    fb0c:	80 83       	st	Z, r24
    fb0e:	29 2f       	mov	r18, r25
    fb10:	2f 5f       	subi	r18, 0xFF	; 255
    fb12:	e0 91 68 0a 	lds	r30, 0x0A68
    fb16:	f0 91 69 0a 	lds	r31, 0x0A69
    fb1a:	80 81       	ld	r24, Z
    fb1c:	e2 2f       	mov	r30, r18
    fb1e:	ff 27       	eor	r31, r31
    fb20:	e2 59       	subi	r30, 0x92	; 146
    fb22:	f5 4f       	sbci	r31, 0xF5	; 245
    fb24:	80 83       	st	Z, r24
    fb26:	2f 5f       	subi	r18, 0xFF	; 255
    fb28:	8c 91       	ld	r24, X
    fb2a:	e2 2f       	mov	r30, r18
    fb2c:	ff 27       	eor	r31, r31
    fb2e:	e2 59       	subi	r30, 0x92	; 146
    fb30:	f5 4f       	sbci	r31, 0xF5	; 245
    fb32:	80 83       	st	Z, r24
    fb34:	2f 5f       	subi	r18, 0xFF	; 255
    fb36:	99 5f       	subi	r25, 0xF9	; 249
    fb38:	90 93 ee 0a 	sts	0x0AEE, r25
    fb3c:	c2 2f       	mov	r28, r18
    fb3e:	dd 27       	eor	r29, r29
    fb40:	c2 59       	subi	r28, 0x92	; 146
    fb42:	d5 4f       	sbci	r29, 0xF5	; 245
    fb44:	e0 91 6c 0a 	lds	r30, 0x0A6C
    fb48:	f0 91 6d 0a 	lds	r31, 0x0A6D
    fb4c:	80 81       	ld	r24, Z
    fb4e:	91 81       	ldd	r25, Z+1	; 0x01
    fb50:	a2 81       	ldd	r26, Z+2	; 0x02
    fb52:	b3 81       	ldd	r27, Z+3	; 0x03
    fb54:	88 83       	st	Y, r24
    fb56:	99 83       	std	Y+1, r25	; 0x01
    fb58:	aa 83       	std	Y+2, r26	; 0x02
    fb5a:	bb 83       	std	Y+3, r27	; 0x03
    fb5c:	80 91 ee 0a 	lds	r24, 0x0AEE
    fb60:	88 37       	cpi	r24, 0x78	; 120
    fb62:	c0 f0       	brcs	.+48     	; 0xfb94 <tracingcontrol.1598+0xae>
    fb64:	ee e6       	ldi	r30, 0x6E	; 110
    fb66:	fa e0       	ldi	r31, 0x0A	; 10
    fb68:	a6 ef       	ldi	r26, 0xF6	; 246
    fb6a:	ba e0       	ldi	r27, 0x0A	; 10
    fb6c:	81 91       	ld	r24, Z+
    fb6e:	8d 93       	st	X+, r24
    fb70:	8a e0       	ldi	r24, 0x0A	; 10
    fb72:	ee 38       	cpi	r30, 0x8E	; 142
    fb74:	f8 07       	cpc	r31, r24
    fb76:	d1 f7       	brne	.-12     	; 0xfb6c <tracingcontrol.1598+0x86>
    fb78:	10 92 ee 0a 	sts	0x0AEE, r1
    fb7c:	e0 91 f3 0a 	lds	r30, 0x0AF3
    fb80:	f0 91 f4 0a 	lds	r31, 0x0AF4
    fb84:	82 e0       	ldi	r24, 0x02	; 2
    fb86:	82 83       	std	Z+2, r24	; 0x02
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}


void **getKernelStackPtr()
	{
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
}







uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
}

void syscall_postThreadTask_nologging()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK_NOLOG; 
 postthreadfp();                              
    fb88:	e0 ef       	ldi	r30, 0xF0	; 240
    fb8a:	fa ee       	ldi	r31, 0xEA	; 234
    fb8c:	09 95       	icall
    fb8e:	81 e0       	ldi	r24, 0x01	; 1
    fb90:	80 93 f5 0a 	sts	0x0AF5, r24
    fb94:	81 2f       	mov	r24, r17
    fb96:	99 27       	eor	r25, r25
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
    fb98:	8f bf       	out	0x3f, r24	; 63
    fb9a:	df 91       	pop	r29
    fb9c:	cf 91       	pop	r28
    fb9e:	1f 91       	pop	r17
    fba0:	08 95       	ret

0000fba2 <getCurrentThreadIndex.1406>:
    fba2:	4f 93       	push	r20
    fba4:	5f 93       	push	r21
    fba6:	ec e1       	ldi	r30, 0x1C	; 28
    fba8:	fa ee       	ldi	r31, 0xEA	; 234
    fbaa:	09 95       	icall
    fbac:	84 2f       	mov	r24, r20
    fbae:	95 2f       	mov	r25, r21
    fbb0:	5f 91       	pop	r21
    fbb2:	4f 91       	pop	r20
    fbb4:	99 27       	eor	r25, r25
    fbb6:	08 95       	ret

0000fbb8 <mfseek.1539>:



void mfseek(MYFILE *fp, int offset, int position)
{
    fbb8:	af 92       	push	r10
    fbba:	bf 92       	push	r11
    fbbc:	cf 92       	push	r12
    fbbe:	df 92       	push	r13
    fbc0:	ef 92       	push	r14
    fbc2:	ff 92       	push	r15
    fbc4:	0f 93       	push	r16
    fbc6:	1f 93       	push	r17
    fbc8:	7c 01       	movw	r14, r24
    fbca:	6b 01       	movw	r12, r22
    fbcc:	5a 01       	movw	r10, r20
   uint8_t currentthreadindex;
   thread** current_thread;

   current_thread = getCurrentThread();
    fbce:	0e 94 65 7d 	call	0xfaca	; 0xfaca <getCurrentThread.1405>
    fbd2:	8c 01       	movw	r16, r24
   currentthreadindex = getCurrentThreadIndex();
    fbd4:	0e 94 d1 7d 	call	0xfba2	; 0xfba2 <getCurrentThreadIndex.1406>

   (*current_thread)->filedata.fileseekstate.fileptr = (uint8_t*)fp;
    fbd8:	d8 01       	movw	r26, r16
    fbda:	ed 91       	ld	r30, X+
    fbdc:	fc 91       	ld	r31, X
    fbde:	11 97       	sbiw	r26, 0x01	; 1
    fbe0:	f0 a2       	std	Z+32, r15	; 0x20
    fbe2:	e7 8e       	std	Z+31, r14	; 0x1f
   (*current_thread)->filedata.fileseekstate.offset = offset;
    fbe4:	ed 91       	ld	r30, X+
    fbe6:	fc 91       	ld	r31, X
    fbe8:	11 97       	sbiw	r26, 0x01	; 1
    fbea:	d2 a2       	std	Z+34, r13	; 0x22
    fbec:	c1 a2       	std	Z+33, r12	; 0x21
   (*current_thread)->filedata.fileseekstate.position = position;
    fbee:	ed 91       	ld	r30, X+
    fbf0:	fc 91       	ld	r31, X
    fbf2:	b4 a2       	std	Z+36, r11	; 0x24
    fbf4:	a3 a2       	std	Z+35, r10	; 0x23
    fbf6:	ec e3       	ldi	r30, 0x3C	; 60
    fbf8:	fa ee       	ldi	r31, 0xEA	; 234
    fbfa:	09 95       	icall
    fbfc:	1f 91       	pop	r17
    fbfe:	0f 91       	pop	r16
    fc00:	ff 90       	pop	r15
    fc02:	ef 90       	pop	r14
    fc04:	df 90       	pop	r13
    fc06:	cf 90       	pop	r12
    fc08:	bf 90       	pop	r11
    fc0a:	af 90       	pop	r10
    fc0c:	08 95       	ret

0000fc0e <getFileMutexAddress.1446>:



mutex *getFileMutexAddress()
{
    fc0e:	4f 93       	push	r20
    fc10:	5f 93       	push	r21
   mutex *mfile;   
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_MUTEX_ADDRESS; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    fc12:	e8 e2       	ldi	r30, 0x28	; 40
    fc14:	fa ee       	ldi	r31, 0xEA	; 234
    fc16:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    fc18:	84 2f       	mov	r24, r20
    fc1a:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (mfile)
				 :
                );
    asm volatile("pop r21" "\n\t"
    fc1c:	5f 91       	pop	r21
    fc1e:	4f 91       	pop	r20
    fc20:	08 95       	ret

0000fc22 <mystrcpy.1455>:
}


void mystrcpy(char *dest, const char *src)
{
    fc22:	dc 01       	movw	r26, r24
    fc24:	fb 01       	movw	r30, r22
    fc26:	02 c0       	rjmp	.+4      	; 0xfc2c <mystrcpy.1455+0xa>
	int i;
	i = 0;
	while (src[i]!='\0')
	{ dest[i] = src[i];
    fc28:	8d 93       	st	X+, r24
    fc2a:	31 96       	adiw	r30, 0x01	; 1
    fc2c:	80 81       	ld	r24, Z
    fc2e:	88 23       	and	r24, r24
    fc30:	d9 f7       	brne	.-10     	; 0xfc28 <mystrcpy.1455+0x6>
	i++;
	}
	dest[i] = '\0';
    fc32:	1c 92       	st	X, r1
    fc34:	08 95       	ret

0000fc36 <yield.1404>:
    fc36:	e0 e0       	ldi	r30, 0x00	; 0
    fc38:	fa ee       	ldi	r31, 0xEA	; 234
    fc3a:	09 95       	icall
    fc3c:	08 95       	ret

0000fc3e <Barrier_block.1445>:
    fc3e:	ef 92       	push	r14
    fc40:	ff 92       	push	r15
    fc42:	0f 93       	push	r16
    fc44:	1f 93       	push	r17
    fc46:	f8 2e       	mov	r15, r24
    fc48:	e6 2e       	mov	r14, r22
    fc4a:	0e 94 65 7d 	call	0xfaca	; 0xfaca <getCurrentThread.1405>
    fc4e:	dc 01       	movw	r26, r24
    fc50:	0f b7       	in	r16, 0x3f	; 63
    fc52:	f8 94       	cli
    fc54:	11 27       	eor	r17, r17
    fc56:	ed 91       	ld	r30, X+
    fc58:	fc 91       	ld	r31, X
    fc5a:	11 97       	sbiw	r26, 0x01	; 1
    fc5c:	86 e0       	ldi	r24, 0x06	; 6
    fc5e:	82 83       	std	Z+2, r24	; 0x02
    fc60:	ed 91       	ld	r30, X+
    fc62:	fc 91       	ld	r31, X
    fc64:	11 97       	sbiw	r26, 0x01	; 1
    fc66:	f3 8e       	std	Z+27, r15	; 0x1b
    fc68:	ed 91       	ld	r30, X+
    fc6a:	fc 91       	ld	r31, X
    fc6c:	e4 8e       	std	Z+28, r14	; 0x1c
    fc6e:	0e 94 1b 7e 	call	0xfc36	; 0xfc36 <yield.1404>
    fc72:	0f bf       	out	0x3f, r16	; 63
    fc74:	1f 91       	pop	r17
    fc76:	0f 91       	pop	r16
    fc78:	ff 90       	pop	r15
    fc7a:	ef 90       	pop	r14
    fc7c:	08 95       	ret

0000fc7e <mfwrite.1535>:
    fc7e:	af 92       	push	r10
    fc80:	bf 92       	push	r11
    fc82:	cf 92       	push	r12
    fc84:	df 92       	push	r13
    fc86:	ef 92       	push	r14
    fc88:	ff 92       	push	r15
    fc8a:	0f 93       	push	r16
    fc8c:	1f 93       	push	r17
    fc8e:	7c 01       	movw	r14, r24
    fc90:	6b 01       	movw	r12, r22
    fc92:	5a 01       	movw	r10, r20
    fc94:	0e 94 65 7d 	call	0xfaca	; 0xfaca <getCurrentThread.1405>
    fc98:	8c 01       	movw	r16, r24
    fc9a:	0e 94 d1 7d 	call	0xfba2	; 0xfba2 <getCurrentThreadIndex.1406>
    fc9e:	0e 94 07 7e 	call	0xfc0e	; 0xfc0e <getFileMutexAddress.1446>
    fca2:	d8 01       	movw	r26, r16
    fca4:	ed 91       	ld	r30, X+
    fca6:	fc 91       	ld	r31, X
    fca8:	11 97       	sbiw	r26, 0x01	; 1
    fcaa:	f0 a2       	std	Z+32, r15	; 0x20
    fcac:	e7 8e       	std	Z+31, r14	; 0x1f
    fcae:	ed 91       	ld	r30, X+
    fcb0:	fc 91       	ld	r31, X
    fcb2:	11 97       	sbiw	r26, 0x01	; 1
    fcb4:	d2 a2       	std	Z+34, r13	; 0x22
    fcb6:	c1 a2       	std	Z+33, r12	; 0x21
    fcb8:	ed 91       	ld	r30, X+
    fcba:	fc 91       	ld	r31, X
    fcbc:	b4 a2       	std	Z+36, r11	; 0x24
    fcbe:	a3 a2       	std	Z+35, r10	; 0x23
    fcc0:	e8 e3       	ldi	r30, 0x38	; 56
    fcc2:	fa ee       	ldi	r31, 0xEA	; 234
    fcc4:	09 95       	icall
    fcc6:	64 e0       	ldi	r22, 0x04	; 4
    fcc8:	87 e0       	ldi	r24, 0x07	; 7
    fcca:	0e 94 1f 7e 	call	0xfc3e	; 0xfc3e <Barrier_block.1445>
    fcce:	1f 91       	pop	r17
    fcd0:	0f 91       	pop	r16
    fcd2:	ff 90       	pop	r15
    fcd4:	ef 90       	pop	r14
    fcd6:	df 90       	pop	r13
    fcd8:	cf 90       	pop	r12
    fcda:	bf 90       	pop	r11
    fcdc:	af 90       	pop	r10
    fcde:	08 95       	ret

0000fce0 <main>:

int main()
{   
    fce0:	8f 92       	push	r8
    fce2:	9f 92       	push	r9
    fce4:	af 92       	push	r10
    fce6:	bf 92       	push	r11
    fce8:	cf 92       	push	r12
    fcea:	df 92       	push	r13
    fcec:	ef 92       	push	r14
    fcee:	ff 92       	push	r15
    fcf0:	0f 93       	push	r16
    fcf2:	1f 93       	push	r17
    fcf4:	cf 93       	push	r28
    fcf6:	df 93       	push	r29
  __asm__ __volatile__("sei" ::); 
    fcf8:	78 94       	sei
 
 
 writetask = 0; 
    fcfa:	10 92 f5 0a 	sts	0x0AF5, r1
 currentindex = 0; 
    fcfe:	10 92 ee 0a 	sts	0x0AEE, r1
    fd02:	0e 94 65 7d 	call	0xfaca	; 0xfaca <getCurrentThread.1405>
    fd06:	4c 01       	movw	r8, r24
    fd08:	0e 94 d1 7d 	call	0xfba2	; 0xfba2 <getCurrentThreadIndex.1406>
    fd0c:	4f 93       	push	r20
    fd0e:	5f 93       	push	r21
    fd10:	e0 e2       	ldi	r30, 0x20	; 32
    fd12:	fa ee       	ldi	r31, 0xEA	; 234
    fd14:	09 95       	icall
    fd16:	c4 2e       	mov	r12, r20
    fd18:	d5 2e       	mov	r13, r21
    fd1a:	5f 91       	pop	r21
    fd1c:	4f 91       	pop	r20
    fd1e:	4f 93       	push	r20
    fd20:	5f 93       	push	r21
    fd22:	e4 e2       	ldi	r30, 0x24	; 36
    fd24:	fa ee       	ldi	r31, 0xEA	; 234
    fd26:	09 95       	icall
    fd28:	e4 2e       	mov	r14, r20
    fd2a:	f5 2e       	mov	r15, r21
    fd2c:	5f 91       	pop	r21
    fd2e:	4f 91       	pop	r20
    fd30:	0e 94 07 7e 	call	0xfc0e	; 0xfc0e <getFileMutexAddress.1446>
    fd34:	ec 01       	movw	r28, r24
    fd36:	0e 94 65 7d 	call	0xfaca	; 0xfaca <getCurrentThread.1405>
    fd3a:	8c 01       	movw	r16, r24
    fd3c:	0e 94 d1 7d 	call	0xfba2	; 0xfba2 <getCurrentThreadIndex.1406>
    fd40:	b8 2e       	mov	r11, r24
    fd42:	af b6       	in	r10, 0x3f	; 63
    fd44:	f8 94       	cli
    fd46:	88 81       	ld	r24, Y
    fd48:	88 23       	and	r24, r24
    fd4a:	91 f0       	breq	.+36     	; 0xfd70 <main+0x90>
    fd4c:	d8 01       	movw	r26, r16
    fd4e:	ed 91       	ld	r30, X+
    fd50:	fc 91       	ld	r31, X
    fd52:	11 97       	sbiw	r26, 0x01	; 1
    fd54:	83 e0       	ldi	r24, 0x03	; 3
    fd56:	82 83       	std	Z+2, r24	; 0x02
    fd58:	ed 91       	ld	r30, X+
    fd5a:	fc 91       	ld	r31, X
    fd5c:	d4 8f       	std	Z+28, r29	; 0x1c
    fd5e:	c3 8f       	std	Z+27, r28	; 0x1b
    fd60:	89 81       	ldd	r24, Y+1	; 0x01
    fd62:	8f 5f       	subi	r24, 0xFF	; 255
    fd64:	89 83       	std	Y+1, r24	; 0x01
    fd66:	0e 94 1b 7e 	call	0xfc36	; 0xfc36 <yield.1404>
    fd6a:	89 81       	ldd	r24, Y+1	; 0x01
    fd6c:	81 50       	subi	r24, 0x01	; 1
    fd6e:	89 83       	std	Y+1, r24	; 0x01
    fd70:	81 e0       	ldi	r24, 0x01	; 1
    fd72:	88 83       	st	Y, r24
    fd74:	ba 82       	std	Y+2, r11	; 0x02
    fd76:	8a 2d       	mov	r24, r10
    fd78:	99 27       	eor	r25, r25
    fd7a:	8f bf       	out	0x3f, r24	; 63
    fd7c:	6a e5       	ldi	r22, 0x5A	; 90
    fd7e:	7a e0       	ldi	r23, 0x0A	; 10
    fd80:	c6 01       	movw	r24, r12
    fd82:	0e 94 11 7e 	call	0xfc22	; 0xfc22 <mystrcpy.1455>
    fd86:	64 e6       	ldi	r22, 0x64	; 100
    fd88:	7a e0       	ldi	r23, 0x0A	; 10
    fd8a:	c7 01       	movw	r24, r14
    fd8c:	0e 94 11 7e 	call	0xfc22	; 0xfc22 <mystrcpy.1455>
    fd90:	ec e2       	ldi	r30, 0x2C	; 44
    fd92:	fa ee       	ldi	r31, 0xEA	; 234
    fd94:	09 95       	icall
    fd96:	61 e0       	ldi	r22, 0x01	; 1
    fd98:	87 e0       	ldi	r24, 0x07	; 7
    fd9a:	0e 94 1f 7e 	call	0xfc3e	; 0xfc3e <Barrier_block.1445>
    fd9e:	4f 93       	push	r20
    fda0:	5f 93       	push	r21
    fda2:	4c 2f       	mov	r20, r28
    fda4:	5d 2f       	mov	r21, r29
    fda6:	e8 e1       	ldi	r30, 0x18	; 24
    fda8:	fa ee       	ldi	r31, 0xEA	; 234
    fdaa:	09 95       	icall
    fdac:	5f 91       	pop	r21
    fdae:	4f 91       	pop	r20
    fdb0:	d4 01       	movw	r26, r8
    fdb2:	ed 91       	ld	r30, X+
    fdb4:	fc 91       	ld	r31, X
    fdb6:	87 8d       	ldd	r24, Z+31	; 0x1f
    fdb8:	90 a1       	ldd	r25, Z+32	; 0x20
 fileptr = mfopen("/logtrace", "w");
    fdba:	90 93 6b 0a 	sts	0x0A6B, r25
    fdbe:	80 93 6a 0a 	sts	0x0A6A, r24

void enableTracing()
{    
   void (*getaddrfp)(void) = (void (*)(void))ENABLE_TRACING_SYSCALL;
   getaddrfp();
    fdc2:	e4 ee       	ldi	r30, 0xE4	; 228
    fdc4:	fa ee       	ldi	r31, 0xEA	; 234
    fdc6:	09 95       	icall
    fdc8:	4f 93       	push	r20
    fdca:	5f 93       	push	r21
    fdcc:	e0 ee       	ldi	r30, 0xE0	; 224
    fdce:	fa ee       	ldi	r31, 0xEA	; 234
    fdd0:	09 95       	icall
    fdd2:	e4 2f       	mov	r30, r20
    fdd4:	f5 2f       	mov	r31, r21
    fdd6:	5f 91       	pop	r21
    fdd8:	4f 91       	pop	r20
 enableTracing();  

 blockaddr = (tracingblock *)getEventBlockAddress();
    fdda:	f0 93 67 0a 	sts	0x0A67, r31
    fdde:	e0 93 66 0a 	sts	0x0A66, r30
 eventid = &(blockaddr->internaleventid); 
    fde2:	f0 93 69 0a 	sts	0x0A69, r31
    fde6:	e0 93 68 0a 	sts	0x0A68, r30
 threadid = &(blockaddr->threadid); 
    fdea:	31 96       	adiw	r30, 0x01	; 1
    fdec:	f0 93 f0 0a 	sts	0x0AF0, r31
    fdf0:	e0 93 ef 0a 	sts	0x0AEF, r30
 localtimestamp = &(blockaddr->timestamp);
    fdf4:	31 96       	adiw	r30, 0x01	; 1
    fdf6:	f0 93 6d 0a 	sts	0x0A6D, r31
    fdfa:	e0 93 6c 0a 	sts	0x0A6C, r30
    fdfe:	32 97       	sbiw	r30, 0x02	; 2
 blockaddr->externaladdtracefp = tracingcontrol; 
    fe00:	83 e7       	ldi	r24, 0x73	; 115
    fe02:	9d e7       	ldi	r25, 0x7D	; 125
    fe04:	97 83       	std	Z+7, r25	; 0x07
    fe06:	86 83       	std	Z+6, r24	; 0x06

 thiscurrentthread = getCurrentThread(); 
    fe08:	0e 94 65 7d 	call	0xfaca	; 0xfaca <getCurrentThread.1405>
    fe0c:	fc 01       	movw	r30, r24
    fe0e:	90 93 f2 0a 	sts	0x0AF2, r25
    fe12:	80 93 f1 0a 	sts	0x0AF1, r24
 thisthread = *thiscurrentthread; 
    fe16:	80 81       	ld	r24, Z
    fe18:	91 81       	ldd	r25, Z+1	; 0x01
    fe1a:	90 93 f4 0a 	sts	0x0AF4, r25
    fe1e:	80 93 f3 0a 	sts	0x0AF3, r24
}


void debugValue(uint16_t v1, uint16_t v2, uint16_t v3)
{

  void (*fp)(void) = (void (*)(void))DEBUG_VALUE_SYSCALL; 
   asm volatile("push r8" "\n\t"
                "push r9" "\n\t"
                "push r10" "\n\t"
                "push r11" "\n\t"
				"push r12" "\n\t"
				"push r13" "\n\t"
                ::);
   
   asm volatile(" mov r8, %A0" "\n\t"
	             "mov r9, %B0" "\n\t"
				 :
				 :"r" (v1)
                );


   asm volatile(" mov r10, %A0" "\n\t"
	             "mov r11, %B0" "\n\t"
				 :
				 :"r" (v2)
                );
 
   asm volatile(" mov r12, %A0" "\n\t"
	             "mov r13, %B0" "\n\t"
				 :
				 :"r" (v3)
                );


  fp(); 

  asm volatile("pop r13" "\n\t"
	           "pop r12" "\n\t"
	              ::);

  asm volatile("pop r11" "\n\t"
	           "pop r10" "\n\t"
	              ::);

  asm volatile("pop r9" "\n\t"
	           "pop r8" "\n\t"
	              ::);
  return; 


}


void postTask(void (*tp) (void), uint16_t priority)
{
   void (*fp)(void) = (void (*)(void))POST_TASK_SYSCALL; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
				"push r22" "\n\t"
				"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
	             "mov r21, %B0" "\n\t"
				 :
				 :"r" (tp)
                );


   asm volatile(" mov r22, %A0" "\n\t"
	             "mov r23, %B0" "\n\t"
				 :
				 :"r" (priority)
                );

  fp(); 

  asm volatile("pop r23" "\n\t"
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
	           "pop r20" "\n\t"
	              ::);
  return; 


}




void postTaskWithoutLogging(void (*tp) (void), uint16_t priority)
{
   void (*fp)(void) = (void (*)(void))POST_TASK_SYSCALL; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
				"push r22" "\n\t"
				"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
	             "mov r21, %B0" "\n\t"
				 :
				 :"r" (tp)
                );


   asm volatile(" mov r22, %A0" "\n\t"
	             "mov r23, %B0" "\n\t"
				 :
				 :"r" (priority)
                );

  fp(); 

  asm volatile("pop r23" "\n\t"
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
	           "pop r20" "\n\t"
	              ::);
  return; 


}


thread_create_block_type *getCurrentThreadControlBlockAddr()
{
   thread_create_block_type *blockinfo; 
   void (*getaddrfp)(void) = (void (*)(void))GET_THREAD_CONTROL_BLOCK; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	              " mov %B0, r21" "\n\t"
				 :"=r" (blockinfo)
				 :
               );
    asm volatile("pop r21" "\n\t"
	               "pop r20" "\n\t"
	               ::);
   return blockinfo; 
}


void *getCurrentThreadControlMutexAddr()
{
   void *blockinfo; 
   void (*getaddrfp)(void) = (void (*)(void))GET_THREAD_CONTROL_MUTEX; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	              " mov %B0, r21" "\n\t"
				 :"=r" (blockinfo)
				 :
               );
    asm volatile("pop r21" "\n\t"
	               "pop r20" "\n\t"
	               ::);
   return blockinfo; 
}





void createThread(void (*fp)(), uint8_t* ram_start, uint8_t *stack_ptr, uint8_t priority, const char *threadname)
{
 
 
   mutex* createthreadmutex; 
   thread_create_block_type *threadblock;
   void (*getaddrfp)(void) = (void (*)(void))CREATE_THERAD_SYSCALL;

  
   threadblock = getCurrentThreadControlBlockAddr(); 
   createthreadmutex = (mutex *)getCurrentThreadControlMutexAddr(); 
   
   Mutex_lock(createthreadmutex);
     
   threadblock-> fp = fp; 
   threadblock->ram_start = ram_start; 
   threadblock->stack_ptr = stack_ptr; 
   threadblock->priority = priority;
   threadblock->threadname = threadname; 

   getaddrfp(); 
   
   sleepThread(20); 
   
  
   Mutex_unlock(createthreadmutex); 

   return; 
}




void setThreadTerminateHandler(void (*tp) (void))
{
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_THREAD_TERMINATE_TASK; 
   asm volatile("push r20" "\n\t"
    fe22:	4f 93       	push	r20
    fe24:	5f 93       	push	r21
                "push r21" "\n\t"
				        ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
    fe26:	8f e6       	ldi	r24, 0x6F	; 111
    fe28:	9d e7       	ldi	r25, 0x7D	; 125
    fe2a:	48 2f       	mov	r20, r24
    fe2c:	59 2f       	mov	r21, r25
	             "mov r21, %B0" "\n\t"
				 :
				 :"r" (tp)
                );


  fp(); 
    fe2e:	e0 e0       	ldi	r30, 0x00	; 0
    fe30:	fb ee       	ldi	r31, 0xEB	; 235
    fe32:	09 95       	icall

  asm volatile("pop r21" "\n\t"
    fe34:	5f 91       	pop	r21
    fe36:	4f 91       	pop	r20
    fe38:	0e 94 65 7d 	call	0xfaca	; 0xfaca <getCurrentThread.1405>
    fe3c:	fc 01       	movw	r30, r24
    fe3e:	01 90       	ld	r0, Z+
    fe40:	f0 81       	ld	r31, Z
    fe42:	e0 2d       	mov	r30, r0
    fe44:	85 e0       	ldi	r24, 0x05	; 5
    fe46:	82 83       	std	Z+2, r24	; 0x02
    fe48:	0e 94 1b 7e 	call	0xfc36	; 0xfc36 <yield.1404>

 
  setThreadTerminateHandler(cleanUpTraceFunction); 

 while (1)
 {
 	hibernateThread();
 	if (writetask == 1)
    fe4c:	80 91 f5 0a 	lds	r24, 0x0AF5
    fe50:	81 30       	cpi	r24, 0x01	; 1
    fe52:	91 f7       	brne	.-28     	; 0xfe38 <main+0x158>
    fe54:	0f b7       	in	r16, 0x3f	; 63
    fe56:	f8 94       	cli
    fe58:	11 27       	eor	r17, r17
    fe5a:	40 e2       	ldi	r20, 0x20	; 32
    fe5c:	50 e0       	ldi	r21, 0x00	; 0
    fe5e:	66 ef       	ldi	r22, 0xF6	; 246
    fe60:	7a e0       	ldi	r23, 0x0A	; 10
    fe62:	80 91 6a 0a 	lds	r24, 0x0A6A
    fe66:	90 91 6b 0a 	lds	r25, 0x0A6B
    fe6a:	0e 94 3f 7e 	call	0xfc7e	; 0xfc7e <mfwrite.1535>
    fe6e:	41 e0       	ldi	r20, 0x01	; 1
    fe70:	50 e0       	ldi	r21, 0x00	; 0
    fe72:	60 e2       	ldi	r22, 0x20	; 32
    fe74:	70 e0       	ldi	r23, 0x00	; 0
    fe76:	80 91 6a 0a 	lds	r24, 0x0A6A
    fe7a:	90 91 6b 0a 	lds	r25, 0x0A6B
    fe7e:	0e 94 dc 7d 	call	0xfbb8	; 0xfbb8 <mfseek.1539>
    fe82:	40 e6       	ldi	r20, 0x60	; 96
    fe84:	50 e0       	ldi	r21, 0x00	; 0
    fe86:	6e e8       	ldi	r22, 0x8E	; 142
    fe88:	7a e0       	ldi	r23, 0x0A	; 10
    fe8a:	80 91 6a 0a 	lds	r24, 0x0A6A
    fe8e:	90 91 6b 0a 	lds	r25, 0x0A6B
    fe92:	0e 94 3f 7e 	call	0xfc7e	; 0xfc7e <mfwrite.1535>
    fe96:	41 e0       	ldi	r20, 0x01	; 1
    fe98:	50 e0       	ldi	r21, 0x00	; 0
    fe9a:	60 e6       	ldi	r22, 0x60	; 96
    fe9c:	70 e0       	ldi	r23, 0x00	; 0
    fe9e:	80 91 6a 0a 	lds	r24, 0x0A6A
    fea2:	90 91 6b 0a 	lds	r25, 0x0A6B
    fea6:	0e 94 dc 7d 	call	0xfbb8	; 0xfbb8 <mfseek.1539>
    feaa:	0f bf       	out	0x3f, r16	; 63
   { writeFileTask();
     writetask = 0; 
    feac:	10 92 f5 0a 	sts	0x0AF5, r1
    feb0:	c3 cf       	rjmp	.-122    	; 0xfe38 <main+0x158>

0000feb2 <wakeupMe.3624>:

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
    feb2:	e0 91 16 0b 	lds	r30, 0x0B16
    feb6:	f0 91 17 0b 	lds	r31, 0x0B17
    feba:	82 e0       	ldi	r24, 0x02	; 2
    febc:	82 83       	std	Z+2, r24	; 0x02
    febe:	e8 e6       	ldi	r30, 0x68	; 104
    fec0:	fa ee       	ldi	r31, 0xEA	; 234
    fec2:	09 95       	icall
    fec4:	08 95       	ret
