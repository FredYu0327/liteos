
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000358  00014600  00014600  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000044  00800a5a  00800a5a  000003cc  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  000003cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  000007d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  00000858  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  00000878  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000014b5  00000000  00000000  00000893  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000299  00000000  00000000  00001d48  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000465  00000000  00000000  00001fe1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000b0  00000000  00000000  00002446  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000437  00000000  00000000  000024f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000001ae  00000000  00000000  0000292d  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00014600 <__vectors>:
   14600:	0c 94 46 a3 	jmp	0x1468c
   14604:	0c 94 63 a3 	jmp	0x146c6
   14608:	0c 94 63 a3 	jmp	0x146c6
   1460c:	0c 94 63 a3 	jmp	0x146c6
   14610:	0c 94 63 a3 	jmp	0x146c6
   14614:	0c 94 63 a3 	jmp	0x146c6
   14618:	0c 94 63 a3 	jmp	0x146c6
   1461c:	0c 94 63 a3 	jmp	0x146c6
   14620:	0c 94 63 a3 	jmp	0x146c6
   14624:	0c 94 63 a3 	jmp	0x146c6
   14628:	0c 94 63 a3 	jmp	0x146c6
   1462c:	0c 94 63 a3 	jmp	0x146c6
   14630:	0c 94 63 a3 	jmp	0x146c6
   14634:	0c 94 63 a3 	jmp	0x146c6
   14638:	0c 94 63 a3 	jmp	0x146c6
   1463c:	0c 94 63 a3 	jmp	0x146c6
   14640:	0c 94 63 a3 	jmp	0x146c6
   14644:	0c 94 63 a3 	jmp	0x146c6
   14648:	0c 94 63 a3 	jmp	0x146c6
   1464c:	0c 94 63 a3 	jmp	0x146c6
   14650:	0c 94 63 a3 	jmp	0x146c6
   14654:	0c 94 63 a3 	jmp	0x146c6
   14658:	0c 94 63 a3 	jmp	0x146c6
   1465c:	0c 94 63 a3 	jmp	0x146c6
   14660:	0c 94 63 a3 	jmp	0x146c6
   14664:	0c 94 63 a3 	jmp	0x146c6
   14668:	0c 94 63 a3 	jmp	0x146c6
   1466c:	0c 94 63 a3 	jmp	0x146c6
   14670:	0c 94 63 a3 	jmp	0x146c6
   14674:	0c 94 63 a3 	jmp	0x146c6
   14678:	0c 94 63 a3 	jmp	0x146c6
   1467c:	0c 94 63 a3 	jmp	0x146c6
   14680:	0c 94 63 a3 	jmp	0x146c6
   14684:	0c 94 63 a3 	jmp	0x146c6
   14688:	0c 94 63 a3 	jmp	0x146c6

0001468c <__ctors_end>:
   1468c:	11 24       	eor	r1, r1
   1468e:	1f be       	out	0x3f, r1	; 63
   14690:	ca e5       	ldi	r28, 0x5A	; 90
   14692:	db e0       	ldi	r29, 0x0B	; 11
   14694:	de bf       	out	0x3e, r29	; 62
   14696:	cd bf       	out	0x3d, r28	; 61

00014698 <__do_copy_data>:
   14698:	1a e0       	ldi	r17, 0x0A	; 10
   1469a:	aa e5       	ldi	r26, 0x5A	; 90
   1469c:	ba e0       	ldi	r27, 0x0A	; 10
   1469e:	e8 e5       	ldi	r30, 0x58	; 88
   146a0:	f9 e4       	ldi	r31, 0x49	; 73
   146a2:	01 e0       	ldi	r16, 0x01	; 1
   146a4:	0b bf       	out	0x3b, r16	; 59
   146a6:	02 c0       	rjmp	.+4      	; 0x146ac
   146a8:	07 90       	elpm	r0, Z+
   146aa:	0d 92       	st	X+, r0
   146ac:	aa 35       	cpi	r26, 0x5A	; 90
   146ae:	b1 07       	cpc	r27, r17
   146b0:	d9 f7       	brne	.-10     	; 0x146a8

000146b2 <__do_clear_bss>:
   146b2:	1a e0       	ldi	r17, 0x0A	; 10
   146b4:	aa e5       	ldi	r26, 0x5A	; 90
   146b6:	ba e0       	ldi	r27, 0x0A	; 10
   146b8:	01 c0       	rjmp	.+2      	; 0x146bc

000146ba <.do_clear_bss_loop>:
   146ba:	1d 92       	st	X+, r1

000146bc <.do_clear_bss_start>:
   146bc:	ae 39       	cpi	r26, 0x9E	; 158
   146be:	b1 07       	cpc	r27, r17
   146c0:	e1 f7       	brne	.-8      	; 0x146ba
   146c2:	0c 94 4c a4 	jmp	0x14898

000146c6 <__bad_interrupt>:
   146c6:	0c 94 00 a3 	jmp	0x14600

000146ca <getCurrentThread.1403>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   146ca:	4f 93       	push	r20
   146cc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   146ce:	ec e0       	ldi	r30, 0x0C	; 12
   146d0:	fa ee       	ldi	r31, 0xEA	; 234
   146d2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   146d4:	84 2f       	mov	r24, r20
   146d6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   146d8:	5f 91       	pop	r21
   146da:	4f 91       	pop	r20
   146dc:	08 95       	ret

000146de <getCurrentEEPROMInfo.1977>:
   genericByteStorageTaskNode *currenteeprominfoaddr;

   void (*getaddrfp)(void) = (void (*)(void))GET_EEPROM_STRUCTURE_HANDLE;

   asm volatile("push r20" "\n\t"
   146de:	4f 93       	push	r20
   146e0:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   146e2:	e4 ea       	ldi	r30, 0xA4	; 164
   146e4:	fa ee       	ldi	r31, 0xEA	; 234
   146e6:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   146e8:	84 2f       	mov	r24, r20
   146ea:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (currenteeprominfoaddr)
				 :
                );
    asm volatile("pop r21" "\n\t"
   146ec:	5f 91       	pop	r21
   146ee:	4f 91       	pop	r20
   146f0:	08 95       	ret

000146f2 <readFromEEPROM.1506>:
	             "pop r20" "\n\t"
	              ::);
   return currenteeprominfoaddr;
}




//Turn off the interrupt, access the location, and use system call to implement poll based imlementation provided by avr libc

void readFromEEPROM(uint16_t addr, uint16_t nBytes, uint8_t *buffer)
{
   146f2:	af 92       	push	r10
   146f4:	bf 92       	push	r11
   146f6:	cf 92       	push	r12
   146f8:	df 92       	push	r13
   146fa:	ef 92       	push	r14
   146fc:	ff 92       	push	r15
   146fe:	0f 93       	push	r16
   14700:	1f 93       	push	r17
   14702:	7c 01       	movw	r14, r24
   14704:	6b 01       	movw	r12, r22
   14706:	5a 01       	movw	r10, r20


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
   14708:	0f b7       	in	r16, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
   1470a:	f8 94       	cli


	_atomic_t currentatomic;

	currentatomic = _atomic_start();
   1470c:	11 27       	eor	r17, r17


    genericByteStorageTaskNode *eeprominfoaddr;
    eeprominfoaddr = getCurrentEEPROMInfo();
   1470e:	0e 94 6f a3 	call	0x146de
   14712:	fc 01       	movw	r30, r24

	void (*getaddrfp)(void) = (void (*)(void))READ_EEPROM_TASK;

    eeprominfoaddr-> addr = addr;
   14714:	f1 82       	std	Z+1, r15	; 0x01
   14716:	e0 82       	st	Z, r14
   	eeprominfoaddr-> nBytes = nBytes;
   14718:	d3 82       	std	Z+3, r13	; 0x03
   1471a:	c2 82       	std	Z+2, r12	; 0x02
   	eeprominfoaddr-> buffer = buffer;
   1471c:	b5 82       	std	Z+5, r11	; 0x05
   1471e:	a4 82       	std	Z+4, r10	; 0x04


    getaddrfp();
   14720:	e8 ea       	ldi	r30, 0xA8	; 168
   14722:	fa ee       	ldi	r31, 0xEA	; 234
   14724:	09 95       	icall
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
   14726:	0f bf       	out	0x3f, r16	; 63
   14728:	1f 91       	pop	r17
   1472a:	0f 91       	pop	r16
   1472c:	ff 90       	pop	r15
   1472e:	ef 90       	pop	r14
   14730:	df 90       	pop	r13
   14732:	cf 90       	pop	r12
   14734:	bf 90       	pop	r11
   14736:	af 90       	pop	r10
   14738:	08 95       	ret

0001473a <writeToEEPROM.1510>:

	_atomic_end(currentatomic);
}




//Turn off the interrupt, access the location, and use system call to implement poll based implementation provided by avr libc

void writeToEEPROM(uint16_t addr, uint16_t nBytes, uint8_t *buffer)
{
   1473a:	af 92       	push	r10
   1473c:	bf 92       	push	r11
   1473e:	cf 92       	push	r12
   14740:	df 92       	push	r13
   14742:	ef 92       	push	r14
   14744:	ff 92       	push	r15
   14746:	0f 93       	push	r16
   14748:	1f 93       	push	r17
   1474a:	7c 01       	movw	r14, r24
   1474c:	6b 01       	movw	r12, r22
   1474e:	5a 01       	movw	r10, r20
   14750:	0f b7       	in	r16, 0x3f	; 63
   14752:	f8 94       	cli

	_atomic_t currentatomic;

	currentatomic = _atomic_start();
   14754:	11 27       	eor	r17, r17

    genericByteStorageTaskNode *eeprominfoaddr;
    eeprominfoaddr = getCurrentEEPROMInfo();
   14756:	0e 94 6f a3 	call	0x146de
   1475a:	fc 01       	movw	r30, r24

	void (*getaddrfp)(void) = (void (*)(void))WRITE_EEPROM_TASK;

    eeprominfoaddr-> addr = addr;
   1475c:	f1 82       	std	Z+1, r15	; 0x01
   1475e:	e0 82       	st	Z, r14
	  eeprominfoaddr-> nBytes = nBytes;
   14760:	d3 82       	std	Z+3, r13	; 0x03
   14762:	c2 82       	std	Z+2, r12	; 0x02
	  eeprominfoaddr-> buffer = buffer;
   14764:	b5 82       	std	Z+5, r11	; 0x05
   14766:	a4 82       	std	Z+4, r10	; 0x04


    getaddrfp();
   14768:	ec ea       	ldi	r30, 0xAC	; 172
   1476a:	fa ee       	ldi	r31, 0xEA	; 234
   1476c:	09 95       	icall
   1476e:	0f bf       	out	0x3f, r16	; 63
   14770:	1f 91       	pop	r17
   14772:	0f 91       	pop	r16
   14774:	ff 90       	pop	r15
   14776:	ef 90       	pop	r14
   14778:	df 90       	pop	r13
   1477a:	cf 90       	pop	r12
   1477c:	bf 90       	pop	r11
   1477e:	af 90       	pop	r10
   14780:	08 95       	ret

00014782 <yield.1402>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
   14782:	e0 e0       	ldi	r30, 0x00	; 0
   14784:	fa ee       	ldi	r31, 0xEA	; 234
   14786:	09 95       	icall
   14788:	08 95       	ret

0001478a <syscall_postThreadTask.1409>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
   1478a:	e8 e6       	ldi	r30, 0x68	; 104
   1478c:	fa ee       	ldi	r31, 0xEA	; 234
   1478e:	09 95       	icall
   14790:	08 95       	ret

00014792 <wakeupMe.3145>:
//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
   14792:	e0 91 9a 0a 	lds	r30, 0x0A9A
   14796:	f0 91 9b 0a 	lds	r31, 0x0A9B
   1479a:	82 e0       	ldi	r24, 0x02	; 2
   1479c:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   1479e:	0e 94 c5 a3 	call	0x1478a
   147a2:	08 95       	ret

000147a4 <serialSend.1478>:



void serialSend(uint8_t length, uint8_t *msg)
{
   147a4:	8f 92       	push	r8
   147a6:	9f 92       	push	r9
   147a8:	af 92       	push	r10
   147aa:	bf 92       	push	r11
   147ac:	cf 92       	push	r12
   147ae:	df 92       	push	r13
   147b0:	ef 92       	push	r14
   147b2:	ff 92       	push	r15
   147b4:	0f 93       	push	r16
   147b6:	1f 93       	push	r17
   147b8:	cf 93       	push	r28
   147ba:	df 93       	push	r29
   147bc:	88 2e       	mov	r8, r24
   147be:	5b 01       	movw	r10, r22
   mutex *msend;   

   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_MUTEX_ADDRESS_FUNCTION;
   
   asm volatile("push r20" "\n\t"
   147c0:	4f 93       	push	r20
   147c2:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   147c4:	e0 e9       	ldi	r30, 0x90	; 144
   147c6:	fa ee       	ldi	r31, 0xEA	; 234
   147c8:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   147ca:	c4 2f       	mov	r28, r20
   147cc:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
   asm volatile("pop r21" "\n\t"
   147ce:	5f 91       	pop	r21
   147d0:	4f 91       	pop	r20


   mutex* mserialsend;
   thread** current_thread;
   serialinfotype *serialinfoaddr;



   mserialsend = getSerialMutexAddress();
   current_thread = getCurrentThread();
   147d2:	0e 94 65 a3 	call	0x146ca
   147d6:	4f 93       	push	r20
   147d8:	5f 93       	push	r21
   147da:	e4 e9       	ldi	r30, 0x94	; 148
   147dc:	fa ee       	ldi	r31, 0xEA	; 234
   147de:	09 95       	icall
   147e0:	c4 2e       	mov	r12, r20
   147e2:	d5 2e       	mov	r13, r21
   147e4:	5f 91       	pop	r21
   147e6:	4f 91       	pop	r20
   147e8:	0e 94 65 a3 	call	0x146ca
   147ec:	8c 01       	movw	r16, r24
   147ee:	4f 93       	push	r20
   147f0:	5f 93       	push	r21
   147f2:	ec e1       	ldi	r30, 0x1C	; 28
   147f4:	fa ee       	ldi	r31, 0xEA	; 234
   147f6:	09 95       	icall
   147f8:	e4 2e       	mov	r14, r20
   147fa:	f5 2e       	mov	r15, r21
   147fc:	5f 91       	pop	r21
   147fe:	4f 91       	pop	r20
   14800:	9f b6       	in	r9, 0x3f	; 63
   14802:	f8 94       	cli
   14804:	88 81       	ld	r24, Y
   14806:	88 23       	and	r24, r24
   14808:	91 f0       	breq	.+36     	; 0x1482e
   1480a:	d8 01       	movw	r26, r16
   1480c:	ed 91       	ld	r30, X+
   1480e:	fc 91       	ld	r31, X
   14810:	11 97       	sbiw	r26, 0x01	; 1
   14812:	83 e0       	ldi	r24, 0x03	; 3
   14814:	82 83       	std	Z+2, r24	; 0x02
   14816:	ed 91       	ld	r30, X+
   14818:	fc 91       	ld	r31, X
   1481a:	d4 8f       	std	Z+28, r29	; 0x1c
   1481c:	c3 8f       	std	Z+27, r28	; 0x1b
   1481e:	89 81       	ldd	r24, Y+1	; 0x01
   14820:	8f 5f       	subi	r24, 0xFF	; 255
   14822:	89 83       	std	Y+1, r24	; 0x01
   14824:	0e 94 c1 a3 	call	0x14782
   14828:	89 81       	ldd	r24, Y+1	; 0x01
   1482a:	81 50       	subi	r24, 0x01	; 1
   1482c:	89 83       	std	Y+1, r24	; 0x01
   1482e:	81 e0       	ldi	r24, 0x01	; 1
   14830:	88 83       	st	Y, r24
   14832:	8e 2d       	mov	r24, r14
   14834:	99 27       	eor	r25, r25
   14836:	8a 83       	std	Y+2, r24	; 0x02
   14838:	89 2d       	mov	r24, r9
   1483a:	99 27       	eor	r25, r25
   1483c:	8f bf       	out	0x3f, r24	; 63
   serialinfoaddr = getCurrentSerialInfo();

   Mutex_lock(mserialsend);

   serialinfoaddr->socket_msg_len = length;
   1483e:	f6 01       	movw	r30, r12
   14840:	80 82       	st	Z, r8
   serialinfoaddr->socket_msg = msg;
   14842:	b2 82       	std	Z+2, r11	; 0x02
   14844:	a1 82       	std	Z+1, r10	; 0x01
   14846:	e8 e9       	ldi	r30, 0x98	; 152
   14848:	fa ee       	ldi	r31, 0xEA	; 234
   1484a:	09 95       	icall
   1484c:	0e 94 65 a3 	call	0x146ca
   14850:	dc 01       	movw	r26, r24
   14852:	ed 91       	ld	r30, X+
   14854:	fc 91       	ld	r31, X
   14856:	11 97       	sbiw	r26, 0x01	; 1
   14858:	84 e0       	ldi	r24, 0x04	; 4
   1485a:	82 83       	std	Z+2, r24	; 0x02
   1485c:	ed 91       	ld	r30, X+
   1485e:	fc 91       	ld	r31, X
   14860:	8e e1       	ldi	r24, 0x1E	; 30
   14862:	90 e0       	ldi	r25, 0x00	; 0
   14864:	94 8f       	std	Z+28, r25	; 0x1c
   14866:	83 8f       	std	Z+27, r24	; 0x1b
   14868:	0e 94 c1 a3 	call	0x14782
   1486c:	4f 93       	push	r20
   1486e:	5f 93       	push	r21
   14870:	4c 2f       	mov	r20, r28
   14872:	5d 2f       	mov	r21, r29
   14874:	e8 e1       	ldi	r30, 0x18	; 24
   14876:	fa ee       	ldi	r31, 0xEA	; 234
   14878:	09 95       	icall
   1487a:	5f 91       	pop	r21
   1487c:	4f 91       	pop	r20
   1487e:	df 91       	pop	r29
   14880:	cf 91       	pop	r28
   14882:	1f 91       	pop	r17
   14884:	0f 91       	pop	r16
   14886:	ff 90       	pop	r15
   14888:	ef 90       	pop	r14
   1488a:	df 90       	pop	r13
   1488c:	cf 90       	pop	r12
   1488e:	bf 90       	pop	r11
   14890:	af 90       	pop	r10
   14892:	9f 90       	pop	r9
   14894:	8f 90       	pop	r8
   14896:	08 95       	ret

00014898 <main>:

int main()
{
    int i;
    __asm__ __volatile__("sei" ::);
   14898:	78 94       	sei
   1489a:	ea e5       	ldi	r30, 0x5A	; 90
   1489c:	fa e0       	ldi	r31, 0x0A	; 10
   1489e:	80 e0       	ldi	r24, 0x00	; 0
    for (i=0;i<32;i++)
     datainternal[i] = i * 3; 
   148a0:	81 93       	st	Z+, r24
   148a2:	8d 5f       	subi	r24, 0xFD	; 253
   148a4:	80 36       	cpi	r24, 0x60	; 96
   148a6:	e1 f7       	brne	.-8      	; 0x148a0
    
    writeToEEPROM(3500, 32, datainternal);
   148a8:	4a e5       	ldi	r20, 0x5A	; 90
   148aa:	5a e0       	ldi	r21, 0x0A	; 10
   148ac:	60 e2       	ldi	r22, 0x20	; 32
   148ae:	70 e0       	ldi	r23, 0x00	; 0
   148b0:	8c ea       	ldi	r24, 0xAC	; 172
   148b2:	9d e0       	ldi	r25, 0x0D	; 13
   148b4:	0e 94 9d a3 	call	0x1473a
    
    readFromEEPROM(3500, 32, datainternal2);
   148b8:	4a e7       	ldi	r20, 0x7A	; 122
   148ba:	5a e0       	ldi	r21, 0x0A	; 10
   148bc:	60 e2       	ldi	r22, 0x20	; 32
   148be:	70 e0       	ldi	r23, 0x00	; 0
   148c0:	8c ea       	ldi	r24, 0xAC	; 172
   148c2:	9d e0       	ldi	r25, 0x0D	; 13
   148c4:	0e 94 79 a3 	call	0x146f2
    
    serialSend(32, datainternal2); 
   148c8:	6a e7       	ldi	r22, 0x7A	; 122
   148ca:	7a e0       	ldi	r23, 0x0A	; 10
   148cc:	80 e2       	ldi	r24, 0x20	; 32
   148ce:	0e 94 d2 a3 	call	0x147a4
   148d2:	ea e5       	ldi	r30, 0x5A	; 90
   148d4:	fa e0       	ldi	r31, 0x0A	; 10
   148d6:	80 e0       	ldi	r24, 0x00	; 0
    
      for (i=0;i<32;i++)
     datainternal[i] = i * 5; 
   148d8:	81 93       	st	Z+, r24
   148da:	8b 5f       	subi	r24, 0xFB	; 251
   148dc:	80 3a       	cpi	r24, 0xA0	; 160
   148de:	e1 f7       	brne	.-8      	; 0x148d8
    
    writeToEEPROM(3700, 32, datainternal);
   148e0:	4a e5       	ldi	r20, 0x5A	; 90
   148e2:	5a e0       	ldi	r21, 0x0A	; 10
   148e4:	60 e2       	ldi	r22, 0x20	; 32
   148e6:	70 e0       	ldi	r23, 0x00	; 0
   148e8:	84 e7       	ldi	r24, 0x74	; 116
   148ea:	9e e0       	ldi	r25, 0x0E	; 14
   148ec:	0e 94 9d a3 	call	0x1473a
    
    readFromEEPROM(3700, 32, datainternal2);
   148f0:	4a e7       	ldi	r20, 0x7A	; 122
   148f2:	5a e0       	ldi	r21, 0x0A	; 10
   148f4:	60 e2       	ldi	r22, 0x20	; 32
   148f6:	70 e0       	ldi	r23, 0x00	; 0
   148f8:	84 e7       	ldi	r24, 0x74	; 116
   148fa:	9e e0       	ldi	r25, 0x0E	; 14
   148fc:	0e 94 79 a3 	call	0x146f2
    
    serialSend(32, datainternal2); 
   14900:	6a e7       	ldi	r22, 0x7A	; 122
   14902:	7a e0       	ldi	r23, 0x0A	; 10
   14904:	80 e2       	ldi	r24, 0x20	; 32
   14906:	0e 94 d2 a3 	call	0x147a4
   1490a:	ea e5       	ldi	r30, 0x5A	; 90
   1490c:	fa e0       	ldi	r31, 0x0A	; 10
   1490e:	80 e0       	ldi	r24, 0x00	; 0
    
      for (i=0;i<32;i++)
     datainternal[i] = i * 8; 
   14910:	81 93       	st	Z+, r24
   14912:	88 5f       	subi	r24, 0xF8	; 248
   14914:	e9 f7       	brne	.-6      	; 0x14910
    
    writeToEEPROM(4000, 32, datainternal);
   14916:	4a e5       	ldi	r20, 0x5A	; 90
   14918:	5a e0       	ldi	r21, 0x0A	; 10
   1491a:	60 e2       	ldi	r22, 0x20	; 32
   1491c:	70 e0       	ldi	r23, 0x00	; 0
   1491e:	80 ea       	ldi	r24, 0xA0	; 160
   14920:	9f e0       	ldi	r25, 0x0F	; 15
   14922:	0e 94 9d a3 	call	0x1473a
    
    readFromEEPROM(4000, 32, datainternal2);
   14926:	4a e7       	ldi	r20, 0x7A	; 122
   14928:	5a e0       	ldi	r21, 0x0A	; 10
   1492a:	60 e2       	ldi	r22, 0x20	; 32
   1492c:	70 e0       	ldi	r23, 0x00	; 0
   1492e:	80 ea       	ldi	r24, 0xA0	; 160
   14930:	9f e0       	ldi	r25, 0x0F	; 15
   14932:	0e 94 79 a3 	call	0x146f2
    
    serialSend(32, datainternal2); 
   14936:	6a e7       	ldi	r22, 0x7A	; 122
   14938:	7a e0       	ldi	r23, 0x0A	; 10
   1493a:	80 e2       	ldi	r24, 0x20	; 32
   1493c:	0e 94 d2 a3 	call	0x147a4
    
    
        
  
	  return 0; 
}
   14940:	80 e0       	ldi	r24, 0x00	; 0
   14942:	90 e0       	ldi	r25, 0x00	; 0
   14944:	08 95       	ret

00014946 <wakeupMeSerial.3432>:


   sendSerialMsg();

   sleepThread(30);


   Mutex_unlock(mserialsend);

   return;
}



//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE;
   14946:	e0 91 9c 0a 	lds	r30, 0x0A9C
   1494a:	f0 91 9d 0a 	lds	r31, 0x0A9D
   1494e:	82 e0       	ldi	r24, 0x02	; 2
   14950:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14952:	0e 94 c5 a3 	call	0x1478a
   14956:	08 95       	ret
