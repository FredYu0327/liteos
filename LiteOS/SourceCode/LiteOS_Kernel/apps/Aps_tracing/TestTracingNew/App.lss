
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800a5a  00019064  000028f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002864  00016800  00016800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000063  00800a6a  00800a6a  00002908  2**0
                  ALLOC
  3 .stab         00000408  00000000  00000000  00002908  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000084  00000000  00000000  00002d10  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00002d94  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000961  00000000  00000000  00002f34  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00004df9  00000000  00000000  00003895  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000f39  00000000  00000000  0000868e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001cf3  00000000  00000000  000095c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000700  00000000  00000000  0000b2ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000273  00000000  00000000  0000b9ba  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00016800 <__vectors>:
   16800:	0c 94 46 b4 	jmp	0x1688c
   16804:	0c 94 63 b4 	jmp	0x168c6
   16808:	0c 94 63 b4 	jmp	0x168c6
   1680c:	0c 94 63 b4 	jmp	0x168c6
   16810:	0c 94 63 b4 	jmp	0x168c6
   16814:	0c 94 63 b4 	jmp	0x168c6
   16818:	0c 94 63 b4 	jmp	0x168c6
   1681c:	0c 94 63 b4 	jmp	0x168c6
   16820:	0c 94 63 b4 	jmp	0x168c6
   16824:	0c 94 63 b4 	jmp	0x168c6
   16828:	0c 94 63 b4 	jmp	0x168c6
   1682c:	0c 94 63 b4 	jmp	0x168c6
   16830:	0c 94 63 b4 	jmp	0x168c6
   16834:	0c 94 63 b4 	jmp	0x168c6
   16838:	0c 94 63 b4 	jmp	0x168c6
   1683c:	0c 94 63 b4 	jmp	0x168c6
   16840:	0c 94 63 b4 	jmp	0x168c6
   16844:	0c 94 63 b4 	jmp	0x168c6
   16848:	0c 94 63 b4 	jmp	0x168c6
   1684c:	0c 94 63 b4 	jmp	0x168c6
   16850:	0c 94 63 b4 	jmp	0x168c6
   16854:	0c 94 63 b4 	jmp	0x168c6
   16858:	0c 94 63 b4 	jmp	0x168c6
   1685c:	0c 94 63 b4 	jmp	0x168c6
   16860:	0c 94 63 b4 	jmp	0x168c6
   16864:	0c 94 63 b4 	jmp	0x168c6
   16868:	0c 94 63 b4 	jmp	0x168c6
   1686c:	0c 94 63 b4 	jmp	0x168c6
   16870:	0c 94 63 b4 	jmp	0x168c6
   16874:	0c 94 63 b4 	jmp	0x168c6
   16878:	0c 94 63 b4 	jmp	0x168c6
   1687c:	0c 94 63 b4 	jmp	0x168c6
   16880:	0c 94 63 b4 	jmp	0x168c6
   16884:	0c 94 63 b4 	jmp	0x168c6
   16888:	0c 94 63 b4 	jmp	0x168c6

0001688c <__ctors_end>:
   1688c:	11 24       	eor	r1, r1
   1688e:	1f be       	out	0x3f, r1	; 63
   16890:	ca ee       	ldi	r28, 0xEA	; 234
   16892:	db e0       	ldi	r29, 0x0B	; 11
   16894:	de bf       	out	0x3e, r29	; 62
   16896:	cd bf       	out	0x3d, r28	; 61

00016898 <__do_copy_data>:
   16898:	1a e0       	ldi	r17, 0x0A	; 10
   1689a:	aa e5       	ldi	r26, 0x5A	; 90
   1689c:	ba e0       	ldi	r27, 0x0A	; 10
   1689e:	e4 e6       	ldi	r30, 0x64	; 100
   168a0:	f0 e9       	ldi	r31, 0x90	; 144
   168a2:	01 e0       	ldi	r16, 0x01	; 1
   168a4:	0b bf       	out	0x3b, r16	; 59
   168a6:	02 c0       	rjmp	.+4      	; 0x168ac
   168a8:	07 90       	elpm	r0, Z+
   168aa:	0d 92       	st	X+, r0
   168ac:	aa 36       	cpi	r26, 0x6A	; 106
   168ae:	b1 07       	cpc	r27, r17
   168b0:	d9 f7       	brne	.-10     	; 0x168a8

000168b2 <__do_clear_bss>:
   168b2:	1a e0       	ldi	r17, 0x0A	; 10
   168b4:	aa e6       	ldi	r26, 0x6A	; 106
   168b6:	ba e0       	ldi	r27, 0x0A	; 10
   168b8:	01 c0       	rjmp	.+2      	; 0x168bc

000168ba <.do_clear_bss_loop>:
   168ba:	1d 92       	st	X+, r1

000168bc <.do_clear_bss_start>:
   168bc:	ad 3c       	cpi	r26, 0xCD	; 205
   168be:	b1 07       	cpc	r27, r17
   168c0:	e1 f7       	brne	.-8      	; 0x168ba
   168c2:	0c 94 23 b7 	jmp	0x16e46

000168c6 <__bad_interrupt>:
   168c6:	0c 94 00 b4 	jmp	0x16800

000168ca <test>:

uint8_t i,j,k; 

void test()
{ 
   168ca:	cf 93       	push	r28
   168cc:	df 93       	push	r29
   168ce:	cd b7       	in	r28, 0x3d	; 61
   168d0:	de b7       	in	r29, 0x3e	; 62
	PUSH_GPR();     
   168d2:	0f 92       	push	r0
   168d4:	1f 92       	push	r1
   168d6:	2f 92       	push	r2
   168d8:	3f 92       	push	r3
   168da:	4f 92       	push	r4
   168dc:	5f 92       	push	r5
   168de:	6f 92       	push	r6
   168e0:	7f 92       	push	r7
   168e2:	8f 92       	push	r8
   168e4:	9f 92       	push	r9
   168e6:	af 92       	push	r10
   168e8:	bf 92       	push	r11
   168ea:	cf 92       	push	r12
   168ec:	df 92       	push	r13
   168ee:	ef 92       	push	r14
   168f0:	ff 92       	push	r15
   168f2:	0f 93       	push	r16
   168f4:	1f 93       	push	r17
   168f6:	2f 93       	push	r18
   168f8:	3f 93       	push	r19
   168fa:	4f 93       	push	r20
   168fc:	5f 93       	push	r21
   168fe:	6f 93       	push	r22
   16900:	7f 93       	push	r23
   16902:	8f 93       	push	r24
   16904:	9f 93       	push	r25
   16906:	af 93       	push	r26
   16908:	bf 93       	push	r27
   1690a:	cf 93       	push	r28
   1690c:	df 93       	push	r29
   1690e:	ef 93       	push	r30
   16910:	ff 93       	push	r31
  i = 1; 
   16912:	81 e0       	ldi	r24, 0x01	; 1
   16914:	80 93 77 0a 	sts	0x0A77, r24
  

  
 
  j = i * 2; 
   16918:	80 91 77 0a 	lds	r24, 0x0A77
   1691c:	99 27       	eor	r25, r25
   1691e:	88 0f       	add	r24, r24
   16920:	99 1f       	adc	r25, r25
   16922:	80 93 71 0a 	sts	0x0A71, r24
  k = i + j; 
   16926:	90 91 77 0a 	lds	r25, 0x0A77
   1692a:	80 91 71 0a 	lds	r24, 0x0A71
   1692e:	89 0f       	add	r24, r25
   16930:	80 93 72 0a 	sts	0x0A72, r24
  for (i=0;i<10;i++)
   16934:	10 92 77 0a 	sts	0x0A77, r1
   16938:	07 c0       	rjmp	.+14     	; 0x16948
    greenToggle();
   1693a:	0e 94 99 bc 	call	0x17932
   1693e:	80 91 77 0a 	lds	r24, 0x0A77
   16942:	8f 5f       	subi	r24, 0xFF	; 255
   16944:	80 93 77 0a 	sts	0x0A77, r24
   16948:	80 91 77 0a 	lds	r24, 0x0A77
   1694c:	8a 30       	cpi	r24, 0x0A	; 10
   1694e:	a8 f3       	brcs	.-22     	; 0x1693a
  k = j * 3; 
   16950:	80 91 71 0a 	lds	r24, 0x0A71
   16954:	28 2f       	mov	r18, r24
   16956:	33 27       	eor	r19, r19
   16958:	c9 01       	movw	r24, r18
   1695a:	88 0f       	add	r24, r24
   1695c:	99 1f       	adc	r25, r25
   1695e:	82 0f       	add	r24, r18
   16960:	93 1f       	adc	r25, r19
   16962:	80 93 72 0a 	sts	0x0A72, r24
  
  PUSH_GPR(); 
   16966:	0f 92       	push	r0
   16968:	1f 92       	push	r1
   1696a:	2f 92       	push	r2
   1696c:	3f 92       	push	r3
   1696e:	4f 92       	push	r4
   16970:	5f 92       	push	r5
   16972:	6f 92       	push	r6
   16974:	7f 92       	push	r7
   16976:	8f 92       	push	r8
   16978:	9f 92       	push	r9
   1697a:	af 92       	push	r10
   1697c:	bf 92       	push	r11
   1697e:	cf 92       	push	r12
   16980:	df 92       	push	r13
   16982:	ef 92       	push	r14
   16984:	ff 92       	push	r15
   16986:	0f 93       	push	r16
   16988:	1f 93       	push	r17
   1698a:	2f 93       	push	r18
   1698c:	3f 93       	push	r19
   1698e:	4f 93       	push	r20
   16990:	5f 93       	push	r21
   16992:	6f 93       	push	r22
   16994:	7f 93       	push	r23
   16996:	8f 93       	push	r24
   16998:	9f 93       	push	r25
   1699a:	af 93       	push	r26
   1699c:	bf 93       	push	r27
   1699e:	cf 93       	push	r28
   169a0:	df 93       	push	r29
   169a2:	ef 93       	push	r30
   169a4:	ff 93       	push	r31
  POP_GPR();
   169a6:	ff 91       	pop	r31
   169a8:	ef 91       	pop	r30
   169aa:	df 91       	pop	r29
   169ac:	cf 91       	pop	r28
   169ae:	bf 91       	pop	r27
   169b0:	af 91       	pop	r26
   169b2:	9f 91       	pop	r25
   169b4:	8f 91       	pop	r24
   169b6:	7f 91       	pop	r23
   169b8:	6f 91       	pop	r22
   169ba:	5f 91       	pop	r21
   169bc:	4f 91       	pop	r20
   169be:	3f 91       	pop	r19
   169c0:	2f 91       	pop	r18
   169c2:	1f 91       	pop	r17
   169c4:	0f 91       	pop	r16
   169c6:	ff 90       	pop	r15
   169c8:	ef 90       	pop	r14
   169ca:	df 90       	pop	r13
   169cc:	cf 90       	pop	r12
   169ce:	bf 90       	pop	r11
   169d0:	af 90       	pop	r10
   169d2:	9f 90       	pop	r9
   169d4:	8f 90       	pop	r8
   169d6:	7f 90       	pop	r7
   169d8:	6f 90       	pop	r6
   169da:	5f 90       	pop	r5
   169dc:	4f 90       	pop	r4
   169de:	3f 90       	pop	r3
   169e0:	2f 90       	pop	r2
   169e2:	1f 90       	pop	r1
   169e4:	0f 90       	pop	r0
    PUSH_GPR(); 
   169e6:	0f 92       	push	r0
   169e8:	1f 92       	push	r1
   169ea:	2f 92       	push	r2
   169ec:	3f 92       	push	r3
   169ee:	4f 92       	push	r4
   169f0:	5f 92       	push	r5
   169f2:	6f 92       	push	r6
   169f4:	7f 92       	push	r7
   169f6:	8f 92       	push	r8
   169f8:	9f 92       	push	r9
   169fa:	af 92       	push	r10
   169fc:	bf 92       	push	r11
   169fe:	cf 92       	push	r12
   16a00:	df 92       	push	r13
   16a02:	ef 92       	push	r14
   16a04:	ff 92       	push	r15
   16a06:	0f 93       	push	r16
   16a08:	1f 93       	push	r17
   16a0a:	2f 93       	push	r18
   16a0c:	3f 93       	push	r19
   16a0e:	4f 93       	push	r20
   16a10:	5f 93       	push	r21
   16a12:	6f 93       	push	r22
   16a14:	7f 93       	push	r23
   16a16:	8f 93       	push	r24
   16a18:	9f 93       	push	r25
   16a1a:	af 93       	push	r26
   16a1c:	bf 93       	push	r27
   16a1e:	cf 93       	push	r28
   16a20:	df 93       	push	r29
   16a22:	ef 93       	push	r30
   16a24:	ff 93       	push	r31
  POP_GPR();
   16a26:	ff 91       	pop	r31
   16a28:	ef 91       	pop	r30
   16a2a:	df 91       	pop	r29
   16a2c:	cf 91       	pop	r28
   16a2e:	bf 91       	pop	r27
   16a30:	af 91       	pop	r26
   16a32:	9f 91       	pop	r25
   16a34:	8f 91       	pop	r24
   16a36:	7f 91       	pop	r23
   16a38:	6f 91       	pop	r22
   16a3a:	5f 91       	pop	r21
   16a3c:	4f 91       	pop	r20
   16a3e:	3f 91       	pop	r19
   16a40:	2f 91       	pop	r18
   16a42:	1f 91       	pop	r17
   16a44:	0f 91       	pop	r16
   16a46:	ff 90       	pop	r15
   16a48:	ef 90       	pop	r14
   16a4a:	df 90       	pop	r13
   16a4c:	cf 90       	pop	r12
   16a4e:	bf 90       	pop	r11
   16a50:	af 90       	pop	r10
   16a52:	9f 90       	pop	r9
   16a54:	8f 90       	pop	r8
   16a56:	7f 90       	pop	r7
   16a58:	6f 90       	pop	r6
   16a5a:	5f 90       	pop	r5
   16a5c:	4f 90       	pop	r4
   16a5e:	3f 90       	pop	r3
   16a60:	2f 90       	pop	r2
   16a62:	1f 90       	pop	r1
   16a64:	0f 90       	pop	r0
    PUSH_GPR(); 
   16a66:	0f 92       	push	r0
   16a68:	1f 92       	push	r1
   16a6a:	2f 92       	push	r2
   16a6c:	3f 92       	push	r3
   16a6e:	4f 92       	push	r4
   16a70:	5f 92       	push	r5
   16a72:	6f 92       	push	r6
   16a74:	7f 92       	push	r7
   16a76:	8f 92       	push	r8
   16a78:	9f 92       	push	r9
   16a7a:	af 92       	push	r10
   16a7c:	bf 92       	push	r11
   16a7e:	cf 92       	push	r12
   16a80:	df 92       	push	r13
   16a82:	ef 92       	push	r14
   16a84:	ff 92       	push	r15
   16a86:	0f 93       	push	r16
   16a88:	1f 93       	push	r17
   16a8a:	2f 93       	push	r18
   16a8c:	3f 93       	push	r19
   16a8e:	4f 93       	push	r20
   16a90:	5f 93       	push	r21
   16a92:	6f 93       	push	r22
   16a94:	7f 93       	push	r23
   16a96:	8f 93       	push	r24
   16a98:	9f 93       	push	r25
   16a9a:	af 93       	push	r26
   16a9c:	bf 93       	push	r27
   16a9e:	cf 93       	push	r28
   16aa0:	df 93       	push	r29
   16aa2:	ef 93       	push	r30
   16aa4:	ff 93       	push	r31
  POP_GPR();
   16aa6:	ff 91       	pop	r31
   16aa8:	ef 91       	pop	r30
   16aaa:	df 91       	pop	r29
   16aac:	cf 91       	pop	r28
   16aae:	bf 91       	pop	r27
   16ab0:	af 91       	pop	r26
   16ab2:	9f 91       	pop	r25
   16ab4:	8f 91       	pop	r24
   16ab6:	7f 91       	pop	r23
   16ab8:	6f 91       	pop	r22
   16aba:	5f 91       	pop	r21
   16abc:	4f 91       	pop	r20
   16abe:	3f 91       	pop	r19
   16ac0:	2f 91       	pop	r18
   16ac2:	1f 91       	pop	r17
   16ac4:	0f 91       	pop	r16
   16ac6:	ff 90       	pop	r15
   16ac8:	ef 90       	pop	r14
   16aca:	df 90       	pop	r13
   16acc:	cf 90       	pop	r12
   16ace:	bf 90       	pop	r11
   16ad0:	af 90       	pop	r10
   16ad2:	9f 90       	pop	r9
   16ad4:	8f 90       	pop	r8
   16ad6:	7f 90       	pop	r7
   16ad8:	6f 90       	pop	r6
   16ada:	5f 90       	pop	r5
   16adc:	4f 90       	pop	r4
   16ade:	3f 90       	pop	r3
   16ae0:	2f 90       	pop	r2
   16ae2:	1f 90       	pop	r1
   16ae4:	0f 90       	pop	r0
  
    PUSH_GPR(); 
   16ae6:	0f 92       	push	r0
   16ae8:	1f 92       	push	r1
   16aea:	2f 92       	push	r2
   16aec:	3f 92       	push	r3
   16aee:	4f 92       	push	r4
   16af0:	5f 92       	push	r5
   16af2:	6f 92       	push	r6
   16af4:	7f 92       	push	r7
   16af6:	8f 92       	push	r8
   16af8:	9f 92       	push	r9
   16afa:	af 92       	push	r10
   16afc:	bf 92       	push	r11
   16afe:	cf 92       	push	r12
   16b00:	df 92       	push	r13
   16b02:	ef 92       	push	r14
   16b04:	ff 92       	push	r15
   16b06:	0f 93       	push	r16
   16b08:	1f 93       	push	r17
   16b0a:	2f 93       	push	r18
   16b0c:	3f 93       	push	r19
   16b0e:	4f 93       	push	r20
   16b10:	5f 93       	push	r21
   16b12:	6f 93       	push	r22
   16b14:	7f 93       	push	r23
   16b16:	8f 93       	push	r24
   16b18:	9f 93       	push	r25
   16b1a:	af 93       	push	r26
   16b1c:	bf 93       	push	r27
   16b1e:	cf 93       	push	r28
   16b20:	df 93       	push	r29
   16b22:	ef 93       	push	r30
   16b24:	ff 93       	push	r31
  POP_GPR();
   16b26:	ff 91       	pop	r31
   16b28:	ef 91       	pop	r30
   16b2a:	df 91       	pop	r29
   16b2c:	cf 91       	pop	r28
   16b2e:	bf 91       	pop	r27
   16b30:	af 91       	pop	r26
   16b32:	9f 91       	pop	r25
   16b34:	8f 91       	pop	r24
   16b36:	7f 91       	pop	r23
   16b38:	6f 91       	pop	r22
   16b3a:	5f 91       	pop	r21
   16b3c:	4f 91       	pop	r20
   16b3e:	3f 91       	pop	r19
   16b40:	2f 91       	pop	r18
   16b42:	1f 91       	pop	r17
   16b44:	0f 91       	pop	r16
   16b46:	ff 90       	pop	r15
   16b48:	ef 90       	pop	r14
   16b4a:	df 90       	pop	r13
   16b4c:	cf 90       	pop	r12
   16b4e:	bf 90       	pop	r11
   16b50:	af 90       	pop	r10
   16b52:	9f 90       	pop	r9
   16b54:	8f 90       	pop	r8
   16b56:	7f 90       	pop	r7
   16b58:	6f 90       	pop	r6
   16b5a:	5f 90       	pop	r5
   16b5c:	4f 90       	pop	r4
   16b5e:	3f 90       	pop	r3
   16b60:	2f 90       	pop	r2
   16b62:	1f 90       	pop	r1
   16b64:	0f 90       	pop	r0
    PUSH_GPR(); 
   16b66:	0f 92       	push	r0
   16b68:	1f 92       	push	r1
   16b6a:	2f 92       	push	r2
   16b6c:	3f 92       	push	r3
   16b6e:	4f 92       	push	r4
   16b70:	5f 92       	push	r5
   16b72:	6f 92       	push	r6
   16b74:	7f 92       	push	r7
   16b76:	8f 92       	push	r8
   16b78:	9f 92       	push	r9
   16b7a:	af 92       	push	r10
   16b7c:	bf 92       	push	r11
   16b7e:	cf 92       	push	r12
   16b80:	df 92       	push	r13
   16b82:	ef 92       	push	r14
   16b84:	ff 92       	push	r15
   16b86:	0f 93       	push	r16
   16b88:	1f 93       	push	r17
   16b8a:	2f 93       	push	r18
   16b8c:	3f 93       	push	r19
   16b8e:	4f 93       	push	r20
   16b90:	5f 93       	push	r21
   16b92:	6f 93       	push	r22
   16b94:	7f 93       	push	r23
   16b96:	8f 93       	push	r24
   16b98:	9f 93       	push	r25
   16b9a:	af 93       	push	r26
   16b9c:	bf 93       	push	r27
   16b9e:	cf 93       	push	r28
   16ba0:	df 93       	push	r29
   16ba2:	ef 93       	push	r30
   16ba4:	ff 93       	push	r31
  POP_GPR();
   16ba6:	ff 91       	pop	r31
   16ba8:	ef 91       	pop	r30
   16baa:	df 91       	pop	r29
   16bac:	cf 91       	pop	r28
   16bae:	bf 91       	pop	r27
   16bb0:	af 91       	pop	r26
   16bb2:	9f 91       	pop	r25
   16bb4:	8f 91       	pop	r24
   16bb6:	7f 91       	pop	r23
   16bb8:	6f 91       	pop	r22
   16bba:	5f 91       	pop	r21
   16bbc:	4f 91       	pop	r20
   16bbe:	3f 91       	pop	r19
   16bc0:	2f 91       	pop	r18
   16bc2:	1f 91       	pop	r17
   16bc4:	0f 91       	pop	r16
   16bc6:	ff 90       	pop	r15
   16bc8:	ef 90       	pop	r14
   16bca:	df 90       	pop	r13
   16bcc:	cf 90       	pop	r12
   16bce:	bf 90       	pop	r11
   16bd0:	af 90       	pop	r10
   16bd2:	9f 90       	pop	r9
   16bd4:	8f 90       	pop	r8
   16bd6:	7f 90       	pop	r7
   16bd8:	6f 90       	pop	r6
   16bda:	5f 90       	pop	r5
   16bdc:	4f 90       	pop	r4
   16bde:	3f 90       	pop	r3
   16be0:	2f 90       	pop	r2
   16be2:	1f 90       	pop	r1
   16be4:	0f 90       	pop	r0
    PUSH_GPR(); 
   16be6:	0f 92       	push	r0
   16be8:	1f 92       	push	r1
   16bea:	2f 92       	push	r2
   16bec:	3f 92       	push	r3
   16bee:	4f 92       	push	r4
   16bf0:	5f 92       	push	r5
   16bf2:	6f 92       	push	r6
   16bf4:	7f 92       	push	r7
   16bf6:	8f 92       	push	r8
   16bf8:	9f 92       	push	r9
   16bfa:	af 92       	push	r10
   16bfc:	bf 92       	push	r11
   16bfe:	cf 92       	push	r12
   16c00:	df 92       	push	r13
   16c02:	ef 92       	push	r14
   16c04:	ff 92       	push	r15
   16c06:	0f 93       	push	r16
   16c08:	1f 93       	push	r17
   16c0a:	2f 93       	push	r18
   16c0c:	3f 93       	push	r19
   16c0e:	4f 93       	push	r20
   16c10:	5f 93       	push	r21
   16c12:	6f 93       	push	r22
   16c14:	7f 93       	push	r23
   16c16:	8f 93       	push	r24
   16c18:	9f 93       	push	r25
   16c1a:	af 93       	push	r26
   16c1c:	bf 93       	push	r27
   16c1e:	cf 93       	push	r28
   16c20:	df 93       	push	r29
   16c22:	ef 93       	push	r30
   16c24:	ff 93       	push	r31
  POP_GPR();
   16c26:	ff 91       	pop	r31
   16c28:	ef 91       	pop	r30
   16c2a:	df 91       	pop	r29
   16c2c:	cf 91       	pop	r28
   16c2e:	bf 91       	pop	r27
   16c30:	af 91       	pop	r26
   16c32:	9f 91       	pop	r25
   16c34:	8f 91       	pop	r24
   16c36:	7f 91       	pop	r23
   16c38:	6f 91       	pop	r22
   16c3a:	5f 91       	pop	r21
   16c3c:	4f 91       	pop	r20
   16c3e:	3f 91       	pop	r19
   16c40:	2f 91       	pop	r18
   16c42:	1f 91       	pop	r17
   16c44:	0f 91       	pop	r16
   16c46:	ff 90       	pop	r15
   16c48:	ef 90       	pop	r14
   16c4a:	df 90       	pop	r13
   16c4c:	cf 90       	pop	r12
   16c4e:	bf 90       	pop	r11
   16c50:	af 90       	pop	r10
   16c52:	9f 90       	pop	r9
   16c54:	8f 90       	pop	r8
   16c56:	7f 90       	pop	r7
   16c58:	6f 90       	pop	r6
   16c5a:	5f 90       	pop	r5
   16c5c:	4f 90       	pop	r4
   16c5e:	3f 90       	pop	r3
   16c60:	2f 90       	pop	r2
   16c62:	1f 90       	pop	r1
   16c64:	0f 90       	pop	r0
    PUSH_GPR(); 
   16c66:	0f 92       	push	r0
   16c68:	1f 92       	push	r1
   16c6a:	2f 92       	push	r2
   16c6c:	3f 92       	push	r3
   16c6e:	4f 92       	push	r4
   16c70:	5f 92       	push	r5
   16c72:	6f 92       	push	r6
   16c74:	7f 92       	push	r7
   16c76:	8f 92       	push	r8
   16c78:	9f 92       	push	r9
   16c7a:	af 92       	push	r10
   16c7c:	bf 92       	push	r11
   16c7e:	cf 92       	push	r12
   16c80:	df 92       	push	r13
   16c82:	ef 92       	push	r14
   16c84:	ff 92       	push	r15
   16c86:	0f 93       	push	r16
   16c88:	1f 93       	push	r17
   16c8a:	2f 93       	push	r18
   16c8c:	3f 93       	push	r19
   16c8e:	4f 93       	push	r20
   16c90:	5f 93       	push	r21
   16c92:	6f 93       	push	r22
   16c94:	7f 93       	push	r23
   16c96:	8f 93       	push	r24
   16c98:	9f 93       	push	r25
   16c9a:	af 93       	push	r26
   16c9c:	bf 93       	push	r27
   16c9e:	cf 93       	push	r28
   16ca0:	df 93       	push	r29
   16ca2:	ef 93       	push	r30
   16ca4:	ff 93       	push	r31
  POP_GPR();
   16ca6:	ff 91       	pop	r31
   16ca8:	ef 91       	pop	r30
   16caa:	df 91       	pop	r29
   16cac:	cf 91       	pop	r28
   16cae:	bf 91       	pop	r27
   16cb0:	af 91       	pop	r26
   16cb2:	9f 91       	pop	r25
   16cb4:	8f 91       	pop	r24
   16cb6:	7f 91       	pop	r23
   16cb8:	6f 91       	pop	r22
   16cba:	5f 91       	pop	r21
   16cbc:	4f 91       	pop	r20
   16cbe:	3f 91       	pop	r19
   16cc0:	2f 91       	pop	r18
   16cc2:	1f 91       	pop	r17
   16cc4:	0f 91       	pop	r16
   16cc6:	ff 90       	pop	r15
   16cc8:	ef 90       	pop	r14
   16cca:	df 90       	pop	r13
   16ccc:	cf 90       	pop	r12
   16cce:	bf 90       	pop	r11
   16cd0:	af 90       	pop	r10
   16cd2:	9f 90       	pop	r9
   16cd4:	8f 90       	pop	r8
   16cd6:	7f 90       	pop	r7
   16cd8:	6f 90       	pop	r6
   16cda:	5f 90       	pop	r5
   16cdc:	4f 90       	pop	r4
   16cde:	3f 90       	pop	r3
   16ce0:	2f 90       	pop	r2
   16ce2:	1f 90       	pop	r1
   16ce4:	0f 90       	pop	r0
    PUSH_GPR(); 
   16ce6:	0f 92       	push	r0
   16ce8:	1f 92       	push	r1
   16cea:	2f 92       	push	r2
   16cec:	3f 92       	push	r3
   16cee:	4f 92       	push	r4
   16cf0:	5f 92       	push	r5
   16cf2:	6f 92       	push	r6
   16cf4:	7f 92       	push	r7
   16cf6:	8f 92       	push	r8
   16cf8:	9f 92       	push	r9
   16cfa:	af 92       	push	r10
   16cfc:	bf 92       	push	r11
   16cfe:	cf 92       	push	r12
   16d00:	df 92       	push	r13
   16d02:	ef 92       	push	r14
   16d04:	ff 92       	push	r15
   16d06:	0f 93       	push	r16
   16d08:	1f 93       	push	r17
   16d0a:	2f 93       	push	r18
   16d0c:	3f 93       	push	r19
   16d0e:	4f 93       	push	r20
   16d10:	5f 93       	push	r21
   16d12:	6f 93       	push	r22
   16d14:	7f 93       	push	r23
   16d16:	8f 93       	push	r24
   16d18:	9f 93       	push	r25
   16d1a:	af 93       	push	r26
   16d1c:	bf 93       	push	r27
   16d1e:	cf 93       	push	r28
   16d20:	df 93       	push	r29
   16d22:	ef 93       	push	r30
   16d24:	ff 93       	push	r31
  POP_GPR();
   16d26:	ff 91       	pop	r31
   16d28:	ef 91       	pop	r30
   16d2a:	df 91       	pop	r29
   16d2c:	cf 91       	pop	r28
   16d2e:	bf 91       	pop	r27
   16d30:	af 91       	pop	r26
   16d32:	9f 91       	pop	r25
   16d34:	8f 91       	pop	r24
   16d36:	7f 91       	pop	r23
   16d38:	6f 91       	pop	r22
   16d3a:	5f 91       	pop	r21
   16d3c:	4f 91       	pop	r20
   16d3e:	3f 91       	pop	r19
   16d40:	2f 91       	pop	r18
   16d42:	1f 91       	pop	r17
   16d44:	0f 91       	pop	r16
   16d46:	ff 90       	pop	r15
   16d48:	ef 90       	pop	r14
   16d4a:	df 90       	pop	r13
   16d4c:	cf 90       	pop	r12
   16d4e:	bf 90       	pop	r11
   16d50:	af 90       	pop	r10
   16d52:	9f 90       	pop	r9
   16d54:	8f 90       	pop	r8
   16d56:	7f 90       	pop	r7
   16d58:	6f 90       	pop	r6
   16d5a:	5f 90       	pop	r5
   16d5c:	4f 90       	pop	r4
   16d5e:	3f 90       	pop	r3
   16d60:	2f 90       	pop	r2
   16d62:	1f 90       	pop	r1
   16d64:	0f 90       	pop	r0
    PUSH_GPR(); 
   16d66:	0f 92       	push	r0
   16d68:	1f 92       	push	r1
   16d6a:	2f 92       	push	r2
   16d6c:	3f 92       	push	r3
   16d6e:	4f 92       	push	r4
   16d70:	5f 92       	push	r5
   16d72:	6f 92       	push	r6
   16d74:	7f 92       	push	r7
   16d76:	8f 92       	push	r8
   16d78:	9f 92       	push	r9
   16d7a:	af 92       	push	r10
   16d7c:	bf 92       	push	r11
   16d7e:	cf 92       	push	r12
   16d80:	df 92       	push	r13
   16d82:	ef 92       	push	r14
   16d84:	ff 92       	push	r15
   16d86:	0f 93       	push	r16
   16d88:	1f 93       	push	r17
   16d8a:	2f 93       	push	r18
   16d8c:	3f 93       	push	r19
   16d8e:	4f 93       	push	r20
   16d90:	5f 93       	push	r21
   16d92:	6f 93       	push	r22
   16d94:	7f 93       	push	r23
   16d96:	8f 93       	push	r24
   16d98:	9f 93       	push	r25
   16d9a:	af 93       	push	r26
   16d9c:	bf 93       	push	r27
   16d9e:	cf 93       	push	r28
   16da0:	df 93       	push	r29
   16da2:	ef 93       	push	r30
   16da4:	ff 93       	push	r31
  POP_GPR();
   16da6:	ff 91       	pop	r31
   16da8:	ef 91       	pop	r30
   16daa:	df 91       	pop	r29
   16dac:	cf 91       	pop	r28
   16dae:	bf 91       	pop	r27
   16db0:	af 91       	pop	r26
   16db2:	9f 91       	pop	r25
   16db4:	8f 91       	pop	r24
   16db6:	7f 91       	pop	r23
   16db8:	6f 91       	pop	r22
   16dba:	5f 91       	pop	r21
   16dbc:	4f 91       	pop	r20
   16dbe:	3f 91       	pop	r19
   16dc0:	2f 91       	pop	r18
   16dc2:	1f 91       	pop	r17
   16dc4:	0f 91       	pop	r16
   16dc6:	ff 90       	pop	r15
   16dc8:	ef 90       	pop	r14
   16dca:	df 90       	pop	r13
   16dcc:	cf 90       	pop	r12
   16dce:	bf 90       	pop	r11
   16dd0:	af 90       	pop	r10
   16dd2:	9f 90       	pop	r9
   16dd4:	8f 90       	pop	r8
   16dd6:	7f 90       	pop	r7
   16dd8:	6f 90       	pop	r6
   16dda:	5f 90       	pop	r5
   16ddc:	4f 90       	pop	r4
   16dde:	3f 90       	pop	r3
   16de0:	2f 90       	pop	r2
   16de2:	1f 90       	pop	r1
   16de4:	0f 90       	pop	r0
  
  counter1++;
   16de6:	80 91 73 0a 	lds	r24, 0x0A73
   16dea:	90 91 74 0a 	lds	r25, 0x0A74
   16dee:	01 96       	adiw	r24, 0x01	; 1
   16df0:	90 93 74 0a 	sts	0x0A74, r25
   16df4:	80 93 73 0a 	sts	0x0A73, r24
  //mythread->state=STATE_ACTIVE;
  //syscall_postThreadTask();
  
  radioSend_string_experimental("Hello, world!\n"); 
   16df8:	8a e5       	ldi	r24, 0x5A	; 90
   16dfa:	9a e0       	ldi	r25, 0x0A	; 10
   16dfc:	0e 94 77 c0 	call	0x180ee
  POP_GPR(); 
   16e00:	ff 91       	pop	r31
   16e02:	ef 91       	pop	r30
   16e04:	df 91       	pop	r29
   16e06:	cf 91       	pop	r28
   16e08:	bf 91       	pop	r27
   16e0a:	af 91       	pop	r26
   16e0c:	9f 91       	pop	r25
   16e0e:	8f 91       	pop	r24
   16e10:	7f 91       	pop	r23
   16e12:	6f 91       	pop	r22
   16e14:	5f 91       	pop	r21
   16e16:	4f 91       	pop	r20
   16e18:	3f 91       	pop	r19
   16e1a:	2f 91       	pop	r18
   16e1c:	1f 91       	pop	r17
   16e1e:	0f 91       	pop	r16
   16e20:	ff 90       	pop	r15
   16e22:	ef 90       	pop	r14
   16e24:	df 90       	pop	r13
   16e26:	cf 90       	pop	r12
   16e28:	bf 90       	pop	r11
   16e2a:	af 90       	pop	r10
   16e2c:	9f 90       	pop	r9
   16e2e:	8f 90       	pop	r8
   16e30:	7f 90       	pop	r7
   16e32:	6f 90       	pop	r6
   16e34:	5f 90       	pop	r5
   16e36:	4f 90       	pop	r4
   16e38:	3f 90       	pop	r3
   16e3a:	2f 90       	pop	r2
   16e3c:	1f 90       	pop	r1
   16e3e:	0f 90       	pop	r0
   16e40:	df 91       	pop	r29
   16e42:	cf 91       	pop	r28
   16e44:	08 95       	ret

00016e46 <main>:
  	  
}

int main()
{
   16e46:	cf 93       	push	r28
   16e48:	df 93       	push	r29
   16e4a:	cd b7       	in	r28, 0x3d	; 61
   16e4c:	de b7       	in	r29, 0x3e	; 62
   16e4e:	23 97       	sbiw	r28, 0x03	; 3
   16e50:	0f b6       	in	r0, 0x3f	; 63
   16e52:	f8 94       	cli
   16e54:	de bf       	out	0x3e, r29	; 62
   16e56:	0f be       	out	0x3f, r0	; 63
   16e58:	cd bf       	out	0x3d, r28	; 61
 uint8_t index;  
 __asm__ __volatile__("sei" ::); 
   16e5a:	78 94       	sei
 
 counter1 = counter2 = 0; 
   16e5c:	10 92 79 0a 	sts	0x0A79, r1
   16e60:	10 92 78 0a 	sts	0x0A78, r1
   16e64:	80 91 78 0a 	lds	r24, 0x0A78
   16e68:	90 91 79 0a 	lds	r25, 0x0A79
   16e6c:	90 93 74 0a 	sts	0x0A74, r25
   16e70:	80 93 73 0a 	sts	0x0A73, r24
 thread** current_thread;
   
 current_thread = getCurrentThread();
   16e74:	0e 94 74 c5 	call	0x18ae8
   16e78:	9a 83       	std	Y+2, r25	; 0x02
   16e7a:	89 83       	std	Y+1, r24	; 0x01
   
 mythread = *current_thread;
   16e7c:	e9 81       	ldd	r30, Y+1	; 0x01
   16e7e:	fa 81       	ldd	r31, Y+2	; 0x02
   16e80:	80 81       	ld	r24, Z
   16e82:	91 81       	ldd	r25, Z+1	; 0x01
   16e84:	90 93 76 0a 	sts	0x0A76, r25
   16e88:	80 93 75 0a 	sts	0x0A75, r24
   

 
 setTimerFunction(50, 0, test);
   16e8c:	85 e6       	ldi	r24, 0x65	; 101
   16e8e:	94 eb       	ldi	r25, 0xB4	; 180
   16e90:	ac 01       	movw	r20, r24
   16e92:	60 e0       	ldi	r22, 0x00	; 0
   16e94:	82 e3       	ldi	r24, 0x32	; 50
   16e96:	90 e0       	ldi	r25, 0x00	; 0
   16e98:	0e 94 d0 c7 	call	0x18fa0

while (1)
{ 
 hibernateThread();
   16e9c:	0e 94 0b c6 	call	0x18c16
 //counter2++;
 //radioSend_string("Hello, world!\n"); 
  
}
   16ea0:	fd cf       	rjmp	.-6      	; 0x16e9c

00016ea2 <get_light>:
#include "thread.h"
#include "system.h"

int get_light()
{
   16ea2:	cf 93       	push	r28
   16ea4:	df 93       	push	r29
   16ea6:	cd b7       	in	r28, 0x3d	; 61
   16ea8:	de b7       	in	r29, 0x3e	; 62
   16eaa:	24 97       	sbiw	r28, 0x04	; 4
   16eac:	0f b6       	in	r0, 0x3f	; 63
   16eae:	f8 94       	cli
   16eb0:	de bf       	out	0x3e, r29	; 62
   16eb2:	0f be       	out	0x3f, r0	; 63
   16eb4:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADC_READ_LIGHT;
   16eb6:	80 e4       	ldi	r24, 0x40	; 64
   16eb8:	9a ee       	ldi	r25, 0xEA	; 234
   16eba:	9a 83       	std	Y+2, r25	; 0x02
   16ebc:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   16ebe:	0e 94 74 c5 	call	0x18ae8
   16ec2:	9c 83       	std	Y+4, r25	; 0x04
   16ec4:	8b 83       	std	Y+3, r24	; 0x03
   fp(); 
   16ec6:	e9 81       	ldd	r30, Y+1	; 0x01
   16ec8:	fa 81       	ldd	r31, Y+2	; 0x02
   16eca:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   16ecc:	eb 81       	ldd	r30, Y+3	; 0x03
   16ece:	fc 81       	ldd	r31, Y+4	; 0x04
   16ed0:	01 90       	ld	r0, Z+
   16ed2:	f0 81       	ld	r31, Z
   16ed4:	e0 2d       	mov	r30, r0
   16ed6:	83 8d       	ldd	r24, Z+27	; 0x1b
   16ed8:	94 8d       	ldd	r25, Z+28	; 0x1c
   16eda:	24 96       	adiw	r28, 0x04	; 4
   16edc:	0f b6       	in	r0, 0x3f	; 63
   16ede:	f8 94       	cli
   16ee0:	de bf       	out	0x3e, r29	; 62
   16ee2:	0f be       	out	0x3f, r0	; 63
   16ee4:	cd bf       	out	0x3d, r28	; 61
   16ee6:	df 91       	pop	r29
   16ee8:	cf 91       	pop	r28
   16eea:	08 95       	ret

00016eec <get_temp>:
  
}


int get_temp()
{
   16eec:	cf 93       	push	r28
   16eee:	df 93       	push	r29
   16ef0:	cd b7       	in	r28, 0x3d	; 61
   16ef2:	de b7       	in	r29, 0x3e	; 62
   16ef4:	24 97       	sbiw	r28, 0x04	; 4
   16ef6:	0f b6       	in	r0, 0x3f	; 63
   16ef8:	f8 94       	cli
   16efa:	de bf       	out	0x3e, r29	; 62
   16efc:	0f be       	out	0x3f, r0	; 63
   16efe:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADC_READ_TEMP;
   16f00:	84 e4       	ldi	r24, 0x44	; 68
   16f02:	9a ee       	ldi	r25, 0xEA	; 234
   16f04:	9a 83       	std	Y+2, r25	; 0x02
   16f06:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   16f08:	0e 94 74 c5 	call	0x18ae8
   16f0c:	9c 83       	std	Y+4, r25	; 0x04
   16f0e:	8b 83       	std	Y+3, r24	; 0x03
   fp(); 
   16f10:	e9 81       	ldd	r30, Y+1	; 0x01
   16f12:	fa 81       	ldd	r31, Y+2	; 0x02
   16f14:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   16f16:	eb 81       	ldd	r30, Y+3	; 0x03
   16f18:	fc 81       	ldd	r31, Y+4	; 0x04
   16f1a:	01 90       	ld	r0, Z+
   16f1c:	f0 81       	ld	r31, Z
   16f1e:	e0 2d       	mov	r30, r0
   16f20:	83 8d       	ldd	r24, Z+27	; 0x1b
   16f22:	94 8d       	ldd	r25, Z+28	; 0x1c
   16f24:	24 96       	adiw	r28, 0x04	; 4
   16f26:	0f b6       	in	r0, 0x3f	; 63
   16f28:	f8 94       	cli
   16f2a:	de bf       	out	0x3e, r29	; 62
   16f2c:	0f be       	out	0x3f, r0	; 63
   16f2e:	cd bf       	out	0x3d, r28	; 61
   16f30:	df 91       	pop	r29
   16f32:	cf 91       	pop	r28
   16f34:	08 95       	ret

00016f36 <get_magx>:

}


int get_magx()
{
   16f36:	cf 93       	push	r28
   16f38:	df 93       	push	r29
   16f3a:	cd b7       	in	r28, 0x3d	; 61
   16f3c:	de b7       	in	r29, 0x3e	; 62
   16f3e:	25 97       	sbiw	r28, 0x05	; 5
   16f40:	0f b6       	in	r0, 0x3f	; 63
   16f42:	f8 94       	cli
   16f44:	de bf       	out	0x3e, r29	; 62
   16f46:	0f be       	out	0x3f, r0	; 63
   16f48:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   
   {_atomic_t test = _atomic_start();
   16f4a:	0e 94 d6 c4 	call	0x189ac
   16f4e:	8b 83       	std	Y+3, r24	; 0x03
   
   void (*fp)() = (void (*)(void))ADC_READ_MAGX;
   16f50:	88 e4       	ldi	r24, 0x48	; 72
   16f52:	9a ee       	ldi	r25, 0xEA	; 234
   16f54:	9a 83       	std	Y+2, r25	; 0x02
   16f56:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   16f58:	0e 94 74 c5 	call	0x18ae8
   16f5c:	9d 83       	std	Y+5, r25	; 0x05
   16f5e:	8c 83       	std	Y+4, r24	; 0x04
   fp(); 
   16f60:	e9 81       	ldd	r30, Y+1	; 0x01
   16f62:	fa 81       	ldd	r31, Y+2	; 0x02
   16f64:	09 95       	icall
   
   _atomic_end(test);
   16f66:	8b 81       	ldd	r24, Y+3	; 0x03
   16f68:	0e 94 f0 c4 	call	0x189e0
  }
   return (*current_thread)->data.adcstate.adcreading;  
   16f6c:	ec 81       	ldd	r30, Y+4	; 0x04
   16f6e:	fd 81       	ldd	r31, Y+5	; 0x05
   16f70:	01 90       	ld	r0, Z+
   16f72:	f0 81       	ld	r31, Z
   16f74:	e0 2d       	mov	r30, r0
   16f76:	83 8d       	ldd	r24, Z+27	; 0x1b
   16f78:	94 8d       	ldd	r25, Z+28	; 0x1c
   16f7a:	25 96       	adiw	r28, 0x05	; 5
   16f7c:	0f b6       	in	r0, 0x3f	; 63
   16f7e:	f8 94       	cli
   16f80:	de bf       	out	0x3e, r29	; 62
   16f82:	0f be       	out	0x3f, r0	; 63
   16f84:	cd bf       	out	0x3d, r28	; 61
   16f86:	df 91       	pop	r29
   16f88:	cf 91       	pop	r28
   16f8a:	08 95       	ret

00016f8c <get_magy>:

}


int get_magy()
{
   16f8c:	cf 93       	push	r28
   16f8e:	df 93       	push	r29
   16f90:	cd b7       	in	r28, 0x3d	; 61
   16f92:	de b7       	in	r29, 0x3e	; 62
   16f94:	25 97       	sbiw	r28, 0x05	; 5
   16f96:	0f b6       	in	r0, 0x3f	; 63
   16f98:	f8 94       	cli
   16f9a:	de bf       	out	0x3e, r29	; 62
   16f9c:	0f be       	out	0x3f, r0	; 63
   16f9e:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
  {_atomic_t test = _atomic_start();
   16fa0:	0e 94 d6 c4 	call	0x189ac
   16fa4:	8b 83       	std	Y+3, r24	; 0x03
   void (*fp)() = (void (*)(void))ADC_READ_MAGY;
   16fa6:	8c e4       	ldi	r24, 0x4C	; 76
   16fa8:	9a ee       	ldi	r25, 0xEA	; 234
   16faa:	9a 83       	std	Y+2, r25	; 0x02
   16fac:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   16fae:	0e 94 74 c5 	call	0x18ae8
   16fb2:	9d 83       	std	Y+5, r25	; 0x05
   16fb4:	8c 83       	std	Y+4, r24	; 0x04
   fp(); 
   16fb6:	e9 81       	ldd	r30, Y+1	; 0x01
   16fb8:	fa 81       	ldd	r31, Y+2	; 0x02
   16fba:	09 95       	icall
   
      
   _atomic_end(test);
   16fbc:	8b 81       	ldd	r24, Y+3	; 0x03
   16fbe:	0e 94 f0 c4 	call	0x189e0
  }
   return (*current_thread)->data.adcstate.adcreading;  
   16fc2:	ec 81       	ldd	r30, Y+4	; 0x04
   16fc4:	fd 81       	ldd	r31, Y+5	; 0x05
   16fc6:	01 90       	ld	r0, Z+
   16fc8:	f0 81       	ld	r31, Z
   16fca:	e0 2d       	mov	r30, r0
   16fcc:	83 8d       	ldd	r24, Z+27	; 0x1b
   16fce:	94 8d       	ldd	r25, Z+28	; 0x1c
   16fd0:	25 96       	adiw	r28, 0x05	; 5
   16fd2:	0f b6       	in	r0, 0x3f	; 63
   16fd4:	f8 94       	cli
   16fd6:	de bf       	out	0x3e, r29	; 62
   16fd8:	0f be       	out	0x3f, r0	; 63
   16fda:	cd bf       	out	0x3d, r28	; 61
   16fdc:	df 91       	pop	r29
   16fde:	cf 91       	pop	r28
   16fe0:	08 95       	ret

00016fe2 <get_accx>:
}


int get_accx()
{
   16fe2:	cf 93       	push	r28
   16fe4:	df 93       	push	r29
   16fe6:	cd b7       	in	r28, 0x3d	; 61
   16fe8:	de b7       	in	r29, 0x3e	; 62
   16fea:	24 97       	sbiw	r28, 0x04	; 4
   16fec:	0f b6       	in	r0, 0x3f	; 63
   16fee:	f8 94       	cli
   16ff0:	de bf       	out	0x3e, r29	; 62
   16ff2:	0f be       	out	0x3f, r0	; 63
   16ff4:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADC_READ_ACCX;
   16ff6:	80 e5       	ldi	r24, 0x50	; 80
   16ff8:	9a ee       	ldi	r25, 0xEA	; 234
   16ffa:	9a 83       	std	Y+2, r25	; 0x02
   16ffc:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   16ffe:	0e 94 74 c5 	call	0x18ae8
   17002:	9c 83       	std	Y+4, r25	; 0x04
   17004:	8b 83       	std	Y+3, r24	; 0x03
   fp(); 
   17006:	e9 81       	ldd	r30, Y+1	; 0x01
   17008:	fa 81       	ldd	r31, Y+2	; 0x02
   1700a:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   1700c:	eb 81       	ldd	r30, Y+3	; 0x03
   1700e:	fc 81       	ldd	r31, Y+4	; 0x04
   17010:	01 90       	ld	r0, Z+
   17012:	f0 81       	ld	r31, Z
   17014:	e0 2d       	mov	r30, r0
   17016:	83 8d       	ldd	r24, Z+27	; 0x1b
   17018:	94 8d       	ldd	r25, Z+28	; 0x1c
   1701a:	24 96       	adiw	r28, 0x04	; 4
   1701c:	0f b6       	in	r0, 0x3f	; 63
   1701e:	f8 94       	cli
   17020:	de bf       	out	0x3e, r29	; 62
   17022:	0f be       	out	0x3f, r0	; 63
   17024:	cd bf       	out	0x3d, r28	; 61
   17026:	df 91       	pop	r29
   17028:	cf 91       	pop	r28
   1702a:	08 95       	ret

0001702c <get_accy>:
}


int get_accy()
{
   1702c:	cf 93       	push	r28
   1702e:	df 93       	push	r29
   17030:	cd b7       	in	r28, 0x3d	; 61
   17032:	de b7       	in	r29, 0x3e	; 62
   17034:	24 97       	sbiw	r28, 0x04	; 4
   17036:	0f b6       	in	r0, 0x3f	; 63
   17038:	f8 94       	cli
   1703a:	de bf       	out	0x3e, r29	; 62
   1703c:	0f be       	out	0x3f, r0	; 63
   1703e:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADC_READ_ACCY;
   17040:	84 e5       	ldi	r24, 0x54	; 84
   17042:	9a ee       	ldi	r25, 0xEA	; 234
   17044:	9a 83       	std	Y+2, r25	; 0x02
   17046:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   17048:	0e 94 74 c5 	call	0x18ae8
   1704c:	9c 83       	std	Y+4, r25	; 0x04
   1704e:	8b 83       	std	Y+3, r24	; 0x03
   fp(); 
   17050:	e9 81       	ldd	r30, Y+1	; 0x01
   17052:	fa 81       	ldd	r31, Y+2	; 0x02
   17054:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   17056:	eb 81       	ldd	r30, Y+3	; 0x03
   17058:	fc 81       	ldd	r31, Y+4	; 0x04
   1705a:	01 90       	ld	r0, Z+
   1705c:	f0 81       	ld	r31, Z
   1705e:	e0 2d       	mov	r30, r0
   17060:	83 8d       	ldd	r24, Z+27	; 0x1b
   17062:	94 8d       	ldd	r25, Z+28	; 0x1c
   17064:	24 96       	adiw	r28, 0x04	; 4
   17066:	0f b6       	in	r0, 0x3f	; 63
   17068:	f8 94       	cli
   1706a:	de bf       	out	0x3e, r29	; 62
   1706c:	0f be       	out	0x3f, r0	; 63
   1706e:	cd bf       	out	0x3d, r28	; 61
   17070:	df 91       	pop	r29
   17072:	cf 91       	pop	r28
   17074:	08 95       	ret

00017076 <getCurrentEEPROMInfo>:



genericByteStorageTaskNode *getCurrentEEPROMInfo()
{
   17076:	cf 93       	push	r28
   17078:	df 93       	push	r29
   1707a:	cd b7       	in	r28, 0x3d	; 61
   1707c:	de b7       	in	r29, 0x3e	; 62
   1707e:	24 97       	sbiw	r28, 0x04	; 4
   17080:	0f b6       	in	r0, 0x3f	; 63
   17082:	f8 94       	cli
   17084:	de bf       	out	0x3e, r29	; 62
   17086:	0f be       	out	0x3f, r0	; 63
   17088:	cd bf       	out	0x3d, r28	; 61
   genericByteStorageTaskNode *currenteeprominfoaddr;

   void (*getaddrfp)(void) = (void (*)(void))GET_EEPROM_STRUCTURE_HANDLE;
   1708a:	84 ea       	ldi	r24, 0xA4	; 164
   1708c:	9a ee       	ldi	r25, 0xEA	; 234
   1708e:	9a 83       	std	Y+2, r25	; 0x02
   17090:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   17092:	4f 93       	push	r20
   17094:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   17096:	e9 81       	ldd	r30, Y+1	; 0x01
   17098:	fa 81       	ldd	r31, Y+2	; 0x02
   1709a:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   1709c:	84 2f       	mov	r24, r20
   1709e:	95 2f       	mov	r25, r21
   170a0:	9c 83       	std	Y+4, r25	; 0x04
   170a2:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currenteeprominfoaddr)
				 :
                );
    asm volatile("pop r21" "\n\t"
   170a4:	5f 91       	pop	r21
   170a6:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currenteeprominfoaddr;
   170a8:	8b 81       	ldd	r24, Y+3	; 0x03
   170aa:	9c 81       	ldd	r25, Y+4	; 0x04
   170ac:	24 96       	adiw	r28, 0x04	; 4
   170ae:	0f b6       	in	r0, 0x3f	; 63
   170b0:	f8 94       	cli
   170b2:	de bf       	out	0x3e, r29	; 62
   170b4:	0f be       	out	0x3f, r0	; 63
   170b6:	cd bf       	out	0x3d, r28	; 61
   170b8:	df 91       	pop	r29
   170ba:	cf 91       	pop	r28
   170bc:	08 95       	ret

000170be <readFromEEPROM>:
}




//Turn off the interrupt, access the location, and use system call to implement poll based imlementation provided by avr libc

void readFromEEPROM(uint16_t addr, uint16_t nBytes, uint8_t *buffer)
{
   170be:	cf 93       	push	r28
   170c0:	df 93       	push	r29
   170c2:	cd b7       	in	r28, 0x3d	; 61
   170c4:	de b7       	in	r29, 0x3e	; 62
   170c6:	2b 97       	sbiw	r28, 0x0b	; 11
   170c8:	0f b6       	in	r0, 0x3f	; 63
   170ca:	f8 94       	cli
   170cc:	de bf       	out	0x3e, r29	; 62
   170ce:	0f be       	out	0x3f, r0	; 63
   170d0:	cd bf       	out	0x3d, r28	; 61
   170d2:	9f 83       	std	Y+7, r25	; 0x07
   170d4:	8e 83       	std	Y+6, r24	; 0x06
   170d6:	79 87       	std	Y+9, r23	; 0x09
   170d8:	68 87       	std	Y+8, r22	; 0x08
   170da:	5b 87       	std	Y+11, r21	; 0x0b
   170dc:	4a 87       	std	Y+10, r20	; 0x0a


	_atomic_t currentatomic;

	currentatomic = _atomic_start();
   170de:	0e 94 d6 c4 	call	0x189ac
   170e2:	8d 83       	std	Y+5, r24	; 0x05


    genericByteStorageTaskNode *eeprominfoaddr;
    eeprominfoaddr = getCurrentEEPROMInfo();
   170e4:	0e 94 3b b8 	call	0x17076
   170e8:	9c 83       	std	Y+4, r25	; 0x04
   170ea:	8b 83       	std	Y+3, r24	; 0x03

	void (*getaddrfp)(void) = (void (*)(void))READ_EEPROM_TASK;
   170ec:	88 ea       	ldi	r24, 0xA8	; 168
   170ee:	9a ee       	ldi	r25, 0xEA	; 234
   170f0:	9a 83       	std	Y+2, r25	; 0x02
   170f2:	89 83       	std	Y+1, r24	; 0x01

    eeprominfoaddr-> addr = addr;
   170f4:	eb 81       	ldd	r30, Y+3	; 0x03
   170f6:	fc 81       	ldd	r31, Y+4	; 0x04
   170f8:	8e 81       	ldd	r24, Y+6	; 0x06
   170fa:	9f 81       	ldd	r25, Y+7	; 0x07
   170fc:	91 83       	std	Z+1, r25	; 0x01
   170fe:	80 83       	st	Z, r24
   	eeprominfoaddr-> nBytes = nBytes;
   17100:	eb 81       	ldd	r30, Y+3	; 0x03
   17102:	fc 81       	ldd	r31, Y+4	; 0x04
   17104:	88 85       	ldd	r24, Y+8	; 0x08
   17106:	99 85       	ldd	r25, Y+9	; 0x09
   17108:	93 83       	std	Z+3, r25	; 0x03
   1710a:	82 83       	std	Z+2, r24	; 0x02
   	eeprominfoaddr-> buffer = buffer;
   1710c:	eb 81       	ldd	r30, Y+3	; 0x03
   1710e:	fc 81       	ldd	r31, Y+4	; 0x04
   17110:	8a 85       	ldd	r24, Y+10	; 0x0a
   17112:	9b 85       	ldd	r25, Y+11	; 0x0b
   17114:	95 83       	std	Z+5, r25	; 0x05
   17116:	84 83       	std	Z+4, r24	; 0x04


    getaddrfp();
   17118:	e9 81       	ldd	r30, Y+1	; 0x01
   1711a:	fa 81       	ldd	r31, Y+2	; 0x02
   1711c:	09 95       	icall

	_atomic_end(currentatomic);
   1711e:	8d 81       	ldd	r24, Y+5	; 0x05
   17120:	0e 94 f0 c4 	call	0x189e0
   17124:	2b 96       	adiw	r28, 0x0b	; 11
   17126:	0f b6       	in	r0, 0x3f	; 63
   17128:	f8 94       	cli
   1712a:	de bf       	out	0x3e, r29	; 62
   1712c:	0f be       	out	0x3f, r0	; 63
   1712e:	cd bf       	out	0x3d, r28	; 61
   17130:	df 91       	pop	r29
   17132:	cf 91       	pop	r28
   17134:	08 95       	ret

00017136 <writeToEEPROM>:
}




//Turn off the interrupt, access the location, and use system call to implement poll based implementation provided by avr libc

void writeToEEPROM(uint16_t addr, uint16_t nBytes, uint8_t *buffer)
{
   17136:	cf 93       	push	r28
   17138:	df 93       	push	r29
   1713a:	cd b7       	in	r28, 0x3d	; 61
   1713c:	de b7       	in	r29, 0x3e	; 62
   1713e:	2b 97       	sbiw	r28, 0x0b	; 11
   17140:	0f b6       	in	r0, 0x3f	; 63
   17142:	f8 94       	cli
   17144:	de bf       	out	0x3e, r29	; 62
   17146:	0f be       	out	0x3f, r0	; 63
   17148:	cd bf       	out	0x3d, r28	; 61
   1714a:	9f 83       	std	Y+7, r25	; 0x07
   1714c:	8e 83       	std	Y+6, r24	; 0x06
   1714e:	79 87       	std	Y+9, r23	; 0x09
   17150:	68 87       	std	Y+8, r22	; 0x08
   17152:	5b 87       	std	Y+11, r21	; 0x0b
   17154:	4a 87       	std	Y+10, r20	; 0x0a

	_atomic_t currentatomic;

	currentatomic = _atomic_start();
   17156:	0e 94 d6 c4 	call	0x189ac
   1715a:	8d 83       	std	Y+5, r24	; 0x05

    genericByteStorageTaskNode *eeprominfoaddr;
    eeprominfoaddr = getCurrentEEPROMInfo();
   1715c:	0e 94 3b b8 	call	0x17076
   17160:	9c 83       	std	Y+4, r25	; 0x04
   17162:	8b 83       	std	Y+3, r24	; 0x03

	void (*getaddrfp)(void) = (void (*)(void))WRITE_EEPROM_TASK;
   17164:	8c ea       	ldi	r24, 0xAC	; 172
   17166:	9a ee       	ldi	r25, 0xEA	; 234
   17168:	9a 83       	std	Y+2, r25	; 0x02
   1716a:	89 83       	std	Y+1, r24	; 0x01

    eeprominfoaddr-> addr = addr;
   1716c:	eb 81       	ldd	r30, Y+3	; 0x03
   1716e:	fc 81       	ldd	r31, Y+4	; 0x04
   17170:	8e 81       	ldd	r24, Y+6	; 0x06
   17172:	9f 81       	ldd	r25, Y+7	; 0x07
   17174:	91 83       	std	Z+1, r25	; 0x01
   17176:	80 83       	st	Z, r24
	  eeprominfoaddr-> nBytes = nBytes;
   17178:	eb 81       	ldd	r30, Y+3	; 0x03
   1717a:	fc 81       	ldd	r31, Y+4	; 0x04
   1717c:	88 85       	ldd	r24, Y+8	; 0x08
   1717e:	99 85       	ldd	r25, Y+9	; 0x09
   17180:	93 83       	std	Z+3, r25	; 0x03
   17182:	82 83       	std	Z+2, r24	; 0x02
	  eeprominfoaddr-> buffer = buffer;
   17184:	eb 81       	ldd	r30, Y+3	; 0x03
   17186:	fc 81       	ldd	r31, Y+4	; 0x04
   17188:	8a 85       	ldd	r24, Y+10	; 0x0a
   1718a:	9b 85       	ldd	r25, Y+11	; 0x0b
   1718c:	95 83       	std	Z+5, r25	; 0x05
   1718e:	84 83       	std	Z+4, r24	; 0x04


    getaddrfp();
   17190:	e9 81       	ldd	r30, Y+1	; 0x01
   17192:	fa 81       	ldd	r31, Y+2	; 0x02
   17194:	09 95       	icall

	_atomic_end(currentatomic);
   17196:	8d 81       	ldd	r24, Y+5	; 0x05
   17198:	0e 94 f0 c4 	call	0x189e0
   1719c:	2b 96       	adiw	r28, 0x0b	; 11
   1719e:	0f b6       	in	r0, 0x3f	; 63
   171a0:	f8 94       	cli
   171a2:	de bf       	out	0x3e, r29	; 62
   171a4:	0f be       	out	0x3f, r0	; 63
   171a6:	cd bf       	out	0x3d, r28	; 61
   171a8:	df 91       	pop	r29
   171aa:	cf 91       	pop	r28
   171ac:	08 95       	ret

000171ae <getEventBlockAddress>:
volatile uint16_t globalpageoffset;
volatile uint8_t *globalbuffer;

void *getEventBlockAddress()
{
   171ae:	cf 93       	push	r28
   171b0:	df 93       	push	r29
   171b2:	cd b7       	in	r28, 0x3d	; 61
   171b4:	de b7       	in	r29, 0x3e	; 62
   171b6:	24 97       	sbiw	r28, 0x04	; 4
   171b8:	0f b6       	in	r0, 0x3f	; 63
   171ba:	f8 94       	cli
   171bc:	de bf       	out	0x3e, r29	; 62
   171be:	0f be       	out	0x3f, r0	; 63
   171c0:	cd bf       	out	0x3d, r28	; 61
   
   void *retaddr; 
   void (*getaddrfp)(void) = (void (*)(void))GET_LOGGER_BLOCK_ADDRESS;
   171c2:	80 ee       	ldi	r24, 0xE0	; 224
   171c4:	9a ee       	ldi	r25, 0xEA	; 234
   171c6:	9a 83       	std	Y+2, r25	; 0x02
   171c8:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   171ca:	4f 93       	push	r20
   171cc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   171ce:	e9 81       	ldd	r30, Y+1	; 0x01
   171d0:	fa 81       	ldd	r31, Y+2	; 0x02
   171d2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   171d4:	84 2f       	mov	r24, r20
   171d6:	95 2f       	mov	r25, r21
   171d8:	9c 83       	std	Y+4, r25	; 0x04
   171da:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (retaddr)
				 :);
    asm volatile("pop r21" "\n\t"
   171dc:	5f 91       	pop	r21
   171de:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return retaddr;
   171e0:	8b 81       	ldd	r24, Y+3	; 0x03
   171e2:	9c 81       	ldd	r25, Y+4	; 0x04
   171e4:	24 96       	adiw	r28, 0x04	; 4
   171e6:	0f b6       	in	r0, 0x3f	; 63
   171e8:	f8 94       	cli
   171ea:	de bf       	out	0x3e, r29	; 62
   171ec:	0f be       	out	0x3f, r0	; 63
   171ee:	cd bf       	out	0x3d, r28	; 61
   171f0:	df 91       	pop	r29
   171f2:	cf 91       	pop	r28
   171f4:	08 95       	ret

000171f6 <enableTracing>:
}



void enableTracing()
{    
   171f6:	cf 93       	push	r28
   171f8:	df 93       	push	r29
   171fa:	cd b7       	in	r28, 0x3d	; 61
   171fc:	de b7       	in	r29, 0x3e	; 62
   171fe:	22 97       	sbiw	r28, 0x02	; 2
   17200:	0f b6       	in	r0, 0x3f	; 63
   17202:	f8 94       	cli
   17204:	de bf       	out	0x3e, r29	; 62
   17206:	0f be       	out	0x3f, r0	; 63
   17208:	cd bf       	out	0x3d, r28	; 61
   void (*getaddrfp)(void) = (void (*)(void))ENABLE_TRACING_SYSCALL;
   1720a:	84 ee       	ldi	r24, 0xE4	; 228
   1720c:	9a ee       	ldi	r25, 0xEA	; 234
   1720e:	9a 83       	std	Y+2, r25	; 0x02
   17210:	89 83       	std	Y+1, r24	; 0x01
   getaddrfp();
   17212:	e9 81       	ldd	r30, Y+1	; 0x01
   17214:	fa 81       	ldd	r31, Y+2	; 0x02
   17216:	09 95       	icall
   17218:	22 96       	adiw	r28, 0x02	; 2
   1721a:	0f b6       	in	r0, 0x3f	; 63
   1721c:	f8 94       	cli
   1721e:	de bf       	out	0x3e, r29	; 62
   17220:	0f be       	out	0x3f, r0	; 63
   17222:	cd bf       	out	0x3d, r28	; 61
   17224:	df 91       	pop	r29
   17226:	cf 91       	pop	r28
   17228:	08 95       	ret

0001722a <disableTracing>:
   return;
}



void disableTracing()
{     
   1722a:	cf 93       	push	r28
   1722c:	df 93       	push	r29
   1722e:	cd b7       	in	r28, 0x3d	; 61
   17230:	de b7       	in	r29, 0x3e	; 62
   17232:	22 97       	sbiw	r28, 0x02	; 2
   17234:	0f b6       	in	r0, 0x3f	; 63
   17236:	f8 94       	cli
   17238:	de bf       	out	0x3e, r29	; 62
   1723a:	0f be       	out	0x3f, r0	; 63
   1723c:	cd bf       	out	0x3d, r28	; 61
   void (*getaddrfp)(void) = (void (*)(void))DISABLE_TRACING_SYSCALL;
   1723e:	88 ee       	ldi	r24, 0xE8	; 232
   17240:	9a ee       	ldi	r25, 0xEA	; 234
   17242:	9a 83       	std	Y+2, r25	; 0x02
   17244:	89 83       	std	Y+1, r24	; 0x01
   getaddrfp();
   17246:	e9 81       	ldd	r30, Y+1	; 0x01
   17248:	fa 81       	ldd	r31, Y+2	; 0x02
   1724a:	09 95       	icall
   1724c:	22 96       	adiw	r28, 0x02	; 2
   1724e:	0f b6       	in	r0, 0x3f	; 63
   17250:	f8 94       	cli
   17252:	de bf       	out	0x3e, r29	; 62
   17254:	0f be       	out	0x3f, r0	; 63
   17256:	cd bf       	out	0x3d, r28	; 61
   17258:	df 91       	pop	r29
   1725a:	cf 91       	pop	r28
   1725c:	08 95       	ret

0001725e <addUserTracePoint>:
   return;
}





void addUserTracePoint(uint16_t pagenum, uint16_t pageoffset)
{
   1725e:	cf 93       	push	r28
   17260:	df 93       	push	r29
   17262:	cd b7       	in	r28, 0x3d	; 61
   17264:	de b7       	in	r29, 0x3e	; 62
   17266:	26 97       	sbiw	r28, 0x06	; 6
   17268:	0f b6       	in	r0, 0x3f	; 63
   1726a:	f8 94       	cli
   1726c:	de bf       	out	0x3e, r29	; 62
   1726e:	0f be       	out	0x3f, r0	; 63
   17270:	cd bf       	out	0x3d, r28	; 61
   17272:	9c 83       	std	Y+4, r25	; 0x04
   17274:	8b 83       	std	Y+3, r24	; 0x03
   17276:	7e 83       	std	Y+6, r23	; 0x06
   17278:	6d 83       	std	Y+5, r22	; 0x05
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_ADD_TRACE_POINT; 
   1727a:	88 ef       	ldi	r24, 0xF8	; 248
   1727c:	9a ee       	ldi	r25, 0xEA	; 234
   1727e:	9a 83       	std	Y+2, r25	; 0x02
   17280:	89 83       	std	Y+1, r24	; 0x01
   globalpagenum = pagenum;
   17282:	8b 81       	ldd	r24, Y+3	; 0x03
   17284:	9c 81       	ldd	r25, Y+4	; 0x04
   17286:	90 93 7f 0a 	sts	0x0A7F, r25
   1728a:	80 93 7e 0a 	sts	0x0A7E, r24
   globalpageoffset = pageoffset; 
   1728e:	8d 81       	ldd	r24, Y+5	; 0x05
   17290:	9e 81       	ldd	r25, Y+6	; 0x06
   17292:	90 93 7d 0a 	sts	0x0A7D, r25
   17296:	80 93 7c 0a 	sts	0x0A7C, r24
   
   asm volatile("push r20" "\n\t"
   1729a:	4f 93       	push	r20
   1729c:	5f 93       	push	r21
   1729e:	6f 93       	push	r22
   172a0:	7f 93       	push	r23
                "push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   172a2:	80 91 7e 0a 	lds	r24, 0x0A7E
   172a6:	90 91 7f 0a 	lds	r25, 0x0A7F
   172aa:	48 2f       	mov	r20, r24
   172ac:	59 2f       	mov	r21, r25
	             	" mov r21, %B0" "\n\t"
				 :
				 :"r" (globalpagenum)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   172ae:	80 91 7c 0a 	lds	r24, 0x0A7C
   172b2:	90 91 7d 0a 	lds	r25, 0x0A7D
   172b6:	68 2f       	mov	r22, r24
   172b8:	79 2f       	mov	r23, r25
	             	" mov r23, %B0" "\n\t"
				 :
				 :"r" (globalpageoffset)
                );

  fp(); 
   172ba:	e9 81       	ldd	r30, Y+1	; 0x01
   172bc:	fa 81       	ldd	r31, Y+2	; 0x02
   172be:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   172c0:	7f 91       	pop	r23
   172c2:	6f 91       	pop	r22
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   172c4:	5f 91       	pop	r21
   172c6:	4f 91       	pop	r20
   172c8:	26 96       	adiw	r28, 0x06	; 6
   172ca:	0f b6       	in	r0, 0x3f	; 63
   172cc:	f8 94       	cli
   172ce:	de bf       	out	0x3e, r29	; 62
   172d0:	0f be       	out	0x3f, r0	; 63
   172d2:	cd bf       	out	0x3d, r28	; 61
   172d4:	df 91       	pop	r29
   172d6:	cf 91       	pop	r28
   172d8:	08 95       	ret

000172da <addUserTracePoint_longinstruction>:
	           "pop r20" "\n\t"
	              ::);
  return; 


}



void addUserTracePoint_longinstruction(uint16_t pagenum, uint16_t pageoffset)
{
   172da:	cf 93       	push	r28
   172dc:	df 93       	push	r29
   172de:	cd b7       	in	r28, 0x3d	; 61
   172e0:	de b7       	in	r29, 0x3e	; 62
   172e2:	26 97       	sbiw	r28, 0x06	; 6
   172e4:	0f b6       	in	r0, 0x3f	; 63
   172e6:	f8 94       	cli
   172e8:	de bf       	out	0x3e, r29	; 62
   172ea:	0f be       	out	0x3f, r0	; 63
   172ec:	cd bf       	out	0x3d, r28	; 61
   172ee:	9c 83       	std	Y+4, r25	; 0x04
   172f0:	8b 83       	std	Y+3, r24	; 0x03
   172f2:	7e 83       	std	Y+6, r23	; 0x06
   172f4:	6d 83       	std	Y+5, r22	; 0x05

	 
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_ADD_TRACE_POINT_LONG; 
   172f6:	8c ef       	ldi	r24, 0xFC	; 252
   172f8:	9a ee       	ldi	r25, 0xEA	; 234
   172fa:	9a 83       	std	Y+2, r25	; 0x02
   172fc:	89 83       	std	Y+1, r24	; 0x01
   	 globalpagenum = pagenum;
   172fe:	8b 81       	ldd	r24, Y+3	; 0x03
   17300:	9c 81       	ldd	r25, Y+4	; 0x04
   17302:	90 93 7f 0a 	sts	0x0A7F, r25
   17306:	80 93 7e 0a 	sts	0x0A7E, r24
	 globalpageoffset = pageoffset; 
   1730a:	8d 81       	ldd	r24, Y+5	; 0x05
   1730c:	9e 81       	ldd	r25, Y+6	; 0x06
   1730e:	90 93 7d 0a 	sts	0x0A7D, r25
   17312:	80 93 7c 0a 	sts	0x0A7C, r24
   asm volatile("push r20" "\n\t"
   17316:	4f 93       	push	r20
   17318:	5f 93       	push	r21
   1731a:	6f 93       	push	r22
   1731c:	7f 93       	push	r23
                "push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   1731e:	80 91 7e 0a 	lds	r24, 0x0A7E
   17322:	90 91 7f 0a 	lds	r25, 0x0A7F
   17326:	48 2f       	mov	r20, r24
   17328:	59 2f       	mov	r21, r25
	             	" mov r21, %B0" "\n\t"
				 :
				 :"r" (globalpagenum)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   1732a:	80 91 7c 0a 	lds	r24, 0x0A7C
   1732e:	90 91 7d 0a 	lds	r25, 0x0A7D
   17332:	68 2f       	mov	r22, r24
   17334:	79 2f       	mov	r23, r25
	             	" mov r23, %B0" "\n\t"
				 :
				 :"r" (globalpageoffset)
                );

  fp(); 
   17336:	e9 81       	ldd	r30, Y+1	; 0x01
   17338:	fa 81       	ldd	r31, Y+2	; 0x02
   1733a:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   1733c:	7f 91       	pop	r23
   1733e:	6f 91       	pop	r22
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   17340:	5f 91       	pop	r21
   17342:	4f 91       	pop	r20
   17344:	26 96       	adiw	r28, 0x06	; 6
   17346:	0f b6       	in	r0, 0x3f	; 63
   17348:	f8 94       	cli
   1734a:	de bf       	out	0x3e, r29	; 62
   1734c:	0f be       	out	0x3f, r0	; 63
   1734e:	cd bf       	out	0x3d, r28	; 61
   17350:	df 91       	pop	r29
   17352:	cf 91       	pop	r28
   17354:	08 95       	ret

00017356 <removeUserTracePoint>:
	           "pop r20" "\n\t"
	              ::);
  return; 


}



void removeUserTracePoint(uint16_t pagenum, uint16_t pageoffset, uint8_t *buffer)
{
   17356:	cf 93       	push	r28
   17358:	df 93       	push	r29
   1735a:	cd b7       	in	r28, 0x3d	; 61
   1735c:	de b7       	in	r29, 0x3e	; 62
   1735e:	28 97       	sbiw	r28, 0x08	; 8
   17360:	0f b6       	in	r0, 0x3f	; 63
   17362:	f8 94       	cli
   17364:	de bf       	out	0x3e, r29	; 62
   17366:	0f be       	out	0x3f, r0	; 63
   17368:	cd bf       	out	0x3d, r28	; 61
   1736a:	9c 83       	std	Y+4, r25	; 0x04
   1736c:	8b 83       	std	Y+3, r24	; 0x03
   1736e:	7e 83       	std	Y+6, r23	; 0x06
   17370:	6d 83       	std	Y+5, r22	; 0x05
   17372:	58 87       	std	Y+8, r21	; 0x08
   17374:	4f 83       	std	Y+7, r20	; 0x07
	
	  
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_REMOVE_TRACE_POINT; 
   17376:	8c e0       	ldi	r24, 0x0C	; 12
   17378:	9b ee       	ldi	r25, 0xEB	; 235
   1737a:	9a 83       	std	Y+2, r25	; 0x02
   1737c:	89 83       	std	Y+1, r24	; 0x01
   globalpagenum = pagenum;
   1737e:	8b 81       	ldd	r24, Y+3	; 0x03
   17380:	9c 81       	ldd	r25, Y+4	; 0x04
   17382:	90 93 7f 0a 	sts	0x0A7F, r25
   17386:	80 93 7e 0a 	sts	0x0A7E, r24
   globalpageoffset = pageoffset; 
   1738a:	8d 81       	ldd	r24, Y+5	; 0x05
   1738c:	9e 81       	ldd	r25, Y+6	; 0x06
   1738e:	90 93 7d 0a 	sts	0x0A7D, r25
   17392:	80 93 7c 0a 	sts	0x0A7C, r24
   globalbuffer = buffer; 
   17396:	8f 81       	ldd	r24, Y+7	; 0x07
   17398:	98 85       	ldd	r25, Y+8	; 0x08
   1739a:	90 93 7b 0a 	sts	0x0A7B, r25
   1739e:	80 93 7a 0a 	sts	0x0A7A, r24
   
   asm volatile(
   173a2:	2f 93       	push	r18
   173a4:	3f 93       	push	r19
   173a6:	4f 93       	push	r20
   173a8:	5f 93       	push	r21
   173aa:	6f 93       	push	r22
   173ac:	7f 93       	push	r23
   							"push r18" "\n\t"
   							"push r19" "\n\t"
   							"push r20" "\n\t"
                "push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"
                ::);
                	
                	
   
   asm volatile(" mov r20, %A0" "\n\t"
   173ae:	80 91 7e 0a 	lds	r24, 0x0A7E
   173b2:	90 91 7f 0a 	lds	r25, 0x0A7F
   173b6:	48 2f       	mov	r20, r24
   173b8:	59 2f       	mov	r21, r25
	             	" mov r21, %B0" "\n\t"
				 :
				 :"r" (globalpagenum)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   173ba:	80 91 7c 0a 	lds	r24, 0x0A7C
   173be:	90 91 7d 0a 	lds	r25, 0x0A7D
   173c2:	68 2f       	mov	r22, r24
   173c4:	79 2f       	mov	r23, r25
	             	" mov r23, %B0" "\n\t"
				 :
				 :"r" (globalpageoffset)
                );
                
   asm volatile(" mov r18, %A0" "\n\t"
   173c6:	80 91 7a 0a 	lds	r24, 0x0A7A
   173ca:	90 91 7b 0a 	lds	r25, 0x0A7B
   173ce:	28 2f       	mov	r18, r24
   173d0:	39 2f       	mov	r19, r25
	             	" mov r19, %B0" "\n\t"
				 :
				 :"r" (globalbuffer)
                );

  fp(); 
   173d2:	e9 81       	ldd	r30, Y+1	; 0x01
   173d4:	fa 81       	ldd	r31, Y+2	; 0x02
   173d6:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   173d8:	7f 91       	pop	r23
   173da:	6f 91       	pop	r22
	             "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   173dc:	5f 91       	pop	r21
   173de:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
	              	
  asm volatile("pop r19" "\n\t"
   173e0:	3f 91       	pop	r19
   173e2:	2f 91       	pop	r18
   173e4:	28 96       	adiw	r28, 0x08	; 8
   173e6:	0f b6       	in	r0, 0x3f	; 63
   173e8:	f8 94       	cli
   173ea:	de bf       	out	0x3e, r29	; 62
   173ec:	0f be       	out	0x3f, r0	; 63
   173ee:	cd bf       	out	0x3d, r28	; 61
   173f0:	df 91       	pop	r29
   173f2:	cf 91       	pop	r28
   173f4:	08 95       	ret

000173f6 <removeUserTracePoint_longinstruction>:
	             "pop r18" "\n\t"
	              ::);
  return; 


}



void removeUserTracePoint_longinstruction(uint16_t pagenum, uint16_t pageoffset, uint8_t *buffer)
{
   173f6:	cf 93       	push	r28
   173f8:	df 93       	push	r29
   173fa:	cd b7       	in	r28, 0x3d	; 61
   173fc:	de b7       	in	r29, 0x3e	; 62
   173fe:	28 97       	sbiw	r28, 0x08	; 8
   17400:	0f b6       	in	r0, 0x3f	; 63
   17402:	f8 94       	cli
   17404:	de bf       	out	0x3e, r29	; 62
   17406:	0f be       	out	0x3f, r0	; 63
   17408:	cd bf       	out	0x3d, r28	; 61
   1740a:	9c 83       	std	Y+4, r25	; 0x04
   1740c:	8b 83       	std	Y+3, r24	; 0x03
   1740e:	7e 83       	std	Y+6, r23	; 0x06
   17410:	6d 83       	std	Y+5, r22	; 0x05
   17412:	58 87       	std	Y+8, r21	; 0x08
   17414:	4f 83       	std	Y+7, r20	; 0x07
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_REMOVE_TRACE_POINT_LONG; 
   17416:	80 e1       	ldi	r24, 0x10	; 16
   17418:	9b ee       	ldi	r25, 0xEB	; 235
   1741a:	9a 83       	std	Y+2, r25	; 0x02
   1741c:	89 83       	std	Y+1, r24	; 0x01
   
   globalpagenum = pagenum;
   1741e:	8b 81       	ldd	r24, Y+3	; 0x03
   17420:	9c 81       	ldd	r25, Y+4	; 0x04
   17422:	90 93 7f 0a 	sts	0x0A7F, r25
   17426:	80 93 7e 0a 	sts	0x0A7E, r24
   globalpageoffset = pageoffset; 
   1742a:	8d 81       	ldd	r24, Y+5	; 0x05
   1742c:	9e 81       	ldd	r25, Y+6	; 0x06
   1742e:	90 93 7d 0a 	sts	0x0A7D, r25
   17432:	80 93 7c 0a 	sts	0x0A7C, r24
   globalbuffer = buffer; 
   17436:	8f 81       	ldd	r24, Y+7	; 0x07
   17438:	98 85       	ldd	r25, Y+8	; 0x08
   1743a:	90 93 7b 0a 	sts	0x0A7B, r25
   1743e:	80 93 7a 0a 	sts	0x0A7A, r24
   asm volatile("push r18" "\n\t"
   17442:	2f 93       	push	r18
   17444:	3f 93       	push	r19
   17446:	4f 93       	push	r20
   17448:	5f 93       	push	r21
   1744a:	6f 93       	push	r22
   1744c:	7f 93       	push	r23
   							"push r19" "\n\t"
   							"push r20" "\n\t"
                "push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   1744e:	80 91 7e 0a 	lds	r24, 0x0A7E
   17452:	90 91 7f 0a 	lds	r25, 0x0A7F
   17456:	48 2f       	mov	r20, r24
   17458:	59 2f       	mov	r21, r25
	             	" mov r21, %B0" "\n\t"
				 :
				 :"r" (globalpagenum)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   1745a:	80 91 7c 0a 	lds	r24, 0x0A7C
   1745e:	90 91 7d 0a 	lds	r25, 0x0A7D
   17462:	68 2f       	mov	r22, r24
   17464:	79 2f       	mov	r23, r25
	             	" mov r23, %B0" "\n\t"
				 :
				 :"r" (globalpageoffset)
                );
                
   asm volatile(" mov r18, %A0" "\n\t"
   17466:	80 91 7a 0a 	lds	r24, 0x0A7A
   1746a:	90 91 7b 0a 	lds	r25, 0x0A7B
   1746e:	28 2f       	mov	r18, r24
   17470:	39 2f       	mov	r19, r25
	             	" mov r19, %B0" "\n\t"
				 :
				 :"r" (globalbuffer)
                );

  fp(); 
   17472:	e9 81       	ldd	r30, Y+1	; 0x01
   17474:	fa 81       	ldd	r31, Y+2	; 0x02
   17476:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   17478:	7f 91       	pop	r23
   1747a:	6f 91       	pop	r22
	             "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   1747c:	5f 91       	pop	r21
   1747e:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
	
	asm volatile("pop r19" "\n\t"
   17480:	3f 91       	pop	r19
   17482:	2f 91       	pop	r18
   17484:	28 96       	adiw	r28, 0x08	; 8
   17486:	0f b6       	in	r0, 0x3f	; 63
   17488:	f8 94       	cli
   1748a:	de bf       	out	0x3e, r29	; 62
   1748c:	0f be       	out	0x3f, r0	; 63
   1748e:	cd bf       	out	0x3d, r28	; 61
   17490:	df 91       	pop	r29
   17492:	cf 91       	pop	r28
   17494:	08 95       	ret

00017496 <getFilePathAddress>:



char *getFilePathAddress()
{
   17496:	cf 93       	push	r28
   17498:	df 93       	push	r29
   1749a:	cd b7       	in	r28, 0x3d	; 61
   1749c:	de b7       	in	r29, 0x3e	; 62
   1749e:	24 97       	sbiw	r28, 0x04	; 4
   174a0:	0f b6       	in	r0, 0x3f	; 63
   174a2:	f8 94       	cli
   174a4:	de bf       	out	0x3e, r29	; 62
   174a6:	0f be       	out	0x3f, r0	; 63
   174a8:	cd bf       	out	0x3d, r28	; 61
   char *pathaddr;
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_PATH_ADDRESS;
   174aa:	80 e2       	ldi	r24, 0x20	; 32
   174ac:	9a ee       	ldi	r25, 0xEA	; 234
   174ae:	9a 83       	std	Y+2, r25	; 0x02
   174b0:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   174b2:	4f 93       	push	r20
   174b4:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   174b6:	e9 81       	ldd	r30, Y+1	; 0x01
   174b8:	fa 81       	ldd	r31, Y+2	; 0x02
   174ba:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   174bc:	84 2f       	mov	r24, r20
   174be:	95 2f       	mov	r25, r21
   174c0:	9c 83       	std	Y+4, r25	; 0x04
   174c2:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (pathaddr)
				 :);
    asm volatile("pop r21" "\n\t"
   174c4:	5f 91       	pop	r21
   174c6:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return pathaddr;
   174c8:	8b 81       	ldd	r24, Y+3	; 0x03
   174ca:	9c 81       	ldd	r25, Y+4	; 0x04
   174cc:	24 96       	adiw	r28, 0x04	; 4
   174ce:	0f b6       	in	r0, 0x3f	; 63
   174d0:	f8 94       	cli
   174d2:	de bf       	out	0x3e, r29	; 62
   174d4:	0f be       	out	0x3f, r0	; 63
   174d6:	cd bf       	out	0x3d, r28	; 61
   174d8:	df 91       	pop	r29
   174da:	cf 91       	pop	r28
   174dc:	08 95       	ret

000174de <getFileModeAddress>:
}



char *getFileModeAddress()

{
   174de:	cf 93       	push	r28
   174e0:	df 93       	push	r29
   174e2:	cd b7       	in	r28, 0x3d	; 61
   174e4:	de b7       	in	r29, 0x3e	; 62
   174e6:	24 97       	sbiw	r28, 0x04	; 4
   174e8:	0f b6       	in	r0, 0x3f	; 63
   174ea:	f8 94       	cli
   174ec:	de bf       	out	0x3e, r29	; 62
   174ee:	0f be       	out	0x3f, r0	; 63
   174f0:	cd bf       	out	0x3d, r28	; 61
   char *modeaddr;
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_MODE_ADDRESS;
   174f2:	84 e2       	ldi	r24, 0x24	; 36
   174f4:	9a ee       	ldi	r25, 0xEA	; 234
   174f6:	9a 83       	std	Y+2, r25	; 0x02
   174f8:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   174fa:	4f 93       	push	r20
   174fc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   174fe:	e9 81       	ldd	r30, Y+1	; 0x01
   17500:	fa 81       	ldd	r31, Y+2	; 0x02
   17502:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17504:	84 2f       	mov	r24, r20
   17506:	95 2f       	mov	r25, r21
   17508:	9c 83       	std	Y+4, r25	; 0x04
   1750a:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (modeaddr)
				 :);
    asm volatile("pop r21" "\n\t"
   1750c:	5f 91       	pop	r21
   1750e:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return modeaddr;
   17510:	8b 81       	ldd	r24, Y+3	; 0x03
   17512:	9c 81       	ldd	r25, Y+4	; 0x04
   17514:	24 96       	adiw	r28, 0x04	; 4
   17516:	0f b6       	in	r0, 0x3f	; 63
   17518:	f8 94       	cli
   1751a:	de bf       	out	0x3e, r29	; 62
   1751c:	0f be       	out	0x3f, r0	; 63
   1751e:	cd bf       	out	0x3d, r28	; 61
   17520:	df 91       	pop	r29
   17522:	cf 91       	pop	r28
   17524:	08 95       	ret

00017526 <openFileSysCall>:
}




void openFileSysCall()
{
   17526:	cf 93       	push	r28
   17528:	df 93       	push	r29
   1752a:	cd b7       	in	r28, 0x3d	; 61
   1752c:	de b7       	in	r29, 0x3e	; 62
   1752e:	22 97       	sbiw	r28, 0x02	; 2
   17530:	0f b6       	in	r0, 0x3f	; 63
   17532:	f8 94       	cli
   17534:	de bf       	out	0x3e, r29	; 62
   17536:	0f be       	out	0x3f, r0	; 63
   17538:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))OPEN_FILE_SYSCALL;
   1753a:	8c e2       	ldi	r24, 0x2C	; 44
   1753c:	9a ee       	ldi	r25, 0xEA	; 234
   1753e:	9a 83       	std	Y+2, r25	; 0x02
   17540:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   17542:	e9 81       	ldd	r30, Y+1	; 0x01
   17544:	fa 81       	ldd	r31, Y+2	; 0x02
   17546:	09 95       	icall
   17548:	22 96       	adiw	r28, 0x02	; 2
   1754a:	0f b6       	in	r0, 0x3f	; 63
   1754c:	f8 94       	cli
   1754e:	de bf       	out	0x3e, r29	; 62
   17550:	0f be       	out	0x3f, r0	; 63
   17552:	cd bf       	out	0x3d, r28	; 61
   17554:	df 91       	pop	r29
   17556:	cf 91       	pop	r28
   17558:	08 95       	ret

0001755a <closeFileSysCall>:
}



void closeFileSysCall()
{
   1755a:	cf 93       	push	r28
   1755c:	df 93       	push	r29
   1755e:	cd b7       	in	r28, 0x3d	; 61
   17560:	de b7       	in	r29, 0x3e	; 62
   17562:	22 97       	sbiw	r28, 0x02	; 2
   17564:	0f b6       	in	r0, 0x3f	; 63
   17566:	f8 94       	cli
   17568:	de bf       	out	0x3e, r29	; 62
   1756a:	0f be       	out	0x3f, r0	; 63
   1756c:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))CLOSE_FILE_SYSCALL;
   1756e:	80 e3       	ldi	r24, 0x30	; 48
   17570:	9a ee       	ldi	r25, 0xEA	; 234
   17572:	9a 83       	std	Y+2, r25	; 0x02
   17574:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   17576:	e9 81       	ldd	r30, Y+1	; 0x01
   17578:	fa 81       	ldd	r31, Y+2	; 0x02
   1757a:	09 95       	icall
   1757c:	22 96       	adiw	r28, 0x02	; 2
   1757e:	0f b6       	in	r0, 0x3f	; 63
   17580:	f8 94       	cli
   17582:	de bf       	out	0x3e, r29	; 62
   17584:	0f be       	out	0x3f, r0	; 63
   17586:	cd bf       	out	0x3d, r28	; 61
   17588:	df 91       	pop	r29
   1758a:	cf 91       	pop	r28
   1758c:	08 95       	ret

0001758e <readFileSysCall>:
}


void readFileSysCall()
{
   1758e:	cf 93       	push	r28
   17590:	df 93       	push	r29
   17592:	cd b7       	in	r28, 0x3d	; 61
   17594:	de b7       	in	r29, 0x3e	; 62
   17596:	22 97       	sbiw	r28, 0x02	; 2
   17598:	0f b6       	in	r0, 0x3f	; 63
   1759a:	f8 94       	cli
   1759c:	de bf       	out	0x3e, r29	; 62
   1759e:	0f be       	out	0x3f, r0	; 63
   175a0:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))READ_FILE_SYSCALL;
   175a2:	84 e3       	ldi	r24, 0x34	; 52
   175a4:	9a ee       	ldi	r25, 0xEA	; 234
   175a6:	9a 83       	std	Y+2, r25	; 0x02
   175a8:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   175aa:	e9 81       	ldd	r30, Y+1	; 0x01
   175ac:	fa 81       	ldd	r31, Y+2	; 0x02
   175ae:	09 95       	icall
   175b0:	22 96       	adiw	r28, 0x02	; 2
   175b2:	0f b6       	in	r0, 0x3f	; 63
   175b4:	f8 94       	cli
   175b6:	de bf       	out	0x3e, r29	; 62
   175b8:	0f be       	out	0x3f, r0	; 63
   175ba:	cd bf       	out	0x3d, r28	; 61
   175bc:	df 91       	pop	r29
   175be:	cf 91       	pop	r28
   175c0:	08 95       	ret

000175c2 <writeFileSysCall>:
}



void writeFileSysCall()
{
   175c2:	cf 93       	push	r28
   175c4:	df 93       	push	r29
   175c6:	cd b7       	in	r28, 0x3d	; 61
   175c8:	de b7       	in	r29, 0x3e	; 62
   175ca:	22 97       	sbiw	r28, 0x02	; 2
   175cc:	0f b6       	in	r0, 0x3f	; 63
   175ce:	f8 94       	cli
   175d0:	de bf       	out	0x3e, r29	; 62
   175d2:	0f be       	out	0x3f, r0	; 63
   175d4:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))WRITE_FILE_SYSCALL;
   175d6:	88 e3       	ldi	r24, 0x38	; 56
   175d8:	9a ee       	ldi	r25, 0xEA	; 234
   175da:	9a 83       	std	Y+2, r25	; 0x02
   175dc:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   175de:	e9 81       	ldd	r30, Y+1	; 0x01
   175e0:	fa 81       	ldd	r31, Y+2	; 0x02
   175e2:	09 95       	icall
   175e4:	22 96       	adiw	r28, 0x02	; 2
   175e6:	0f b6       	in	r0, 0x3f	; 63
   175e8:	f8 94       	cli
   175ea:	de bf       	out	0x3e, r29	; 62
   175ec:	0f be       	out	0x3f, r0	; 63
   175ee:	cd bf       	out	0x3d, r28	; 61
   175f0:	df 91       	pop	r29
   175f2:	cf 91       	pop	r28
   175f4:	08 95       	ret

000175f6 <seekFileSysCall>:
}



void seekFileSysCall()
{
   175f6:	cf 93       	push	r28
   175f8:	df 93       	push	r29
   175fa:	cd b7       	in	r28, 0x3d	; 61
   175fc:	de b7       	in	r29, 0x3e	; 62
   175fe:	22 97       	sbiw	r28, 0x02	; 2
   17600:	0f b6       	in	r0, 0x3f	; 63
   17602:	f8 94       	cli
   17604:	de bf       	out	0x3e, r29	; 62
   17606:	0f be       	out	0x3f, r0	; 63
   17608:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))SEEK_FILE_SYSCALL;
   1760a:	8c e3       	ldi	r24, 0x3C	; 60
   1760c:	9a ee       	ldi	r25, 0xEA	; 234
   1760e:	9a 83       	std	Y+2, r25	; 0x02
   17610:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   17612:	e9 81       	ldd	r30, Y+1	; 0x01
   17614:	fa 81       	ldd	r31, Y+2	; 0x02
   17616:	09 95       	icall
   17618:	22 96       	adiw	r28, 0x02	; 2
   1761a:	0f b6       	in	r0, 0x3f	; 63
   1761c:	f8 94       	cli
   1761e:	de bf       	out	0x3e, r29	; 62
   17620:	0f be       	out	0x3f, r0	; 63
   17622:	cd bf       	out	0x3d, r28	; 61
   17624:	df 91       	pop	r29
   17626:	cf 91       	pop	r28
   17628:	08 95       	ret

0001762a <mfopen>:
}




MYFILE *mfopen(char *pathname, char *mode)
{
   1762a:	cf 93       	push	r28
   1762c:	df 93       	push	r29
   1762e:	cd b7       	in	r28, 0x3d	; 61
   17630:	de b7       	in	r29, 0x3e	; 62
   17632:	2d 97       	sbiw	r28, 0x0d	; 13
   17634:	0f b6       	in	r0, 0x3f	; 63
   17636:	f8 94       	cli
   17638:	de bf       	out	0x3e, r29	; 62
   1763a:	0f be       	out	0x3f, r0	; 63
   1763c:	cd bf       	out	0x3d, r28	; 61
   1763e:	9b 87       	std	Y+11, r25	; 0x0b
   17640:	8a 87       	std	Y+10, r24	; 0x0a
   17642:	7d 87       	std	Y+13, r23	; 0x0d
   17644:	6c 87       	std	Y+12, r22	; 0x0c
   char *commonpathnameaddr;

   char *commonmodeaddr;

   uint8_t currentthreadindex;

   thread** current_thread;

   mutex *mfile;

   current_thread = getCurrentThread();
   17646:	0e 94 74 c5 	call	0x18ae8
   1764a:	9c 83       	std	Y+4, r25	; 0x04
   1764c:	8b 83       	std	Y+3, r24	; 0x03

   currentthreadindex = getCurrentThreadIndex();
   1764e:	0e 94 bc c5 	call	0x18b78
   17652:	8d 83       	std	Y+5, r24	; 0x05

   commonpathnameaddr =  getFilePathAddress();
   17654:	0e 94 4b ba 	call	0x17496
   17658:	99 87       	std	Y+9, r25	; 0x09
   1765a:	88 87       	std	Y+8, r24	; 0x08

   commonmodeaddr = getFileModeAddress();
   1765c:	0e 94 6f ba 	call	0x174de
   17660:	9f 83       	std	Y+7, r25	; 0x07
   17662:	8e 83       	std	Y+6, r24	; 0x06

   mfile = getFileMutexAddress();
   17664:	0e 94 c2 be 	call	0x17d84
   17668:	9a 83       	std	Y+2, r25	; 0x02
   1766a:	89 83       	std	Y+1, r24	; 0x01


   Mutex_lock(mfile);
   1766c:	89 81       	ldd	r24, Y+1	; 0x01
   1766e:	9a 81       	ldd	r25, Y+2	; 0x02
   17670:	0e 94 d1 bd 	call	0x17ba2

   mystrcpy(commonpathnameaddr, pathname);
   17674:	8a 85       	ldd	r24, Y+10	; 0x0a
   17676:	9b 85       	ldd	r25, Y+11	; 0x0b
   17678:	28 85       	ldd	r18, Y+8	; 0x08
   1767a:	39 85       	ldd	r19, Y+9	; 0x09
   1767c:	bc 01       	movw	r22, r24
   1767e:	c9 01       	movw	r24, r18
   17680:	0e 94 8d c3 	call	0x1871a
   mystrcpy(commonmodeaddr, mode);
   17684:	8c 85       	ldd	r24, Y+12	; 0x0c
   17686:	9d 85       	ldd	r25, Y+13	; 0x0d
   17688:	2e 81       	ldd	r18, Y+6	; 0x06
   1768a:	3f 81       	ldd	r19, Y+7	; 0x07
   1768c:	bc 01       	movw	r22, r24
   1768e:	c9 01       	movw	r24, r18
   17690:	0e 94 8d c3 	call	0x1871a

   openFileSysCall();
   17694:	0e 94 93 ba 	call	0x17526

   Barrier_block(7, 1);
   17698:	61 e0       	ldi	r22, 0x01	; 1
   1769a:	87 e0       	ldi	r24, 0x07	; 7
   1769c:	0e 94 44 be 	call	0x17c88
   Mutex_unlock(mfile);
   176a0:	89 81       	ldd	r24, Y+1	; 0x01
   176a2:	9a 81       	ldd	r25, Y+2	; 0x02
   176a4:	0e 94 20 be 	call	0x17c40

   return (MYFILE *)((*current_thread)->filedata.filestate.fileptr);
   176a8:	eb 81       	ldd	r30, Y+3	; 0x03
   176aa:	fc 81       	ldd	r31, Y+4	; 0x04
   176ac:	01 90       	ld	r0, Z+
   176ae:	f0 81       	ld	r31, Z
   176b0:	e0 2d       	mov	r30, r0
   176b2:	87 8d       	ldd	r24, Z+31	; 0x1f
   176b4:	90 a1       	ldd	r25, Z+32	; 0x20
   176b6:	2d 96       	adiw	r28, 0x0d	; 13
   176b8:	0f b6       	in	r0, 0x3f	; 63
   176ba:	f8 94       	cli
   176bc:	de bf       	out	0x3e, r29	; 62
   176be:	0f be       	out	0x3f, r0	; 63
   176c0:	cd bf       	out	0x3d, r28	; 61
   176c2:	df 91       	pop	r29
   176c4:	cf 91       	pop	r28
   176c6:	08 95       	ret

000176c8 <mfclose>:
}



void mfclose(MYFILE *fp)
{
   176c8:	cf 93       	push	r28
   176ca:	df 93       	push	r29
   176cc:	cd b7       	in	r28, 0x3d	; 61
   176ce:	de b7       	in	r29, 0x3e	; 62
   176d0:	27 97       	sbiw	r28, 0x07	; 7
   176d2:	0f b6       	in	r0, 0x3f	; 63
   176d4:	f8 94       	cli
   176d6:	de bf       	out	0x3e, r29	; 62
   176d8:	0f be       	out	0x3f, r0	; 63
   176da:	cd bf       	out	0x3d, r28	; 61
   176dc:	9f 83       	std	Y+7, r25	; 0x07
   176de:	8e 83       	std	Y+6, r24	; 0x06
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   176e0:	0e 94 74 c5 	call	0x18ae8
   176e4:	9c 83       	std	Y+4, r25	; 0x04
   176e6:	8b 83       	std	Y+3, r24	; 0x03
   currentthreadindex = getCurrentThreadIndex();
   176e8:	0e 94 bc c5 	call	0x18b78
   176ec:	8d 83       	std	Y+5, r24	; 0x05
   mfile = getFileMutexAddress();
   176ee:	0e 94 c2 be 	call	0x17d84
   176f2:	9a 83       	std	Y+2, r25	; 0x02
   176f4:	89 83       	std	Y+1, r24	; 0x01

   Mutex_lock(mfile);
   176f6:	89 81       	ldd	r24, Y+1	; 0x01
   176f8:	9a 81       	ldd	r25, Y+2	; 0x02
   176fa:	0e 94 d1 bd 	call	0x17ba2

   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   176fe:	eb 81       	ldd	r30, Y+3	; 0x03
   17700:	fc 81       	ldd	r31, Y+4	; 0x04
   17702:	01 90       	ld	r0, Z+
   17704:	f0 81       	ld	r31, Z
   17706:	e0 2d       	mov	r30, r0
   17708:	8e 81       	ldd	r24, Y+6	; 0x06
   1770a:	9f 81       	ldd	r25, Y+7	; 0x07
   1770c:	90 a3       	std	Z+32, r25	; 0x20
   1770e:	87 8f       	std	Z+31, r24	; 0x1f
   closeFileSysCall();
   17710:	0e 94 ad ba 	call	0x1755a

   Barrier_block(7, 2);
   17714:	62 e0       	ldi	r22, 0x02	; 2
   17716:	87 e0       	ldi	r24, 0x07	; 7
   17718:	0e 94 44 be 	call	0x17c88
   Mutex_unlock(mfile);
   1771c:	89 81       	ldd	r24, Y+1	; 0x01
   1771e:	9a 81       	ldd	r25, Y+2	; 0x02
   17720:	0e 94 20 be 	call	0x17c40
   17724:	27 96       	adiw	r28, 0x07	; 7
   17726:	0f b6       	in	r0, 0x3f	; 63
   17728:	f8 94       	cli
   1772a:	de bf       	out	0x3e, r29	; 62
   1772c:	0f be       	out	0x3f, r0	; 63
   1772e:	cd bf       	out	0x3d, r28	; 61
   17730:	df 91       	pop	r29
   17732:	cf 91       	pop	r28
   17734:	08 95       	ret

00017736 <mfread>:

   return;

}

void mfread(MYFILE *fp, void *buffer, int nBytes)
{
   17736:	cf 93       	push	r28
   17738:	df 93       	push	r29
   1773a:	cd b7       	in	r28, 0x3d	; 61
   1773c:	de b7       	in	r29, 0x3e	; 62
   1773e:	2b 97       	sbiw	r28, 0x0b	; 11
   17740:	0f b6       	in	r0, 0x3f	; 63
   17742:	f8 94       	cli
   17744:	de bf       	out	0x3e, r29	; 62
   17746:	0f be       	out	0x3f, r0	; 63
   17748:	cd bf       	out	0x3d, r28	; 61
   1774a:	9f 83       	std	Y+7, r25	; 0x07
   1774c:	8e 83       	std	Y+6, r24	; 0x06
   1774e:	79 87       	std	Y+9, r23	; 0x09
   17750:	68 87       	std	Y+8, r22	; 0x08
   17752:	5b 87       	std	Y+11, r21	; 0x0b
   17754:	4a 87       	std	Y+10, r20	; 0x0a
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   17756:	0e 94 74 c5 	call	0x18ae8
   1775a:	9c 83       	std	Y+4, r25	; 0x04
   1775c:	8b 83       	std	Y+3, r24	; 0x03
   currentthreadindex = getCurrentThreadIndex();
   1775e:	0e 94 bc c5 	call	0x18b78
   17762:	8d 83       	std	Y+5, r24	; 0x05
   mfile = getFileMutexAddress();
   17764:	0e 94 c2 be 	call	0x17d84
   17768:	9a 83       	std	Y+2, r25	; 0x02
   1776a:	89 83       	std	Y+1, r24	; 0x01


   Mutex_lock(mfile);
   1776c:	89 81       	ldd	r24, Y+1	; 0x01
   1776e:	9a 81       	ldd	r25, Y+2	; 0x02
   17770:	0e 94 d1 bd 	call	0x17ba2
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   17774:	eb 81       	ldd	r30, Y+3	; 0x03
   17776:	fc 81       	ldd	r31, Y+4	; 0x04
   17778:	01 90       	ld	r0, Z+
   1777a:	f0 81       	ld	r31, Z
   1777c:	e0 2d       	mov	r30, r0
   1777e:	8e 81       	ldd	r24, Y+6	; 0x06
   17780:	9f 81       	ldd	r25, Y+7	; 0x07
   17782:	90 a3       	std	Z+32, r25	; 0x20
   17784:	87 8f       	std	Z+31, r24	; 0x1f
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   17786:	eb 81       	ldd	r30, Y+3	; 0x03
   17788:	fc 81       	ldd	r31, Y+4	; 0x04
   1778a:	01 90       	ld	r0, Z+
   1778c:	f0 81       	ld	r31, Z
   1778e:	e0 2d       	mov	r30, r0
   17790:	88 85       	ldd	r24, Y+8	; 0x08
   17792:	99 85       	ldd	r25, Y+9	; 0x09
   17794:	92 a3       	std	Z+34, r25	; 0x22
   17796:	81 a3       	std	Z+33, r24	; 0x21
   (*current_thread)->filedata.filestate.bytes = nBytes;
   17798:	eb 81       	ldd	r30, Y+3	; 0x03
   1779a:	fc 81       	ldd	r31, Y+4	; 0x04
   1779c:	01 90       	ld	r0, Z+
   1779e:	f0 81       	ld	r31, Z
   177a0:	e0 2d       	mov	r30, r0
   177a2:	8a 85       	ldd	r24, Y+10	; 0x0a
   177a4:	9b 85       	ldd	r25, Y+11	; 0x0b
   177a6:	94 a3       	std	Z+36, r25	; 0x24
   177a8:	83 a3       	std	Z+35, r24	; 0x23

   readFileSysCall();
   177aa:	0e 94 c7 ba 	call	0x1758e

   Barrier_block(7, 3);
   177ae:	63 e0       	ldi	r22, 0x03	; 3
   177b0:	87 e0       	ldi	r24, 0x07	; 7
   177b2:	0e 94 44 be 	call	0x17c88
   Mutex_unlock(mfile);
   177b6:	89 81       	ldd	r24, Y+1	; 0x01
   177b8:	9a 81       	ldd	r25, Y+2	; 0x02
   177ba:	0e 94 20 be 	call	0x17c40
   177be:	2b 96       	adiw	r28, 0x0b	; 11
   177c0:	0f b6       	in	r0, 0x3f	; 63
   177c2:	f8 94       	cli
   177c4:	de bf       	out	0x3e, r29	; 62
   177c6:	0f be       	out	0x3f, r0	; 63
   177c8:	cd bf       	out	0x3d, r28	; 61
   177ca:	df 91       	pop	r29
   177cc:	cf 91       	pop	r28
   177ce:	08 95       	ret

000177d0 <mfwrite>:

   return;

}



void mfwrite(MYFILE *fp, void *buffer, int nBytes)
{
   177d0:	cf 93       	push	r28
   177d2:	df 93       	push	r29
   177d4:	cd b7       	in	r28, 0x3d	; 61
   177d6:	de b7       	in	r29, 0x3e	; 62
   177d8:	2b 97       	sbiw	r28, 0x0b	; 11
   177da:	0f b6       	in	r0, 0x3f	; 63
   177dc:	f8 94       	cli
   177de:	de bf       	out	0x3e, r29	; 62
   177e0:	0f be       	out	0x3f, r0	; 63
   177e2:	cd bf       	out	0x3d, r28	; 61
   177e4:	9f 83       	std	Y+7, r25	; 0x07
   177e6:	8e 83       	std	Y+6, r24	; 0x06
   177e8:	79 87       	std	Y+9, r23	; 0x09
   177ea:	68 87       	std	Y+8, r22	; 0x08
   177ec:	5b 87       	std	Y+11, r21	; 0x0b
   177ee:	4a 87       	std	Y+10, r20	; 0x0a
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   177f0:	0e 94 74 c5 	call	0x18ae8
   177f4:	9c 83       	std	Y+4, r25	; 0x04
   177f6:	8b 83       	std	Y+3, r24	; 0x03
   currentthreadindex = getCurrentThreadIndex();
   177f8:	0e 94 bc c5 	call	0x18b78
   177fc:	8d 83       	std	Y+5, r24	; 0x05
   mfile = getFileMutexAddress();
   177fe:	0e 94 c2 be 	call	0x17d84
   17802:	9a 83       	std	Y+2, r25	; 0x02
   17804:	89 83       	std	Y+1, r24	; 0x01


   Mutex_lock(mfile);
   17806:	89 81       	ldd	r24, Y+1	; 0x01
   17808:	9a 81       	ldd	r25, Y+2	; 0x02
   1780a:	0e 94 d1 bd 	call	0x17ba2
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   1780e:	eb 81       	ldd	r30, Y+3	; 0x03
   17810:	fc 81       	ldd	r31, Y+4	; 0x04
   17812:	01 90       	ld	r0, Z+
   17814:	f0 81       	ld	r31, Z
   17816:	e0 2d       	mov	r30, r0
   17818:	8e 81       	ldd	r24, Y+6	; 0x06
   1781a:	9f 81       	ldd	r25, Y+7	; 0x07
   1781c:	90 a3       	std	Z+32, r25	; 0x20
   1781e:	87 8f       	std	Z+31, r24	; 0x1f
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   17820:	eb 81       	ldd	r30, Y+3	; 0x03
   17822:	fc 81       	ldd	r31, Y+4	; 0x04
   17824:	01 90       	ld	r0, Z+
   17826:	f0 81       	ld	r31, Z
   17828:	e0 2d       	mov	r30, r0
   1782a:	88 85       	ldd	r24, Y+8	; 0x08
   1782c:	99 85       	ldd	r25, Y+9	; 0x09
   1782e:	92 a3       	std	Z+34, r25	; 0x22
   17830:	81 a3       	std	Z+33, r24	; 0x21
   (*current_thread)->filedata.filestate.bytes = nBytes;
   17832:	eb 81       	ldd	r30, Y+3	; 0x03
   17834:	fc 81       	ldd	r31, Y+4	; 0x04
   17836:	01 90       	ld	r0, Z+
   17838:	f0 81       	ld	r31, Z
   1783a:	e0 2d       	mov	r30, r0
   1783c:	8a 85       	ldd	r24, Y+10	; 0x0a
   1783e:	9b 85       	ldd	r25, Y+11	; 0x0b
   17840:	94 a3       	std	Z+36, r25	; 0x24
   17842:	83 a3       	std	Z+35, r24	; 0x23

   writeFileSysCall();
   17844:	0e 94 e1 ba 	call	0x175c2

   Barrier_block(7, 4);
   17848:	64 e0       	ldi	r22, 0x04	; 4
   1784a:	87 e0       	ldi	r24, 0x07	; 7
   1784c:	0e 94 44 be 	call	0x17c88
   Mutex_unlock(mfile);
   17850:	89 81       	ldd	r24, Y+1	; 0x01
   17852:	9a 81       	ldd	r25, Y+2	; 0x02
   17854:	0e 94 20 be 	call	0x17c40
   17858:	2b 96       	adiw	r28, 0x0b	; 11
   1785a:	0f b6       	in	r0, 0x3f	; 63
   1785c:	f8 94       	cli
   1785e:	de bf       	out	0x3e, r29	; 62
   17860:	0f be       	out	0x3f, r0	; 63
   17862:	cd bf       	out	0x3d, r28	; 61
   17864:	df 91       	pop	r29
   17866:	cf 91       	pop	r28
   17868:	08 95       	ret

0001786a <mfwrite_withoutlength>:

   return;
}


void mfwrite_withoutlength(MYFILE *fp, void *buffer)
{
   1786a:	cf 93       	push	r28
   1786c:	df 93       	push	r29
   1786e:	cd b7       	in	r28, 0x3d	; 61
   17870:	de b7       	in	r29, 0x3e	; 62
   17872:	25 97       	sbiw	r28, 0x05	; 5
   17874:	0f b6       	in	r0, 0x3f	; 63
   17876:	f8 94       	cli
   17878:	de bf       	out	0x3e, r29	; 62
   1787a:	0f be       	out	0x3f, r0	; 63
   1787c:	cd bf       	out	0x3d, r28	; 61
   1787e:	9b 83       	std	Y+3, r25	; 0x03
   17880:	8a 83       	std	Y+2, r24	; 0x02
   17882:	7d 83       	std	Y+5, r23	; 0x05
   17884:	6c 83       	std	Y+4, r22	; 0x04


   uint8_t length;

   length = (uint8_t)String_length((char*)buffer);
   17886:	8c 81       	ldd	r24, Y+4	; 0x04
   17888:	9d 81       	ldd	r25, Y+5	; 0x05
   1788a:	0e 94 2b c3 	call	0x18656
   1788e:	89 83       	std	Y+1, r24	; 0x01

   mfwrite(fp, buffer, length);
   17890:	89 81       	ldd	r24, Y+1	; 0x01
   17892:	99 27       	eor	r25, r25
   17894:	2c 81       	ldd	r18, Y+4	; 0x04
   17896:	3d 81       	ldd	r19, Y+5	; 0x05
   17898:	ea 81       	ldd	r30, Y+2	; 0x02
   1789a:	fb 81       	ldd	r31, Y+3	; 0x03
   1789c:	ac 01       	movw	r20, r24
   1789e:	b9 01       	movw	r22, r18
   178a0:	cf 01       	movw	r24, r30
   178a2:	0e 94 e8 bb 	call	0x177d0
   178a6:	25 96       	adiw	r28, 0x05	; 5
   178a8:	0f b6       	in	r0, 0x3f	; 63
   178aa:	f8 94       	cli
   178ac:	de bf       	out	0x3e, r29	; 62
   178ae:	0f be       	out	0x3f, r0	; 63
   178b0:	cd bf       	out	0x3d, r28	; 61
   178b2:	df 91       	pop	r29
   178b4:	cf 91       	pop	r28
   178b6:	08 95       	ret

000178b8 <mfseek>:

   return;
}






void mfseek(MYFILE *fp, int offset, int position)
{
   178b8:	cf 93       	push	r28
   178ba:	df 93       	push	r29
   178bc:	cd b7       	in	r28, 0x3d	; 61
   178be:	de b7       	in	r29, 0x3e	; 62
   178c0:	29 97       	sbiw	r28, 0x09	; 9
   178c2:	0f b6       	in	r0, 0x3f	; 63
   178c4:	f8 94       	cli
   178c6:	de bf       	out	0x3e, r29	; 62
   178c8:	0f be       	out	0x3f, r0	; 63
   178ca:	cd bf       	out	0x3d, r28	; 61
   178cc:	9d 83       	std	Y+5, r25	; 0x05
   178ce:	8c 83       	std	Y+4, r24	; 0x04
   178d0:	7f 83       	std	Y+7, r23	; 0x07
   178d2:	6e 83       	std	Y+6, r22	; 0x06
   178d4:	59 87       	std	Y+9, r21	; 0x09
   178d6:	48 87       	std	Y+8, r20	; 0x08
   uint8_t currentthreadindex;
   thread** current_thread;

   current_thread = getCurrentThread();
   178d8:	0e 94 74 c5 	call	0x18ae8
   178dc:	9a 83       	std	Y+2, r25	; 0x02
   178de:	89 83       	std	Y+1, r24	; 0x01
   currentthreadindex = getCurrentThreadIndex();
   178e0:	0e 94 bc c5 	call	0x18b78
   178e4:	8b 83       	std	Y+3, r24	; 0x03

   (*current_thread)->filedata.fileseekstate.fileptr = (uint8_t*)fp;
   178e6:	e9 81       	ldd	r30, Y+1	; 0x01
   178e8:	fa 81       	ldd	r31, Y+2	; 0x02
   178ea:	01 90       	ld	r0, Z+
   178ec:	f0 81       	ld	r31, Z
   178ee:	e0 2d       	mov	r30, r0
   178f0:	8c 81       	ldd	r24, Y+4	; 0x04
   178f2:	9d 81       	ldd	r25, Y+5	; 0x05
   178f4:	90 a3       	std	Z+32, r25	; 0x20
   178f6:	87 8f       	std	Z+31, r24	; 0x1f
   (*current_thread)->filedata.fileseekstate.offset = offset;
   178f8:	e9 81       	ldd	r30, Y+1	; 0x01
   178fa:	fa 81       	ldd	r31, Y+2	; 0x02
   178fc:	01 90       	ld	r0, Z+
   178fe:	f0 81       	ld	r31, Z
   17900:	e0 2d       	mov	r30, r0
   17902:	8e 81       	ldd	r24, Y+6	; 0x06
   17904:	9f 81       	ldd	r25, Y+7	; 0x07
   17906:	92 a3       	std	Z+34, r25	; 0x22
   17908:	81 a3       	std	Z+33, r24	; 0x21
   (*current_thread)->filedata.fileseekstate.position = position;
   1790a:	e9 81       	ldd	r30, Y+1	; 0x01
   1790c:	fa 81       	ldd	r31, Y+2	; 0x02
   1790e:	01 90       	ld	r0, Z+
   17910:	f0 81       	ld	r31, Z
   17912:	e0 2d       	mov	r30, r0
   17914:	88 85       	ldd	r24, Y+8	; 0x08
   17916:	99 85       	ldd	r25, Y+9	; 0x09
   17918:	94 a3       	std	Z+36, r25	; 0x24
   1791a:	83 a3       	std	Z+35, r24	; 0x23

   seekFileSysCall();
   1791c:	0e 94 fb ba 	call	0x175f6
   17920:	29 96       	adiw	r28, 0x09	; 9
   17922:	0f b6       	in	r0, 0x3f	; 63
   17924:	f8 94       	cli
   17926:	de bf       	out	0x3e, r29	; 62
   17928:	0f be       	out	0x3f, r0	; 63
   1792a:	cd bf       	out	0x3d, r28	; 61
   1792c:	df 91       	pop	r29
   1792e:	cf 91       	pop	r28
   17930:	08 95       	ret

00017932 <greenToggle>:
#include "leds.h"
#include "liteoscommon.h"

void greenToggle()
{
   17932:	cf 93       	push	r28
   17934:	df 93       	push	r29
   17936:	cd b7       	in	r28, 0x3d	; 61
   17938:	de b7       	in	r29, 0x3e	; 62
   1793a:	22 97       	sbiw	r28, 0x02	; 2
   1793c:	0f b6       	in	r0, 0x3f	; 63
   1793e:	f8 94       	cli
   17940:	de bf       	out	0x3e, r29	; 62
   17942:	0f be       	out	0x3f, r0	; 63
   17944:	cd bf       	out	0x3d, r28	; 61
 void (*greenfp)() = (void (*)(void))GREEN_LED_TOGGLE_FUNCTION; 
   17946:	84 e0       	ldi	r24, 0x04	; 4
   17948:	9a ee       	ldi	r25, 0xEA	; 234
   1794a:	9a 83       	std	Y+2, r25	; 0x02
   1794c:	89 83       	std	Y+1, r24	; 0x01
 greenfp();                              
   1794e:	e9 81       	ldd	r30, Y+1	; 0x01
   17950:	fa 81       	ldd	r31, Y+2	; 0x02
   17952:	09 95       	icall
   17954:	22 96       	adiw	r28, 0x02	; 2
   17956:	0f b6       	in	r0, 0x3f	; 63
   17958:	f8 94       	cli
   1795a:	de bf       	out	0x3e, r29	; 62
   1795c:	0f be       	out	0x3f, r0	; 63
   1795e:	cd bf       	out	0x3d, r28	; 61
   17960:	df 91       	pop	r29
   17962:	cf 91       	pop	r28
   17964:	08 95       	ret

00017966 <redToggle>:



}

void redToggle()
{
   17966:	cf 93       	push	r28
   17968:	df 93       	push	r29
   1796a:	cd b7       	in	r28, 0x3d	; 61
   1796c:	de b7       	in	r29, 0x3e	; 62
   1796e:	22 97       	sbiw	r28, 0x02	; 2
   17970:	0f b6       	in	r0, 0x3f	; 63
   17972:	f8 94       	cli
   17974:	de bf       	out	0x3e, r29	; 62
   17976:	0f be       	out	0x3f, r0	; 63
   17978:	cd bf       	out	0x3d, r28	; 61
                          
  void (*redfp)() = (void (*)(void))RED_LED_TOGGLE_FUNCTION; 
   1797a:	88 e0       	ldi	r24, 0x08	; 8
   1797c:	9a ee       	ldi	r25, 0xEA	; 234
   1797e:	9a 83       	std	Y+2, r25	; 0x02
   17980:	89 83       	std	Y+1, r24	; 0x01
  redfp();    
   17982:	e9 81       	ldd	r30, Y+1	; 0x01
   17984:	fa 81       	ldd	r31, Y+2	; 0x02
   17986:	09 95       	icall
   17988:	22 96       	adiw	r28, 0x02	; 2
   1798a:	0f b6       	in	r0, 0x3f	; 63
   1798c:	f8 94       	cli
   1798e:	de bf       	out	0x3e, r29	; 62
   17990:	0f be       	out	0x3f, r0	; 63
   17992:	cd bf       	out	0x3d, r28	; 61
   17994:	df 91       	pop	r29
   17996:	cf 91       	pop	r28
   17998:	08 95       	ret

0001799a <yellowToggle>:
}


void yellowToggle()
{
   1799a:	cf 93       	push	r28
   1799c:	df 93       	push	r29
   1799e:	cd b7       	in	r28, 0x3d	; 61
   179a0:	de b7       	in	r29, 0x3e	; 62
   179a2:	22 97       	sbiw	r28, 0x02	; 2
   179a4:	0f b6       	in	r0, 0x3f	; 63
   179a6:	f8 94       	cli
   179a8:	de bf       	out	0x3e, r29	; 62
   179aa:	0f be       	out	0x3f, r0	; 63
   179ac:	cd bf       	out	0x3d, r28	; 61
                          
  void (*yellowfp)() = (void (*)(void))YELLOW_TOGGLE_FUNCTION; 
   179ae:	80 e7       	ldi	r24, 0x70	; 112
   179b0:	9a ee       	ldi	r25, 0xEA	; 234
   179b2:	9a 83       	std	Y+2, r25	; 0x02
   179b4:	89 83       	std	Y+1, r24	; 0x01
  yellowfp();    
   179b6:	e9 81       	ldd	r30, Y+1	; 0x01
   179b8:	fa 81       	ldd	r31, Y+2	; 0x02
   179ba:	09 95       	icall
   179bc:	22 96       	adiw	r28, 0x02	; 2
   179be:	0f b6       	in	r0, 0x3f	; 63
   179c0:	f8 94       	cli
   179c2:	de bf       	out	0x3e, r29	; 62
   179c4:	0f be       	out	0x3f, r0	; 63
   179c6:	cd bf       	out	0x3d, r28	; 61
   179c8:	df 91       	pop	r29
   179ca:	cf 91       	pop	r28
   179cc:	08 95       	ret

000179ce <redOn>:
}



void redOn()
{
   179ce:	cf 93       	push	r28
   179d0:	df 93       	push	r29
   179d2:	cd b7       	in	r28, 0x3d	; 61
   179d4:	de b7       	in	r29, 0x3e	; 62
   179d6:	22 97       	sbiw	r28, 0x02	; 2
   179d8:	0f b6       	in	r0, 0x3f	; 63
   179da:	f8 94       	cli
   179dc:	de bf       	out	0x3e, r29	; 62
   179de:	0f be       	out	0x3f, r0	; 63
   179e0:	cd bf       	out	0x3d, r28	; 61
                          
  void (*redfp)() = (void (*)(void))RED_ON_FUNCTION; 
   179e2:	84 e7       	ldi	r24, 0x74	; 116
   179e4:	9a ee       	ldi	r25, 0xEA	; 234
   179e6:	9a 83       	std	Y+2, r25	; 0x02
   179e8:	89 83       	std	Y+1, r24	; 0x01
  redfp();    
   179ea:	e9 81       	ldd	r30, Y+1	; 0x01
   179ec:	fa 81       	ldd	r31, Y+2	; 0x02
   179ee:	09 95       	icall
   179f0:	22 96       	adiw	r28, 0x02	; 2
   179f2:	0f b6       	in	r0, 0x3f	; 63
   179f4:	f8 94       	cli
   179f6:	de bf       	out	0x3e, r29	; 62
   179f8:	0f be       	out	0x3f, r0	; 63
   179fa:	cd bf       	out	0x3d, r28	; 61
   179fc:	df 91       	pop	r29
   179fe:	cf 91       	pop	r28
   17a00:	08 95       	ret

00017a02 <redOff>:
}



void redOff()
{
   17a02:	cf 93       	push	r28
   17a04:	df 93       	push	r29
   17a06:	cd b7       	in	r28, 0x3d	; 61
   17a08:	de b7       	in	r29, 0x3e	; 62
   17a0a:	22 97       	sbiw	r28, 0x02	; 2
   17a0c:	0f b6       	in	r0, 0x3f	; 63
   17a0e:	f8 94       	cli
   17a10:	de bf       	out	0x3e, r29	; 62
   17a12:	0f be       	out	0x3f, r0	; 63
   17a14:	cd bf       	out	0x3d, r28	; 61
                          
  void (*redfp)() = (void (*)(void))RED_OFF_FUNCTION; 
   17a16:	88 e7       	ldi	r24, 0x78	; 120
   17a18:	9a ee       	ldi	r25, 0xEA	; 234
   17a1a:	9a 83       	std	Y+2, r25	; 0x02
   17a1c:	89 83       	std	Y+1, r24	; 0x01
  redfp();    
   17a1e:	e9 81       	ldd	r30, Y+1	; 0x01
   17a20:	fa 81       	ldd	r31, Y+2	; 0x02
   17a22:	09 95       	icall
   17a24:	22 96       	adiw	r28, 0x02	; 2
   17a26:	0f b6       	in	r0, 0x3f	; 63
   17a28:	f8 94       	cli
   17a2a:	de bf       	out	0x3e, r29	; 62
   17a2c:	0f be       	out	0x3f, r0	; 63
   17a2e:	cd bf       	out	0x3d, r28	; 61
   17a30:	df 91       	pop	r29
   17a32:	cf 91       	pop	r28
   17a34:	08 95       	ret

00017a36 <greenOn>:
}



void greenOn()
{
   17a36:	cf 93       	push	r28
   17a38:	df 93       	push	r29
   17a3a:	cd b7       	in	r28, 0x3d	; 61
   17a3c:	de b7       	in	r29, 0x3e	; 62
   17a3e:	22 97       	sbiw	r28, 0x02	; 2
   17a40:	0f b6       	in	r0, 0x3f	; 63
   17a42:	f8 94       	cli
   17a44:	de bf       	out	0x3e, r29	; 62
   17a46:	0f be       	out	0x3f, r0	; 63
   17a48:	cd bf       	out	0x3d, r28	; 61
                          
  void (*greenfp)() = (void (*)(void))GREEN_ON_FUNCTION; 
   17a4a:	84 e8       	ldi	r24, 0x84	; 132
   17a4c:	9a ee       	ldi	r25, 0xEA	; 234
   17a4e:	9a 83       	std	Y+2, r25	; 0x02
   17a50:	89 83       	std	Y+1, r24	; 0x01
  greenfp();    
   17a52:	e9 81       	ldd	r30, Y+1	; 0x01
   17a54:	fa 81       	ldd	r31, Y+2	; 0x02
   17a56:	09 95       	icall
   17a58:	22 96       	adiw	r28, 0x02	; 2
   17a5a:	0f b6       	in	r0, 0x3f	; 63
   17a5c:	f8 94       	cli
   17a5e:	de bf       	out	0x3e, r29	; 62
   17a60:	0f be       	out	0x3f, r0	; 63
   17a62:	cd bf       	out	0x3d, r28	; 61
   17a64:	df 91       	pop	r29
   17a66:	cf 91       	pop	r28
   17a68:	08 95       	ret

00017a6a <greenOff>:
}


void greenOff()
{
   17a6a:	cf 93       	push	r28
   17a6c:	df 93       	push	r29
   17a6e:	cd b7       	in	r28, 0x3d	; 61
   17a70:	de b7       	in	r29, 0x3e	; 62
   17a72:	22 97       	sbiw	r28, 0x02	; 2
   17a74:	0f b6       	in	r0, 0x3f	; 63
   17a76:	f8 94       	cli
   17a78:	de bf       	out	0x3e, r29	; 62
   17a7a:	0f be       	out	0x3f, r0	; 63
   17a7c:	cd bf       	out	0x3d, r28	; 61
                          
  void (*greenfp)() = (void (*)(void))GREEN_OFF_FUNCTION; 
   17a7e:	88 e8       	ldi	r24, 0x88	; 136
   17a80:	9a ee       	ldi	r25, 0xEA	; 234
   17a82:	9a 83       	std	Y+2, r25	; 0x02
   17a84:	89 83       	std	Y+1, r24	; 0x01
  greenfp();    
   17a86:	e9 81       	ldd	r30, Y+1	; 0x01
   17a88:	fa 81       	ldd	r31, Y+2	; 0x02
   17a8a:	09 95       	icall
   17a8c:	22 96       	adiw	r28, 0x02	; 2
   17a8e:	0f b6       	in	r0, 0x3f	; 63
   17a90:	f8 94       	cli
   17a92:	de bf       	out	0x3e, r29	; 62
   17a94:	0f be       	out	0x3f, r0	; 63
   17a96:	cd bf       	out	0x3d, r28	; 61
   17a98:	df 91       	pop	r29
   17a9a:	cf 91       	pop	r28
   17a9c:	08 95       	ret

00017a9e <yellowOn>:
}

void yellowOn()
{
   17a9e:	cf 93       	push	r28
   17aa0:	df 93       	push	r29
   17aa2:	cd b7       	in	r28, 0x3d	; 61
   17aa4:	de b7       	in	r29, 0x3e	; 62
   17aa6:	22 97       	sbiw	r28, 0x02	; 2
   17aa8:	0f b6       	in	r0, 0x3f	; 63
   17aaa:	f8 94       	cli
   17aac:	de bf       	out	0x3e, r29	; 62
   17aae:	0f be       	out	0x3f, r0	; 63
   17ab0:	cd bf       	out	0x3d, r28	; 61
                          
  void (*yellowfp)() = (void (*)(void))YELLOW_ON_FUNCTION; 
   17ab2:	8c e7       	ldi	r24, 0x7C	; 124
   17ab4:	9a ee       	ldi	r25, 0xEA	; 234
   17ab6:	9a 83       	std	Y+2, r25	; 0x02
   17ab8:	89 83       	std	Y+1, r24	; 0x01
  yellowfp();    
   17aba:	e9 81       	ldd	r30, Y+1	; 0x01
   17abc:	fa 81       	ldd	r31, Y+2	; 0x02
   17abe:	09 95       	icall
   17ac0:	22 96       	adiw	r28, 0x02	; 2
   17ac2:	0f b6       	in	r0, 0x3f	; 63
   17ac4:	f8 94       	cli
   17ac6:	de bf       	out	0x3e, r29	; 62
   17ac8:	0f be       	out	0x3f, r0	; 63
   17aca:	cd bf       	out	0x3d, r28	; 61
   17acc:	df 91       	pop	r29
   17ace:	cf 91       	pop	r28
   17ad0:	08 95       	ret

00017ad2 <yellowOff>:
}

void yellowOff()
{
   17ad2:	cf 93       	push	r28
   17ad4:	df 93       	push	r29
   17ad6:	cd b7       	in	r28, 0x3d	; 61
   17ad8:	de b7       	in	r29, 0x3e	; 62
   17ada:	22 97       	sbiw	r28, 0x02	; 2
   17adc:	0f b6       	in	r0, 0x3f	; 63
   17ade:	f8 94       	cli
   17ae0:	de bf       	out	0x3e, r29	; 62
   17ae2:	0f be       	out	0x3f, r0	; 63
   17ae4:	cd bf       	out	0x3d, r28	; 61
                          
  void (*yellowfp)() = (void (*)(void))YELLOW_OFF_FUNCTION; 
   17ae6:	80 e8       	ldi	r24, 0x80	; 128
   17ae8:	9a ee       	ldi	r25, 0xEA	; 234
   17aea:	9a 83       	std	Y+2, r25	; 0x02
   17aec:	89 83       	std	Y+1, r24	; 0x01
  yellowfp();    
   17aee:	e9 81       	ldd	r30, Y+1	; 0x01
   17af0:	fa 81       	ldd	r31, Y+2	; 0x02
   17af2:	09 95       	icall
   17af4:	22 96       	adiw	r28, 0x02	; 2
   17af6:	0f b6       	in	r0, 0x3f	; 63
   17af8:	f8 94       	cli
   17afa:	de bf       	out	0x3e, r29	; 62
   17afc:	0f be       	out	0x3f, r0	; 63
   17afe:	cd bf       	out	0x3d, r28	; 61
   17b00:	df 91       	pop	r29
   17b02:	cf 91       	pop	r28
   17b04:	08 95       	ret

00017b06 <malloc>:

#include "malloc.h"

void *malloc(uint16_t size)
{
   17b06:	cf 93       	push	r28
   17b08:	df 93       	push	r29
   17b0a:	cd b7       	in	r28, 0x3d	; 61
   17b0c:	de b7       	in	r29, 0x3e	; 62
   17b0e:	26 97       	sbiw	r28, 0x06	; 6
   17b10:	0f b6       	in	r0, 0x3f	; 63
   17b12:	f8 94       	cli
   17b14:	de bf       	out	0x3e, r29	; 62
   17b16:	0f be       	out	0x3f, r0	; 63
   17b18:	cd bf       	out	0x3d, r28	; 61
   17b1a:	9e 83       	std	Y+6, r25	; 0x06
   17b1c:	8d 83       	std	Y+5, r24	; 0x05
 
   void (*mallocfunc)(void) = (void (*)(void))MALLOC_MEMORY_FUNCTION;
   17b1e:	80 eb       	ldi	r24, 0xB0	; 176
   17b20:	9a ee       	ldi	r25, 0xEA	; 234
   17b22:	9c 83       	std	Y+4, r25	; 0x04
   17b24:	8b 83       	std	Y+3, r24	; 0x03
   void *resultaddr; 

   asm volatile("push r20" "\n\t"
   17b26:	4f 93       	push	r20
   17b28:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   asm volatile(" mov r20, %A0" "\n\t"
   17b2a:	8d 81       	ldd	r24, Y+5	; 0x05
   17b2c:	9e 81       	ldd	r25, Y+6	; 0x06
   17b2e:	48 2f       	mov	r20, r24
   17b30:	59 2f       	mov	r21, r25
	              " mov r21, %B0" "\n\t"
				        :
				 	      :"r" (size)				 
               );
                            	
   mallocfunc();     
   17b32:	eb 81       	ldd	r30, Y+3	; 0x03
   17b34:	fc 81       	ldd	r31, Y+4	; 0x04
   17b36:	09 95       	icall
   
   asm volatile(" mov %A0, r20" "\n\t"
   17b38:	84 2f       	mov	r24, r20
   17b3a:	95 2f       	mov	r25, r21
   17b3c:	9a 83       	std	Y+2, r25	; 0x02
   17b3e:	89 83       	std	Y+1, r24	; 0x01
	               "mov %B0, r21" "\n\t"
				        :"=r" (resultaddr)
				        :
                );
    asm volatile("pop r21" "\n\t"
   17b40:	5f 91       	pop	r21
   17b42:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return (void*)resultaddr; 
   17b44:	89 81       	ldd	r24, Y+1	; 0x01
   17b46:	9a 81       	ldd	r25, Y+2	; 0x02
   17b48:	26 96       	adiw	r28, 0x06	; 6
   17b4a:	0f b6       	in	r0, 0x3f	; 63
   17b4c:	f8 94       	cli
   17b4e:	de bf       	out	0x3e, r29	; 62
   17b50:	0f be       	out	0x3f, r0	; 63
   17b52:	cd bf       	out	0x3d, r28	; 61
   17b54:	df 91       	pop	r29
   17b56:	cf 91       	pop	r28
   17b58:	08 95       	ret

00017b5a <free>:
}
	
	

void free(void *ptr)
{
   17b5a:	cf 93       	push	r28
   17b5c:	df 93       	push	r29
   17b5e:	cd b7       	in	r28, 0x3d	; 61
   17b60:	de b7       	in	r29, 0x3e	; 62
   17b62:	24 97       	sbiw	r28, 0x04	; 4
   17b64:	0f b6       	in	r0, 0x3f	; 63
   17b66:	f8 94       	cli
   17b68:	de bf       	out	0x3e, r29	; 62
   17b6a:	0f be       	out	0x3f, r0	; 63
   17b6c:	cd bf       	out	0x3d, r28	; 61
   17b6e:	9c 83       	std	Y+4, r25	; 0x04
   17b70:	8b 83       	std	Y+3, r24	; 0x03
  	
	 void (*mallocfunc)(void) = (void (*)(void))FREE_MEMORY_FUNCTION;
   17b72:	84 eb       	ldi	r24, 0xB4	; 180
   17b74:	9a ee       	ldi	r25, 0xEA	; 234
   17b76:	9a 83       	std	Y+2, r25	; 0x02
   17b78:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   17b7a:	4f 93       	push	r20
   17b7c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   asm volatile(" mov r20, %A0" "\n\t"
   17b7e:	8b 81       	ldd	r24, Y+3	; 0x03
   17b80:	9c 81       	ldd	r25, Y+4	; 0x04
   17b82:	48 2f       	mov	r20, r24
   17b84:	59 2f       	mov	r21, r25
	              " mov r21, %B0" "\n\t"
				        :
				 	      :"r" (ptr)				 
               );
                            	
   mallocfunc();     
   17b86:	e9 81       	ldd	r30, Y+1	; 0x01
   17b88:	fa 81       	ldd	r31, Y+2	; 0x02
   17b8a:	09 95       	icall
   
   asm volatile("pop r21" "\n\t"
   17b8c:	5f 91       	pop	r21
   17b8e:	4f 91       	pop	r20
   17b90:	24 96       	adiw	r28, 0x04	; 4
   17b92:	0f b6       	in	r0, 0x3f	; 63
   17b94:	f8 94       	cli
   17b96:	de bf       	out	0x3e, r29	; 62
   17b98:	0f be       	out	0x3f, r0	; 63
   17b9a:	cd bf       	out	0x3d, r28	; 61
   17b9c:	df 91       	pop	r29
   17b9e:	cf 91       	pop	r28
   17ba0:	08 95       	ret

00017ba2 <Mutex_lock>:
#include "thread.h"
#include "liteoscommon.h"

void Mutex_lock(mutex *m)
{
   17ba2:	cf 93       	push	r28
   17ba4:	df 93       	push	r29
   17ba6:	cd b7       	in	r28, 0x3d	; 61
   17ba8:	de b7       	in	r29, 0x3e	; 62
   17baa:	26 97       	sbiw	r28, 0x06	; 6
   17bac:	0f b6       	in	r0, 0x3f	; 63
   17bae:	f8 94       	cli
   17bb0:	de bf       	out	0x3e, r29	; 62
   17bb2:	0f be       	out	0x3f, r0	; 63
   17bb4:	cd bf       	out	0x3d, r28	; 61
   17bb6:	9e 83       	std	Y+6, r25	; 0x06
   17bb8:	8d 83       	std	Y+5, r24	; 0x05
  
    thread **current_thread; 
    uint8_t threadindex; 
    

	_atomic_t currentatomic;
    
	current_thread = getCurrentThread(); 
   17bba:	0e 94 74 c5 	call	0x18ae8
   17bbe:	9c 83       	std	Y+4, r25	; 0x04
   17bc0:	8b 83       	std	Y+3, r24	; 0x03
	threadindex = getCurrentThreadIndex(); 
   17bc2:	0e 94 bc c5 	call	0x18b78
   17bc6:	8a 83       	std	Y+2, r24	; 0x02

	currentatomic = _atomic_start();
   17bc8:	0e 94 d6 c4 	call	0x189ac
   17bcc:	89 83       	std	Y+1, r24	; 0x01
	
    if(m->lock){  
   17bce:	ed 81       	ldd	r30, Y+5	; 0x05
   17bd0:	fe 81       	ldd	r31, Y+6	; 0x06
   17bd2:	80 81       	ld	r24, Z
   17bd4:	88 23       	and	r24, r24
   17bd6:	01 f1       	breq	.+64     	; 0x17c18
        (*current_thread)->state = STATE_BLOCKED;
   17bd8:	eb 81       	ldd	r30, Y+3	; 0x03
   17bda:	fc 81       	ldd	r31, Y+4	; 0x04
   17bdc:	01 90       	ld	r0, Z+
   17bde:	f0 81       	ld	r31, Z
   17be0:	e0 2d       	mov	r30, r0
   17be2:	83 e0       	ldi	r24, 0x03	; 3
   17be4:	82 83       	std	Z+2, r24	; 0x02
        (*current_thread)->data.m = m;
   17be6:	eb 81       	ldd	r30, Y+3	; 0x03
   17be8:	fc 81       	ldd	r31, Y+4	; 0x04
   17bea:	01 90       	ld	r0, Z+
   17bec:	f0 81       	ld	r31, Z
   17bee:	e0 2d       	mov	r30, r0
   17bf0:	8d 81       	ldd	r24, Y+5	; 0x05
   17bf2:	9e 81       	ldd	r25, Y+6	; 0x06
   17bf4:	94 8f       	std	Z+28, r25	; 0x1c
   17bf6:	83 8f       	std	Z+27, r24	; 0x1b
        
      
        m->waiting++;
   17bf8:	ed 81       	ldd	r30, Y+5	; 0x05
   17bfa:	fe 81       	ldd	r31, Y+6	; 0x06
   17bfc:	81 81       	ldd	r24, Z+1	; 0x01
   17bfe:	8f 5f       	subi	r24, 0xFF	; 255
   17c00:	ed 81       	ldd	r30, Y+5	; 0x05
   17c02:	fe 81       	ldd	r31, Y+6	; 0x06
   17c04:	81 83       	std	Z+1, r24	; 0x01
       
        yield();
   17c06:	0e 94 2b c6 	call	0x18c56
     
        m->waiting--;
   17c0a:	ed 81       	ldd	r30, Y+5	; 0x05
   17c0c:	fe 81       	ldd	r31, Y+6	; 0x06
   17c0e:	81 81       	ldd	r24, Z+1	; 0x01
   17c10:	81 50       	subi	r24, 0x01	; 1
   17c12:	ed 81       	ldd	r30, Y+5	; 0x05
   17c14:	fe 81       	ldd	r31, Y+6	; 0x06
   17c16:	81 83       	std	Z+1, r24	; 0x01
      }
      m->lock = 1;
   17c18:	ed 81       	ldd	r30, Y+5	; 0x05
   17c1a:	fe 81       	ldd	r31, Y+6	; 0x06
   17c1c:	81 e0       	ldi	r24, 0x01	; 1
   17c1e:	80 83       	st	Z, r24
      m->lockingthreadid = threadindex; 
   17c20:	ed 81       	ldd	r30, Y+5	; 0x05
   17c22:	fe 81       	ldd	r31, Y+6	; 0x06
   17c24:	8a 81       	ldd	r24, Y+2	; 0x02
   17c26:	82 83       	std	Z+2, r24	; 0x02
      
    _atomic_end(currentatomic);  
   17c28:	89 81       	ldd	r24, Y+1	; 0x01
   17c2a:	0e 94 f0 c4 	call	0x189e0
   17c2e:	26 96       	adiw	r28, 0x06	; 6
   17c30:	0f b6       	in	r0, 0x3f	; 63
   17c32:	f8 94       	cli
   17c34:	de bf       	out	0x3e, r29	; 62
   17c36:	0f be       	out	0x3f, r0	; 63
   17c38:	cd bf       	out	0x3d, r28	; 61
   17c3a:	df 91       	pop	r29
   17c3c:	cf 91       	pop	r28
   17c3e:	08 95       	ret

00017c40 <Mutex_unlock>:


}



void Mutex_unlock(mutex *m)
{
   17c40:	cf 93       	push	r28
   17c42:	df 93       	push	r29
   17c44:	cd b7       	in	r28, 0x3d	; 61
   17c46:	de b7       	in	r29, 0x3e	; 62
   17c48:	24 97       	sbiw	r28, 0x04	; 4
   17c4a:	0f b6       	in	r0, 0x3f	; 63
   17c4c:	f8 94       	cli
   17c4e:	de bf       	out	0x3e, r29	; 62
   17c50:	0f be       	out	0x3f, r0	; 63
   17c52:	cd bf       	out	0x3d, r28	; 61
   17c54:	9c 83       	std	Y+4, r25	; 0x04
   17c56:	8b 83       	std	Y+3, r24	; 0x03
     
   void (*getaddrfp)(void) = (void (*)(void))MUTEX_UNLOCK_FUNCTION; 
   17c58:	88 e1       	ldi	r24, 0x18	; 24
   17c5a:	9a ee       	ldi	r25, 0xEA	; 234
   17c5c:	9a 83       	std	Y+2, r25	; 0x02
   17c5e:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   17c60:	4f 93       	push	r20
   17c62:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
      
   asm volatile(" mov r20, %A0" "\n\t"
   17c64:	8b 81       	ldd	r24, Y+3	; 0x03
   17c66:	9c 81       	ldd	r25, Y+4	; 0x04
   17c68:	48 2f       	mov	r20, r24
   17c6a:	59 2f       	mov	r21, r25
	              " mov r21, %B0" "\n\t"
				 :
				 :"r" (m)
                );

   getaddrfp();
   17c6c:	e9 81       	ldd	r30, Y+1	; 0x01
   17c6e:	fa 81       	ldd	r31, Y+2	; 0x02
   17c70:	09 95       	icall
   asm volatile( "pop r21" "\n\t"
   17c72:	5f 91       	pop	r21
   17c74:	4f 91       	pop	r20
   17c76:	24 96       	adiw	r28, 0x04	; 4
   17c78:	0f b6       	in	r0, 0x3f	; 63
   17c7a:	f8 94       	cli
   17c7c:	de bf       	out	0x3e, r29	; 62
   17c7e:	0f be       	out	0x3f, r0	; 63
   17c80:	cd bf       	out	0x3d, r28	; 61
   17c82:	df 91       	pop	r29
   17c84:	cf 91       	pop	r28
   17c86:	08 95       	ret

00017c88 <Barrier_block>:
	             "pop r20" "\n\t"
	              ::);
   return;  
}



 


void Barrier_block(uint8_t type, uint8_t id){
   17c88:	cf 93       	push	r28
   17c8a:	df 93       	push	r29
   17c8c:	cd b7       	in	r28, 0x3d	; 61
   17c8e:	de b7       	in	r29, 0x3e	; 62
   17c90:	25 97       	sbiw	r28, 0x05	; 5
   17c92:	0f b6       	in	r0, 0x3f	; 63
   17c94:	f8 94       	cli
   17c96:	de bf       	out	0x3e, r29	; 62
   17c98:	0f be       	out	0x3f, r0	; 63
   17c9a:	cd bf       	out	0x3d, r28	; 61
   17c9c:	8c 83       	std	Y+4, r24	; 0x04
   17c9e:	6d 83       	std	Y+5, r22	; 0x05
   
    _atomic_t currentatomic;
	thread **current_thread; 

     
	current_thread = getCurrentThread(); 
   17ca0:	0e 94 74 c5 	call	0x18ae8
   17ca4:	9a 83       	std	Y+2, r25	; 0x02
   17ca6:	89 83       	std	Y+1, r24	; 0x01

    currentatomic = _atomic_start();
   17ca8:	0e 94 d6 c4 	call	0x189ac
   17cac:	8b 83       	std	Y+3, r24	; 0x03
    
      (*current_thread)->state = STATE_IO;
   17cae:	e9 81       	ldd	r30, Y+1	; 0x01
   17cb0:	fa 81       	ldd	r31, Y+2	; 0x02
   17cb2:	01 90       	ld	r0, Z+
   17cb4:	f0 81       	ld	r31, Z
   17cb6:	e0 2d       	mov	r30, r0
   17cb8:	86 e0       	ldi	r24, 0x06	; 6
   17cba:	82 83       	std	Z+2, r24	; 0x02
      (*current_thread)->data.iostate.type = type;
   17cbc:	e9 81       	ldd	r30, Y+1	; 0x01
   17cbe:	fa 81       	ldd	r31, Y+2	; 0x02
   17cc0:	01 90       	ld	r0, Z+
   17cc2:	f0 81       	ld	r31, Z
   17cc4:	e0 2d       	mov	r30, r0
   17cc6:	8c 81       	ldd	r24, Y+4	; 0x04
   17cc8:	83 8f       	std	Z+27, r24	; 0x1b
      (*current_thread)->data.iostate.id = id;
   17cca:	e9 81       	ldd	r30, Y+1	; 0x01
   17ccc:	fa 81       	ldd	r31, Y+2	; 0x02
   17cce:	01 90       	ld	r0, Z+
   17cd0:	f0 81       	ld	r31, Z
   17cd2:	e0 2d       	mov	r30, r0
   17cd4:	8d 81       	ldd	r24, Y+5	; 0x05
   17cd6:	84 8f       	std	Z+28, r24	; 0x1c
      yield();
   17cd8:	0e 94 2b c6 	call	0x18c56
    
    _atomic_end(currentatomic);
   17cdc:	8b 81       	ldd	r24, Y+3	; 0x03
   17cde:	0e 94 f0 c4 	call	0x189e0
   17ce2:	25 96       	adiw	r28, 0x05	; 5
   17ce4:	0f b6       	in	r0, 0x3f	; 63
   17ce6:	f8 94       	cli
   17ce8:	de bf       	out	0x3e, r29	; 62
   17cea:	0f be       	out	0x3f, r0	; 63
   17cec:	cd bf       	out	0x3d, r28	; 61
   17cee:	df 91       	pop	r29
   17cf0:	cf 91       	pop	r28
   17cf2:	08 95       	ret

00017cf4 <getRadioMutexAddress>:
}



mutex *getRadioMutexAddress()
{
   17cf4:	cf 93       	push	r28
   17cf6:	df 93       	push	r29
   17cf8:	cd b7       	in	r28, 0x3d	; 61
   17cfa:	de b7       	in	r29, 0x3e	; 62
   17cfc:	24 97       	sbiw	r28, 0x04	; 4
   17cfe:	0f b6       	in	r0, 0x3f	; 63
   17d00:	f8 94       	cli
   17d02:	de bf       	out	0x3e, r29	; 62
   17d04:	0f be       	out	0x3f, r0	; 63
   17d06:	cd bf       	out	0x3d, r28	; 61
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GET_RADIO_MUTEX_ADDRESS_FUNCTION; 
   17d08:	80 e1       	ldi	r24, 0x10	; 16
   17d0a:	9a ee       	ldi	r25, 0xEA	; 234
   17d0c:	9a 83       	std	Y+2, r25	; 0x02
   17d0e:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   17d10:	4f 93       	push	r20
   17d12:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   17d14:	e9 81       	ldd	r30, Y+1	; 0x01
   17d16:	fa 81       	ldd	r31, Y+2	; 0x02
   17d18:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17d1a:	84 2f       	mov	r24, r20
   17d1c:	95 2f       	mov	r25, r21
   17d1e:	9c 83       	std	Y+4, r25	; 0x04
   17d20:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17d22:	5f 91       	pop	r21
   17d24:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return msend; 
   17d26:	8b 81       	ldd	r24, Y+3	; 0x03
   17d28:	9c 81       	ldd	r25, Y+4	; 0x04
   17d2a:	24 96       	adiw	r28, 0x04	; 4
   17d2c:	0f b6       	in	r0, 0x3f	; 63
   17d2e:	f8 94       	cli
   17d30:	de bf       	out	0x3e, r29	; 62
   17d32:	0f be       	out	0x3f, r0	; 63
   17d34:	cd bf       	out	0x3d, r28	; 61
   17d36:	df 91       	pop	r29
   17d38:	cf 91       	pop	r28
   17d3a:	08 95       	ret

00017d3c <getSerialMutexAddress>:
}
 


mutex *getSerialMutexAddress()
{
   17d3c:	cf 93       	push	r28
   17d3e:	df 93       	push	r29
   17d40:	cd b7       	in	r28, 0x3d	; 61
   17d42:	de b7       	in	r29, 0x3e	; 62
   17d44:	24 97       	sbiw	r28, 0x04	; 4
   17d46:	0f b6       	in	r0, 0x3f	; 63
   17d48:	f8 94       	cli
   17d4a:	de bf       	out	0x3e, r29	; 62
   17d4c:	0f be       	out	0x3f, r0	; 63
   17d4e:	cd bf       	out	0x3d, r28	; 61
   mutex *msend;   

   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_MUTEX_ADDRESS_FUNCTION;
   17d50:	80 e9       	ldi	r24, 0x90	; 144
   17d52:	9a ee       	ldi	r25, 0xEA	; 234
   17d54:	9a 83       	std	Y+2, r25	; 0x02
   17d56:	89 83       	std	Y+1, r24	; 0x01
   
   asm volatile("push r20" "\n\t"
   17d58:	4f 93       	push	r20
   17d5a:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   17d5c:	e9 81       	ldd	r30, Y+1	; 0x01
   17d5e:	fa 81       	ldd	r31, Y+2	; 0x02
   17d60:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17d62:	84 2f       	mov	r24, r20
   17d64:	95 2f       	mov	r25, r21
   17d66:	9c 83       	std	Y+4, r25	; 0x04
   17d68:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
   asm volatile("pop r21" "\n\t"
   17d6a:	5f 91       	pop	r21
   17d6c:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return msend; 
   17d6e:	8b 81       	ldd	r24, Y+3	; 0x03
   17d70:	9c 81       	ldd	r25, Y+4	; 0x04
   17d72:	24 96       	adiw	r28, 0x04	; 4
   17d74:	0f b6       	in	r0, 0x3f	; 63
   17d76:	f8 94       	cli
   17d78:	de bf       	out	0x3e, r29	; 62
   17d7a:	0f be       	out	0x3f, r0	; 63
   17d7c:	cd bf       	out	0x3d, r28	; 61
   17d7e:	df 91       	pop	r29
   17d80:	cf 91       	pop	r28
   17d82:	08 95       	ret

00017d84 <getFileMutexAddress>:
}
 



mutex *getFileMutexAddress()
{
   17d84:	cf 93       	push	r28
   17d86:	df 93       	push	r29
   17d88:	cd b7       	in	r28, 0x3d	; 61
   17d8a:	de b7       	in	r29, 0x3e	; 62
   17d8c:	24 97       	sbiw	r28, 0x04	; 4
   17d8e:	0f b6       	in	r0, 0x3f	; 63
   17d90:	f8 94       	cli
   17d92:	de bf       	out	0x3e, r29	; 62
   17d94:	0f be       	out	0x3f, r0	; 63
   17d96:	cd bf       	out	0x3d, r28	; 61
   mutex *mfile;   
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_MUTEX_ADDRESS; 
   17d98:	88 e2       	ldi	r24, 0x28	; 40
   17d9a:	9a ee       	ldi	r25, 0xEA	; 234
   17d9c:	9a 83       	std	Y+2, r25	; 0x02
   17d9e:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   17da0:	4f 93       	push	r20
   17da2:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   17da4:	e9 81       	ldd	r30, Y+1	; 0x01
   17da6:	fa 81       	ldd	r31, Y+2	; 0x02
   17da8:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17daa:	84 2f       	mov	r24, r20
   17dac:	95 2f       	mov	r25, r21
   17dae:	9c 83       	std	Y+4, r25	; 0x04
   17db0:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (mfile)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17db2:	5f 91       	pop	r21
   17db4:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return mfile; 
   17db6:	8b 81       	ldd	r24, Y+3	; 0x03
   17db8:	9c 81       	ldd	r25, Y+4	; 0x04
   17dba:	24 96       	adiw	r28, 0x04	; 4
   17dbc:	0f b6       	in	r0, 0x3f	; 63
   17dbe:	f8 94       	cli
   17dc0:	de bf       	out	0x3e, r29	; 62
   17dc2:	0f be       	out	0x3f, r0	; 63
   17dc4:	cd bf       	out	0x3d, r28	; 61
   17dc6:	df 91       	pop	r29
   17dc8:	cf 91       	pop	r28
   17dca:	08 95       	ret

00017dcc <sendRadioMsg>:

thread* mythread;

void sendRadioMsg()
{
   17dcc:	cf 93       	push	r28
   17dce:	df 93       	push	r29
   17dd0:	cd b7       	in	r28, 0x3d	; 61
   17dd2:	de b7       	in	r29, 0x3e	; 62
   17dd4:	22 97       	sbiw	r28, 0x02	; 2
   17dd6:	0f b6       	in	r0, 0x3f	; 63
   17dd8:	f8 94       	cli
   17dda:	de bf       	out	0x3e, r29	; 62
   17ddc:	0f be       	out	0x3f, r0	; 63
   17dde:	cd bf       	out	0x3d, r28	; 61
 void (*radiosendfp)() = (void (*)(void))SOCKET_RADIO_SEND_FUNCTION;
   17de0:	84 e1       	ldi	r24, 0x14	; 20
   17de2:	9a ee       	ldi	r25, 0xEA	; 234
   17de4:	9a 83       	std	Y+2, r25	; 0x02
   17de6:	89 83       	std	Y+1, r24	; 0x01
 radiosendfp();
   17de8:	e9 81       	ldd	r30, Y+1	; 0x01
   17dea:	fa 81       	ldd	r31, Y+2	; 0x02
   17dec:	09 95       	icall
   17dee:	22 96       	adiw	r28, 0x02	; 2
   17df0:	0f b6       	in	r0, 0x3f	; 63
   17df2:	f8 94       	cli
   17df4:	de bf       	out	0x3e, r29	; 62
   17df6:	0f be       	out	0x3f, r0	; 63
   17df8:	cd bf       	out	0x3d, r28	; 61
   17dfa:	df 91       	pop	r29
   17dfc:	cf 91       	pop	r28
   17dfe:	08 95       	ret

00017e00 <radioSend_string>:
}



//This function sends out a string

void radioSend_string(uint8_t *msg)
{
   17e00:	cf 93       	push	r28
   17e02:	df 93       	push	r29
   17e04:	cd b7       	in	r28, 0x3d	; 61
   17e06:	de b7       	in	r29, 0x3e	; 62
   17e08:	23 97       	sbiw	r28, 0x03	; 3
   17e0a:	0f b6       	in	r0, 0x3f	; 63
   17e0c:	f8 94       	cli
   17e0e:	de bf       	out	0x3e, r29	; 62
   17e10:	0f be       	out	0x3f, r0	; 63
   17e12:	cd bf       	out	0x3d, r28	; 61
   17e14:	9b 83       	std	Y+3, r25	; 0x03
   17e16:	8a 83       	std	Y+2, r24	; 0x02

    uint8_t temp = (uint8_t)String_length((char *)msg);
   17e18:	8a 81       	ldd	r24, Y+2	; 0x02
   17e1a:	9b 81       	ldd	r25, Y+3	; 0x03
   17e1c:	0e 94 2b c3 	call	0x18656
   17e20:	89 83       	std	Y+1, r24	; 0x01
	return radioSend(1, 0xffff, temp, msg);
   17e22:	8a 81       	ldd	r24, Y+2	; 0x02
   17e24:	9b 81       	ldd	r25, Y+3	; 0x03
   17e26:	9c 01       	movw	r18, r24
   17e28:	49 81       	ldd	r20, Y+1	; 0x01
   17e2a:	6f ef       	ldi	r22, 0xFF	; 255
   17e2c:	7f ef       	ldi	r23, 0xFF	; 255
   17e2e:	81 e0       	ldi	r24, 0x01	; 1
   17e30:	90 e0       	ldi	r25, 0x00	; 0
   17e32:	0e 94 2b c0 	call	0x18056
   17e36:	23 96       	adiw	r28, 0x03	; 3
   17e38:	0f b6       	in	r0, 0x3f	; 63
   17e3a:	f8 94       	cli
   17e3c:	de bf       	out	0x3e, r29	; 62
   17e3e:	0f be       	out	0x3f, r0	; 63
   17e40:	cd bf       	out	0x3d, r28	; 61
   17e42:	df 91       	pop	r29
   17e44:	cf 91       	pop	r28
   17e46:	08 95       	ret

00017e48 <radioSend_uint16>:


}





void radioSend_uint16(uint16_t value)
{
   17e48:	cf 93       	push	r28
   17e4a:	df 93       	push	r29
   17e4c:	cd b7       	in	r28, 0x3d	; 61
   17e4e:	de b7       	in	r29, 0x3e	; 62
   17e50:	24 97       	sbiw	r28, 0x04	; 4
   17e52:	0f b6       	in	r0, 0x3f	; 63
   17e54:	f8 94       	cli
   17e56:	de bf       	out	0x3e, r29	; 62
   17e58:	0f be       	out	0x3f, r0	; 63
   17e5a:	cd bf       	out	0x3d, r28	; 61
   17e5c:	9c 83       	std	Y+4, r25	; 0x04
   17e5e:	8b 83       	std	Y+3, r24	; 0x03
  uint8_t temp1,temp2;
  temp1 = (uint8_t) (value >> 8);
   17e60:	8b 81       	ldd	r24, Y+3	; 0x03
   17e62:	9c 81       	ldd	r25, Y+4	; 0x04
   17e64:	89 2f       	mov	r24, r25
   17e66:	99 27       	eor	r25, r25
   17e68:	8a 83       	std	Y+2, r24	; 0x02
  temp2 = (uint8_t) (value & 0x00ff);
   17e6a:	8b 81       	ldd	r24, Y+3	; 0x03
   17e6c:	89 83       	std	Y+1, r24	; 0x01

  buffer[0] = temp1;
   17e6e:	8a 81       	ldd	r24, Y+2	; 0x02
   17e70:	80 93 81 0a 	sts	0x0A81, r24
  buffer[1] = temp2;
   17e74:	89 81       	ldd	r24, Y+1	; 0x01
   17e76:	80 93 82 0a 	sts	0x0A82, r24
  buffer[2] = buffer[3] = 0xee;
   17e7a:	8e ee       	ldi	r24, 0xEE	; 238
   17e7c:	80 93 84 0a 	sts	0x0A84, r24
   17e80:	80 91 84 0a 	lds	r24, 0x0A84
   17e84:	80 93 83 0a 	sts	0x0A83, r24

  return radioSend(12, 0xffff, 16, buffer);
   17e88:	81 e8       	ldi	r24, 0x81	; 129
   17e8a:	9a e0       	ldi	r25, 0x0A	; 10
   17e8c:	9c 01       	movw	r18, r24
   17e8e:	40 e1       	ldi	r20, 0x10	; 16
   17e90:	6f ef       	ldi	r22, 0xFF	; 255
   17e92:	7f ef       	ldi	r23, 0xFF	; 255
   17e94:	8c e0       	ldi	r24, 0x0C	; 12
   17e96:	90 e0       	ldi	r25, 0x00	; 0
   17e98:	0e 94 2b c0 	call	0x18056
   17e9c:	24 96       	adiw	r28, 0x04	; 4
   17e9e:	0f b6       	in	r0, 0x3f	; 63
   17ea0:	f8 94       	cli
   17ea2:	de bf       	out	0x3e, r29	; 62
   17ea4:	0f be       	out	0x3f, r0	; 63
   17ea6:	cd bf       	out	0x3d, r28	; 61
   17ea8:	df 91       	pop	r29
   17eaa:	cf 91       	pop	r28
   17eac:	08 95       	ret

00017eae <getCurrentRadioHandleAddr>:

}




radiohandletype *getCurrentRadioHandleAddr()
{
   17eae:	cf 93       	push	r28
   17eb0:	df 93       	push	r29
   17eb2:	cd b7       	in	r28, 0x3d	; 61
   17eb4:	de b7       	in	r29, 0x3e	; 62
   17eb6:	24 97       	sbiw	r28, 0x04	; 4
   17eb8:	0f b6       	in	r0, 0x3f	; 63
   17eba:	f8 94       	cli
   17ebc:	de bf       	out	0x3e, r29	; 62
   17ebe:	0f be       	out	0x3f, r0	; 63
   17ec0:	cd bf       	out	0x3d, r28	; 61
   radiohandletype *currentradioinfo;

   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_HANDLE_ADDR;
   17ec2:	80 e6       	ldi	r24, 0x60	; 96
   17ec4:	9a ee       	ldi	r25, 0xEA	; 234
   17ec6:	9a 83       	std	Y+2, r25	; 0x02
   17ec8:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   17eca:	4f 93       	push	r20
   17ecc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   17ece:	e9 81       	ldd	r30, Y+1	; 0x01
   17ed0:	fa 81       	ldd	r31, Y+2	; 0x02
   17ed2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17ed4:	84 2f       	mov	r24, r20
   17ed6:	95 2f       	mov	r25, r21
   17ed8:	9c 83       	std	Y+4, r25	; 0x04
   17eda:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17edc:	5f 91       	pop	r21
   17ede:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo;
   17ee0:	8b 81       	ldd	r24, Y+3	; 0x03
   17ee2:	9c 81       	ldd	r25, Y+4	; 0x04
   17ee4:	24 96       	adiw	r28, 0x04	; 4
   17ee6:	0f b6       	in	r0, 0x3f	; 63
   17ee8:	f8 94       	cli
   17eea:	de bf       	out	0x3e, r29	; 62
   17eec:	0f be       	out	0x3f, r0	; 63
   17eee:	cd bf       	out	0x3d, r28	; 61
   17ef0:	df 91       	pop	r29
   17ef2:	cf 91       	pop	r28
   17ef4:	08 95       	ret

00017ef6 <setRadioFreq>:
}


void setRadioFreq(uint16_t freq)
{
   17ef6:	cf 93       	push	r28
   17ef8:	df 93       	push	r29
   17efa:	cd b7       	in	r28, 0x3d	; 61
   17efc:	de b7       	in	r29, 0x3e	; 62
   17efe:	24 97       	sbiw	r28, 0x04	; 4
   17f00:	0f b6       	in	r0, 0x3f	; 63
   17f02:	f8 94       	cli
   17f04:	de bf       	out	0x3e, r29	; 62
   17f06:	0f be       	out	0x3f, r0	; 63
   17f08:	cd bf       	out	0x3d, r28	; 61
   17f0a:	9c 83       	std	Y+4, r25	; 0x04
   17f0c:	8b 83       	std	Y+3, r24	; 0x03

   void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_FREQ_FUNCTION;
   17f0e:	80 ec       	ldi	r24, 0xC0	; 192
   17f10:	9a ee       	ldi	r25, 0xEA	; 234
   17f12:	9a 83       	std	Y+2, r25	; 0x02
   17f14:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   17f16:	4f 93       	push	r20
   17f18:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);

   asm volatile(" mov r20, %A0" "\n\t"
   17f1a:	8b 81       	ldd	r24, Y+3	; 0x03
   17f1c:	9c 81       	ldd	r25, Y+4	; 0x04
   17f1e:	48 2f       	mov	r20, r24
   17f20:	59 2f       	mov	r21, r25
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (freq)
                );
   getaddrfp();
   17f22:	e9 81       	ldd	r30, Y+1	; 0x01
   17f24:	fa 81       	ldd	r31, Y+2	; 0x02
   17f26:	09 95       	icall
   asm volatile("pop r21" "\n\t"
   17f28:	5f 91       	pop	r21
   17f2a:	4f 91       	pop	r20
   17f2c:	24 96       	adiw	r28, 0x04	; 4
   17f2e:	0f b6       	in	r0, 0x3f	; 63
   17f30:	f8 94       	cli
   17f32:	de bf       	out	0x3e, r29	; 62
   17f34:	0f be       	out	0x3f, r0	; 63
   17f36:	cd bf       	out	0x3d, r28	; 61
   17f38:	df 91       	pop	r29
   17f3a:	cf 91       	pop	r28
   17f3c:	08 95       	ret

00017f3e <setRadioChannel>:
	             "pop r20" "\n\t"
	              ::);
   return;
}

void setRadioChannel(uint8_t channel)
{
   17f3e:	cf 93       	push	r28
   17f40:	df 93       	push	r29
   17f42:	cd b7       	in	r28, 0x3d	; 61
   17f44:	de b7       	in	r29, 0x3e	; 62
   17f46:	25 97       	sbiw	r28, 0x05	; 5
   17f48:	0f b6       	in	r0, 0x3f	; 63
   17f4a:	f8 94       	cli
   17f4c:	de bf       	out	0x3e, r29	; 62
   17f4e:	0f be       	out	0x3f, r0	; 63
   17f50:	cd bf       	out	0x3d, r28	; 61
   17f52:	8d 83       	std	Y+5, r24	; 0x05

  uint16_t maskchannel = channel;
   17f54:	8d 81       	ldd	r24, Y+5	; 0x05
   17f56:	99 27       	eor	r25, r25
   17f58:	9c 83       	std	Y+4, r25	; 0x04
   17f5a:	8b 83       	std	Y+3, r24	; 0x03

  void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_CHANNEL_FUNCTION;
   17f5c:	84 ec       	ldi	r24, 0xC4	; 196
   17f5e:	9a ee       	ldi	r25, 0xEA	; 234
   17f60:	9a 83       	std	Y+2, r25	; 0x02
   17f62:	89 83       	std	Y+1, r24	; 0x01

  asm volatile("push r20" "\n\t"
   17f64:	4f 93       	push	r20
   17f66:	5f 93       	push	r21
               "push r21" "\n\t"
               ::);

  asm volatile(" mov r20, %A0" "\n\t"
   17f68:	8b 81       	ldd	r24, Y+3	; 0x03
   17f6a:	9c 81       	ldd	r25, Y+4	; 0x04
   17f6c:	48 2f       	mov	r20, r24
   17f6e:	59 2f       	mov	r21, r25
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp();
   17f70:	e9 81       	ldd	r30, Y+1	; 0x01
   17f72:	fa 81       	ldd	r31, Y+2	; 0x02
   17f74:	09 95       	icall
   asm volatile("pop r21" "\n\t"
   17f76:	5f 91       	pop	r21
   17f78:	4f 91       	pop	r20
   17f7a:	25 96       	adiw	r28, 0x05	; 5
   17f7c:	0f b6       	in	r0, 0x3f	; 63
   17f7e:	f8 94       	cli
   17f80:	de bf       	out	0x3e, r29	; 62
   17f82:	0f be       	out	0x3f, r0	; 63
   17f84:	cd bf       	out	0x3d, r28	; 61
   17f86:	df 91       	pop	r29
   17f88:	cf 91       	pop	r28
   17f8a:	08 95       	ret

00017f8c <setRadioPower>:
	             "pop r20" "\n\t"
	              ::);
   return;
}

void setRadioPower(uint8_t power)
{
   17f8c:	cf 93       	push	r28
   17f8e:	df 93       	push	r29
   17f90:	cd b7       	in	r28, 0x3d	; 61
   17f92:	de b7       	in	r29, 0x3e	; 62
   17f94:	25 97       	sbiw	r28, 0x05	; 5
   17f96:	0f b6       	in	r0, 0x3f	; 63
   17f98:	f8 94       	cli
   17f9a:	de bf       	out	0x3e, r29	; 62
   17f9c:	0f be       	out	0x3f, r0	; 63
   17f9e:	cd bf       	out	0x3d, r28	; 61
   17fa0:	8d 83       	std	Y+5, r24	; 0x05

  uint16_t maskchannel = power;
   17fa2:	8d 81       	ldd	r24, Y+5	; 0x05
   17fa4:	99 27       	eor	r25, r25
   17fa6:	9c 83       	std	Y+4, r25	; 0x04
   17fa8:	8b 83       	std	Y+3, r24	; 0x03

  void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_POWER_FUNCTION;
   17faa:	88 ec       	ldi	r24, 0xC8	; 200
   17fac:	9a ee       	ldi	r25, 0xEA	; 234
   17fae:	9a 83       	std	Y+2, r25	; 0x02
   17fb0:	89 83       	std	Y+1, r24	; 0x01

  asm volatile("push r20" "\n\t"
   17fb2:	4f 93       	push	r20
   17fb4:	5f 93       	push	r21
               "push r21" "\n\t"
               ::);

  asm volatile(" mov r20, %A0" "\n\t"
   17fb6:	8b 81       	ldd	r24, Y+3	; 0x03
   17fb8:	9c 81       	ldd	r25, Y+4	; 0x04
   17fba:	48 2f       	mov	r20, r24
   17fbc:	59 2f       	mov	r21, r25
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp();
   17fbe:	e9 81       	ldd	r30, Y+1	; 0x01
   17fc0:	fa 81       	ldd	r31, Y+2	; 0x02
   17fc2:	09 95       	icall
   asm volatile("pop r21" "\n\t"
   17fc4:	5f 91       	pop	r21
   17fc6:	4f 91       	pop	r20
   17fc8:	25 96       	adiw	r28, 0x05	; 5
   17fca:	0f b6       	in	r0, 0x3f	; 63
   17fcc:	f8 94       	cli
   17fce:	de bf       	out	0x3e, r29	; 62
   17fd0:	0f be       	out	0x3f, r0	; 63
   17fd2:	cd bf       	out	0x3d, r28	; 61
   17fd4:	df 91       	pop	r29
   17fd6:	cf 91       	pop	r28
   17fd8:	08 95       	ret

00017fda <getCurrentRadioInfoAddr>:
	             "pop r20" "\n\t"
	              ::);
   return;
}



radioinfotype *getCurrentRadioInfoAddr()
{
   17fda:	cf 93       	push	r28
   17fdc:	df 93       	push	r29
   17fde:	cd b7       	in	r28, 0x3d	; 61
   17fe0:	de b7       	in	r29, 0x3e	; 62
   17fe2:	24 97       	sbiw	r28, 0x04	; 4
   17fe4:	0f b6       	in	r0, 0x3f	; 63
   17fe6:	f8 94       	cli
   17fe8:	de bf       	out	0x3e, r29	; 62
   17fea:	0f be       	out	0x3f, r0	; 63
   17fec:	cd bf       	out	0x3d, r28	; 61
   radioinfotype *currentradioinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_INFO_ADDR;
   17fee:	8c e5       	ldi	r24, 0x5C	; 92
   17ff0:	9a ee       	ldi	r25, 0xEA	; 234
   17ff2:	9a 83       	std	Y+2, r25	; 0x02
   17ff4:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   17ff6:	4f 93       	push	r20
   17ff8:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   17ffa:	e9 81       	ldd	r30, Y+1	; 0x01
   17ffc:	fa 81       	ldd	r31, Y+2	; 0x02
   17ffe:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18000:	84 2f       	mov	r24, r20
   18002:	95 2f       	mov	r25, r21
   18004:	9c 83       	std	Y+4, r25	; 0x04
   18006:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
   18008:	5f 91       	pop	r21
   1800a:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo;
   1800c:	8b 81       	ldd	r24, Y+3	; 0x03
   1800e:	9c 81       	ldd	r25, Y+4	; 0x04
   18010:	24 96       	adiw	r28, 0x04	; 4
   18012:	0f b6       	in	r0, 0x3f	; 63
   18014:	f8 94       	cli
   18016:	de bf       	out	0x3e, r29	; 62
   18018:	0f be       	out	0x3f, r0	; 63
   1801a:	cd bf       	out	0x3d, r28	; 61
   1801c:	df 91       	pop	r29
   1801e:	cf 91       	pop	r28
   18020:	08 95       	ret

00018022 <disableRadioState>:
}


void disableRadioState()
{
   18022:	cf 93       	push	r28
   18024:	df 93       	push	r29
   18026:	cd b7       	in	r28, 0x3d	; 61
   18028:	de b7       	in	r29, 0x3e	; 62
   1802a:	22 97       	sbiw	r28, 0x02	; 2
   1802c:	0f b6       	in	r0, 0x3f	; 63
   1802e:	f8 94       	cli
   18030:	de bf       	out	0x3e, r29	; 62
   18032:	0f be       	out	0x3f, r0	; 63
   18034:	cd bf       	out	0x3d, r28	; 61

   void (*disableradiofp)(void) = (void (*)(void))RESTORE_RADIO_STATE;
   18036:	88 eb       	ldi	r24, 0xB8	; 184
   18038:	9a ee       	ldi	r25, 0xEA	; 234
   1803a:	9a 83       	std	Y+2, r25	; 0x02
   1803c:	89 83       	std	Y+1, r24	; 0x01

   disableradiofp();
   1803e:	e9 81       	ldd	r30, Y+1	; 0x01
   18040:	fa 81       	ldd	r31, Y+2	; 0x02
   18042:	09 95       	icall
   18044:	22 96       	adiw	r28, 0x02	; 2
   18046:	0f b6       	in	r0, 0x3f	; 63
   18048:	f8 94       	cli
   1804a:	de bf       	out	0x3e, r29	; 62
   1804c:	0f be       	out	0x3f, r0	; 63
   1804e:	cd bf       	out	0x3d, r28	; 61
   18050:	df 91       	pop	r29
   18052:	cf 91       	pop	r28
   18054:	08 95       	ret

00018056 <radioSend>:

   return;
}


void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
   18056:	cf 93       	push	r28
   18058:	df 93       	push	r29
   1805a:	cd b7       	in	r28, 0x3d	; 61
   1805c:	de b7       	in	r29, 0x3e	; 62
   1805e:	2d 97       	sbiw	r28, 0x0d	; 13
   18060:	0f b6       	in	r0, 0x3f	; 63
   18062:	f8 94       	cli
   18064:	de bf       	out	0x3e, r29	; 62
   18066:	0f be       	out	0x3f, r0	; 63
   18068:	cd bf       	out	0x3d, r28	; 61
   1806a:	98 87       	std	Y+8, r25	; 0x08
   1806c:	8f 83       	std	Y+7, r24	; 0x07
   1806e:	7a 87       	std	Y+10, r23	; 0x0a
   18070:	69 87       	std	Y+9, r22	; 0x09
   18072:	4b 87       	std	Y+11, r20	; 0x0b
   18074:	3d 87       	std	Y+13, r19	; 0x0d
   18076:	2c 87       	std	Y+12, r18	; 0x0c


   mutex* msend;
   thread** current_thread;
   radioinfotype *radioinfoaddr;



   msend = getRadioMutexAddress();
   18078:	0e 94 7a be 	call	0x17cf4
   1807c:	9e 83       	std	Y+6, r25	; 0x06
   1807e:	8d 83       	std	Y+5, r24	; 0x05
   current_thread = getCurrentThread();
   18080:	0e 94 74 c5 	call	0x18ae8
   18084:	9c 83       	std	Y+4, r25	; 0x04
   18086:	8b 83       	std	Y+3, r24	; 0x03
   radioinfoaddr = getCurrentRadioInfoAddr();
   18088:	0e 94 ed bf 	call	0x17fda
   1808c:	9a 83       	std	Y+2, r25	; 0x02
   1808e:	89 83       	std	Y+1, r24	; 0x01

   Mutex_lock(msend);
   18090:	8d 81       	ldd	r24, Y+5	; 0x05
   18092:	9e 81       	ldd	r25, Y+6	; 0x06
   18094:	0e 94 d1 bd 	call	0x17ba2

   radioinfoaddr-> socket_port = port;
   18098:	e9 81       	ldd	r30, Y+1	; 0x01
   1809a:	fa 81       	ldd	r31, Y+2	; 0x02
   1809c:	8f 81       	ldd	r24, Y+7	; 0x07
   1809e:	98 85       	ldd	r25, Y+8	; 0x08
   180a0:	91 83       	std	Z+1, r25	; 0x01
   180a2:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address;
   180a4:	e9 81       	ldd	r30, Y+1	; 0x01
   180a6:	fa 81       	ldd	r31, Y+2	; 0x02
   180a8:	89 85       	ldd	r24, Y+9	; 0x09
   180aa:	9a 85       	ldd	r25, Y+10	; 0x0a
   180ac:	93 83       	std	Z+3, r25	; 0x03
   180ae:	82 83       	std	Z+2, r24	; 0x02
   radioinfoaddr->socket_msg_len  = length;
   180b0:	e9 81       	ldd	r30, Y+1	; 0x01
   180b2:	fa 81       	ldd	r31, Y+2	; 0x02
   180b4:	8b 85       	ldd	r24, Y+11	; 0x0b
   180b6:	84 83       	std	Z+4, r24	; 0x04
   radioinfoaddr->socket_msg  = msg;
   180b8:	e9 81       	ldd	r30, Y+1	; 0x01
   180ba:	fa 81       	ldd	r31, Y+2	; 0x02
   180bc:	8c 85       	ldd	r24, Y+12	; 0x0c
   180be:	9d 85       	ldd	r25, Y+13	; 0x0d
   180c0:	96 83       	std	Z+6, r25	; 0x06
   180c2:	85 83       	std	Z+5, r24	; 0x05

   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg();
   180c4:	0e 94 e6 be 	call	0x17dcc

   sleepThread(6);
   180c8:	86 e0       	ldi	r24, 0x06	; 6
   180ca:	90 e0       	ldi	r25, 0x00	; 0
   180cc:	0e 94 e0 c5 	call	0x18bc0

   disableRadioState();
   180d0:	0e 94 11 c0 	call	0x18022


   Mutex_unlock(msend);
   180d4:	8d 81       	ldd	r24, Y+5	; 0x05
   180d6:	9e 81       	ldd	r25, Y+6	; 0x06
   180d8:	0e 94 20 be 	call	0x17c40
   180dc:	2d 96       	adiw	r28, 0x0d	; 13
   180de:	0f b6       	in	r0, 0x3f	; 63
   180e0:	f8 94       	cli
   180e2:	de bf       	out	0x3e, r29	; 62
   180e4:	0f be       	out	0x3f, r0	; 63
   180e6:	cd bf       	out	0x3d, r28	; 61
   180e8:	df 91       	pop	r29
   180ea:	cf 91       	pop	r28
   180ec:	08 95       	ret

000180ee <radioSend_string_experimental>:

   return;
}


void radioSend_string_experimental(uint8_t *msg)
{
   180ee:	cf 93       	push	r28
   180f0:	df 93       	push	r29
   180f2:	cd b7       	in	r28, 0x3d	; 61
   180f4:	de b7       	in	r29, 0x3e	; 62
   180f6:	23 97       	sbiw	r28, 0x03	; 3
   180f8:	0f b6       	in	r0, 0x3f	; 63
   180fa:	f8 94       	cli
   180fc:	de bf       	out	0x3e, r29	; 62
   180fe:	0f be       	out	0x3f, r0	; 63
   18100:	cd bf       	out	0x3d, r28	; 61
   18102:	9b 83       	std	Y+3, r25	; 0x03
   18104:	8a 83       	std	Y+2, r24	; 0x02

    uint8_t temp = (uint8_t)String_length((char *)msg);
   18106:	8a 81       	ldd	r24, Y+2	; 0x02
   18108:	9b 81       	ldd	r25, Y+3	; 0x03
   1810a:	0e 94 2b c3 	call	0x18656
   1810e:	89 83       	std	Y+1, r24	; 0x01
	return radioSend_Experimental(1, 0xffff, temp, msg);
   18110:	8a 81       	ldd	r24, Y+2	; 0x02
   18112:	9b 81       	ldd	r25, Y+3	; 0x03
   18114:	9c 01       	movw	r18, r24
   18116:	49 81       	ldd	r20, Y+1	; 0x01
   18118:	6f ef       	ldi	r22, 0xFF	; 255
   1811a:	7f ef       	ldi	r23, 0xFF	; 255
   1811c:	81 e0       	ldi	r24, 0x01	; 1
   1811e:	90 e0       	ldi	r25, 0x00	; 0
   18120:	0e 94 9b c0 	call	0x18136
   18124:	23 96       	adiw	r28, 0x03	; 3
   18126:	0f b6       	in	r0, 0x3f	; 63
   18128:	f8 94       	cli
   1812a:	de bf       	out	0x3e, r29	; 62
   1812c:	0f be       	out	0x3f, r0	; 63
   1812e:	cd bf       	out	0x3d, r28	; 61
   18130:	df 91       	pop	r29
   18132:	cf 91       	pop	r28
   18134:	08 95       	ret

00018136 <radioSend_Experimental>:


}




void radioSend_Experimental(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
   18136:	cf 93       	push	r28
   18138:	df 93       	push	r29
   1813a:	cd b7       	in	r28, 0x3d	; 61
   1813c:	de b7       	in	r29, 0x3e	; 62
   1813e:	2b 97       	sbiw	r28, 0x0b	; 11
   18140:	0f b6       	in	r0, 0x3f	; 63
   18142:	f8 94       	cli
   18144:	de bf       	out	0x3e, r29	; 62
   18146:	0f be       	out	0x3f, r0	; 63
   18148:	cd bf       	out	0x3d, r28	; 61
   1814a:	9e 83       	std	Y+6, r25	; 0x06
   1814c:	8d 83       	std	Y+5, r24	; 0x05
   1814e:	78 87       	std	Y+8, r23	; 0x08
   18150:	6f 83       	std	Y+7, r22	; 0x07
   18152:	49 87       	std	Y+9, r20	; 0x09
   18154:	3b 87       	std	Y+11, r19	; 0x0b
   18156:	2a 87       	std	Y+10, r18	; 0x0a


   mutex* msend;
   radioinfotype *radioinfoaddr;


   msend = getRadioMutexAddress();
   18158:	0e 94 7a be 	call	0x17cf4
   1815c:	9c 83       	std	Y+4, r25	; 0x04
   1815e:	8b 83       	std	Y+3, r24	; 0x03
   radioinfoaddr = getCurrentRadioInfoAddr();
   18160:	0e 94 ed bf 	call	0x17fda
   18164:	9a 83       	std	Y+2, r25	; 0x02
   18166:	89 83       	std	Y+1, r24	; 0x01


   radioinfoaddr-> socket_port = port;
   18168:	e9 81       	ldd	r30, Y+1	; 0x01
   1816a:	fa 81       	ldd	r31, Y+2	; 0x02
   1816c:	8d 81       	ldd	r24, Y+5	; 0x05
   1816e:	9e 81       	ldd	r25, Y+6	; 0x06
   18170:	91 83       	std	Z+1, r25	; 0x01
   18172:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address;
   18174:	e9 81       	ldd	r30, Y+1	; 0x01
   18176:	fa 81       	ldd	r31, Y+2	; 0x02
   18178:	8f 81       	ldd	r24, Y+7	; 0x07
   1817a:	98 85       	ldd	r25, Y+8	; 0x08
   1817c:	93 83       	std	Z+3, r25	; 0x03
   1817e:	82 83       	std	Z+2, r24	; 0x02
   radioinfoaddr->socket_msg_len  = length;
   18180:	e9 81       	ldd	r30, Y+1	; 0x01
   18182:	fa 81       	ldd	r31, Y+2	; 0x02
   18184:	89 85       	ldd	r24, Y+9	; 0x09
   18186:	84 83       	std	Z+4, r24	; 0x04
   radioinfoaddr->socket_msg  = msg;
   18188:	e9 81       	ldd	r30, Y+1	; 0x01
   1818a:	fa 81       	ldd	r31, Y+2	; 0x02
   1818c:	8a 85       	ldd	r24, Y+10	; 0x0a
   1818e:	9b 85       	ldd	r25, Y+11	; 0x0b
   18190:	96 83       	std	Z+6, r25	; 0x06
   18192:	85 83       	std	Z+5, r24	; 0x05

   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   
   disableRadioState();
   18194:	0e 94 11 c0 	call	0x18022
   sendRadioMsg();
   18198:	0e 94 e6 be 	call	0x17dcc
   1819c:	2b 96       	adiw	r28, 0x0b	; 11
   1819e:	0f b6       	in	r0, 0x3f	; 63
   181a0:	f8 94       	cli
   181a2:	de bf       	out	0x3e, r29	; 62
   181a4:	0f be       	out	0x3f, r0	; 63
   181a6:	cd bf       	out	0x3d, r28	; 61
   181a8:	df 91       	pop	r29
   181aa:	cf 91       	pop	r28
   181ac:	08 95       	ret

000181ae <wakeupMe>:


   return;
}

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
   181ae:	cf 93       	push	r28
   181b0:	df 93       	push	r29
   181b2:	cd b7       	in	r28, 0x3d	; 61
   181b4:	de b7       	in	r29, 0x3e	; 62
  mythread->state = STATE_ACTIVE;
   181b6:	e0 91 75 0a 	lds	r30, 0x0A75
   181ba:	f0 91 76 0a 	lds	r31, 0x0A76
   181be:	82 e0       	ldi	r24, 0x02	; 2
   181c0:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   181c2:	0e 94 45 c6 	call	0x18c8a
   181c6:	df 91       	pop	r29
   181c8:	cf 91       	pop	r28
   181ca:	08 95       	ret

000181cc <radioReceive>:


}





int radioReceive(uint16_t port, uint8_t maxlength, uint8_t *msg)

{
   181cc:	cf 93       	push	r28
   181ce:	df 93       	push	r29
   181d0:	cd b7       	in	r28, 0x3d	; 61
   181d2:	de b7       	in	r29, 0x3e	; 62
   181d4:	2c 97       	sbiw	r28, 0x0c	; 12
   181d6:	0f b6       	in	r0, 0x3f	; 63
   181d8:	f8 94       	cli
   181da:	de bf       	out	0x3e, r29	; 62
   181dc:	0f be       	out	0x3f, r0	; 63
   181de:	cd bf       	out	0x3d, r28	; 61
   181e0:	99 87       	std	Y+9, r25	; 0x09
   181e2:	88 87       	std	Y+8, r24	; 0x08
   181e4:	6a 87       	std	Y+10, r22	; 0x0a
   181e6:	5c 87       	std	Y+12, r21	; 0x0c
   181e8:	4b 87       	std	Y+11, r20	; 0x0b


   thread** current_thread;

   _atomic_t currentatomic;


   radiohandletype *radiohandleaddr;


   void (*getaddrfp)(void) = (void (*)(void))REGISTER_RADIO_RECEIVE_EVENT;
   181ea:	84 e6       	ldi	r24, 0x64	; 100
   181ec:	9a ee       	ldi	r25, 0xEA	; 234
   181ee:	9a 83       	std	Y+2, r25	; 0x02
   181f0:	89 83       	std	Y+1, r24	; 0x01

   current_thread = getCurrentThread();
   181f2:	0e 94 74 c5 	call	0x18ae8
   181f6:	9f 83       	std	Y+7, r25	; 0x07
   181f8:	8e 83       	std	Y+6, r24	; 0x06

   radiohandleaddr = getCurrentRadioHandleAddr();
   181fa:	0e 94 57 bf 	call	0x17eae
   181fe:	9c 83       	std	Y+4, r25	; 0x04
   18200:	8b 83       	std	Y+3, r24	; 0x03

   //set up the radiohandleaddr data structures

   radiohandleaddr->port = port;
   18202:	eb 81       	ldd	r30, Y+3	; 0x03
   18204:	fc 81       	ldd	r31, Y+4	; 0x04
   18206:	88 85       	ldd	r24, Y+8	; 0x08
   18208:	99 85       	ldd	r25, Y+9	; 0x09
   1820a:	91 83       	std	Z+1, r25	; 0x01
   1820c:	80 83       	st	Z, r24
   radiohandleaddr->maxLength = maxlength;
   1820e:	eb 81       	ldd	r30, Y+3	; 0x03
   18210:	fc 81       	ldd	r31, Y+4	; 0x04
   18212:	8a 85       	ldd	r24, Y+10	; 0x0a
   18214:	82 83       	std	Z+2, r24	; 0x02
   radiohandleaddr->dataReady = &radioReceiveDataReady;
   18216:	eb 81       	ldd	r30, Y+3	; 0x03
   18218:	fc 81       	ldd	r31, Y+4	; 0x04
   1821a:	80 e8       	ldi	r24, 0x80	; 128
   1821c:	9a e0       	ldi	r25, 0x0A	; 10
   1821e:	94 83       	std	Z+4, r25	; 0x04
   18220:	83 83       	std	Z+3, r24	; 0x03
   radiohandleaddr->data = msg;
   18222:	eb 81       	ldd	r30, Y+3	; 0x03
   18224:	fc 81       	ldd	r31, Y+4	; 0x04
   18226:	8b 85       	ldd	r24, Y+11	; 0x0b
   18228:	9c 85       	ldd	r25, Y+12	; 0x0c
   1822a:	96 83       	std	Z+6, r25	; 0x06
   1822c:	85 83       	std	Z+5, r24	; 0x05
   radiohandleaddr->packetinfo = radioReceivePacketInfo;
   1822e:	eb 81       	ldd	r30, Y+3	; 0x03
   18230:	fc 81       	ldd	r31, Y+4	; 0x04
   18232:	81 ea       	ldi	r24, 0xA1	; 161
   18234:	9a e0       	ldi	r25, 0x0A	; 10
   18236:	90 87       	std	Z+8, r25	; 0x08
   18238:	87 83       	std	Z+7, r24	; 0x07
   radiohandleaddr->handlefunc = wakeupMe;
   1823a:	eb 81       	ldd	r30, Y+3	; 0x03
   1823c:	fc 81       	ldd	r31, Y+4	; 0x04
   1823e:	87 ed       	ldi	r24, 0xD7	; 215
   18240:	90 ec       	ldi	r25, 0xC0	; 192
   18242:	93 87       	std	Z+11, r25	; 0x0b
   18244:	82 87       	std	Z+10, r24	; 0x0a


   //close the interrupt
	currentatomic = _atomic_start();
   18246:	0e 94 d6 c4 	call	0x189ac
   1824a:	8d 83       	std	Y+5, r24	; 0x05

   //call the radio handle set to store the data structure into the handle vectors
    getaddrfp();
   1824c:	e9 81       	ldd	r30, Y+1	; 0x01
   1824e:	fa 81       	ldd	r31, Y+2	; 0x02
   18250:	09 95       	icall


   //set up the current thread into sleep mode
   (*current_thread)->state = STATE_SLEEP;
   18252:	ee 81       	ldd	r30, Y+6	; 0x06
   18254:	ff 81       	ldd	r31, Y+7	; 0x07
   18256:	01 90       	ld	r0, Z+
   18258:	f0 81       	ld	r31, Z
   1825a:	e0 2d       	mov	r30, r0
   1825c:	85 e0       	ldi	r24, 0x05	; 5
   1825e:	82 83       	std	Z+2, r24	; 0x02

   //set up mythread so that later can wake up this thread
   mythread = *current_thread;
   18260:	ee 81       	ldd	r30, Y+6	; 0x06
   18262:	ff 81       	ldd	r31, Y+7	; 0x07
   18264:	80 81       	ld	r24, Z
   18266:	91 81       	ldd	r25, Z+1	; 0x01
   18268:	90 93 76 0a 	sts	0x0A76, r25
   1826c:	80 93 75 0a 	sts	0x0A75, r24


   //open the interrupt
   _atomic_end(currentatomic);
   18270:	8d 81       	ldd	r24, Y+5	; 0x05
   18272:	0e 94 f0 c4 	call	0x189e0

    yield();
   18276:	0e 94 2b c6 	call	0x18c56


   return radioReceiveDataReady;
   1827a:	80 91 80 0a 	lds	r24, 0x0A80
   1827e:	99 27       	eor	r25, r25
   18280:	2c 96       	adiw	r28, 0x0c	; 12
   18282:	0f b6       	in	r0, 0x3f	; 63
   18284:	f8 94       	cli
   18286:	de bf       	out	0x3e, r29	; 62
   18288:	0f be       	out	0x3f, r0	; 63
   1828a:	cd bf       	out	0x3d, r28	; 61
   1828c:	df 91       	pop	r29
   1828e:	cf 91       	pop	r28
   18290:	08 95       	ret

00018292 <radioReceiveTimed>:

}

int radioReceiveTimed(uint16_t port, uint8_t maxlength, uint8_t *msg, uint16_t time)
{
   18292:	cf 93       	push	r28
   18294:	df 93       	push	r29
   18296:	cd b7       	in	r28, 0x3d	; 61
   18298:	de b7       	in	r29, 0x3e	; 62
   1829a:	2e 97       	sbiw	r28, 0x0e	; 14
   1829c:	0f b6       	in	r0, 0x3f	; 63
   1829e:	f8 94       	cli
   182a0:	de bf       	out	0x3e, r29	; 62
   182a2:	0f be       	out	0x3f, r0	; 63
   182a4:	cd bf       	out	0x3d, r28	; 61
   182a6:	99 87       	std	Y+9, r25	; 0x09
   182a8:	88 87       	std	Y+8, r24	; 0x08
   182aa:	6a 87       	std	Y+10, r22	; 0x0a
   182ac:	5c 87       	std	Y+12, r21	; 0x0c
   182ae:	4b 87       	std	Y+11, r20	; 0x0b
   182b0:	3e 87       	std	Y+14, r19	; 0x0e
   182b2:	2d 87       	std	Y+13, r18	; 0x0d
   thread** current_thread;

   _atomic_t currentatomic;


   radiohandletype *radiohandleaddr;
	

   void (*getaddrfp)(void) = (void (*)(void))REGISTER_RADIO_RECEIVE_EVENT;
   182b4:	84 e6       	ldi	r24, 0x64	; 100
   182b6:	9a ee       	ldi	r25, 0xEA	; 234
   182b8:	9a 83       	std	Y+2, r25	; 0x02
   182ba:	89 83       	std	Y+1, r24	; 0x01

   current_thread = getCurrentThread();
   182bc:	0e 94 74 c5 	call	0x18ae8
   182c0:	9f 83       	std	Y+7, r25	; 0x07
   182c2:	8e 83       	std	Y+6, r24	; 0x06

   radiohandleaddr = getCurrentRadioHandleAddr();
   182c4:	0e 94 57 bf 	call	0x17eae
   182c8:	9c 83       	std	Y+4, r25	; 0x04
   182ca:	8b 83       	std	Y+3, r24	; 0x03

   //set up the radiohandleaddr data structures

   radiohandleaddr->port = port;
   182cc:	eb 81       	ldd	r30, Y+3	; 0x03
   182ce:	fc 81       	ldd	r31, Y+4	; 0x04
   182d0:	88 85       	ldd	r24, Y+8	; 0x08
   182d2:	99 85       	ldd	r25, Y+9	; 0x09
   182d4:	91 83       	std	Z+1, r25	; 0x01
   182d6:	80 83       	st	Z, r24
   radiohandleaddr->maxLength = maxlength;
   182d8:	eb 81       	ldd	r30, Y+3	; 0x03
   182da:	fc 81       	ldd	r31, Y+4	; 0x04
   182dc:	8a 85       	ldd	r24, Y+10	; 0x0a
   182de:	82 83       	std	Z+2, r24	; 0x02
   radiohandleaddr->dataReady = &radioReceiveDataReady;
   182e0:	eb 81       	ldd	r30, Y+3	; 0x03
   182e2:	fc 81       	ldd	r31, Y+4	; 0x04
   182e4:	80 e8       	ldi	r24, 0x80	; 128
   182e6:	9a e0       	ldi	r25, 0x0A	; 10
   182e8:	94 83       	std	Z+4, r25	; 0x04
   182ea:	83 83       	std	Z+3, r24	; 0x03
   radiohandleaddr->data = msg;
   182ec:	eb 81       	ldd	r30, Y+3	; 0x03
   182ee:	fc 81       	ldd	r31, Y+4	; 0x04
   182f0:	8b 85       	ldd	r24, Y+11	; 0x0b
   182f2:	9c 85       	ldd	r25, Y+12	; 0x0c
   182f4:	96 83       	std	Z+6, r25	; 0x06
   182f6:	85 83       	std	Z+5, r24	; 0x05
   radiohandleaddr->packetinfo = radioReceivePacketInfo;
   182f8:	eb 81       	ldd	r30, Y+3	; 0x03
   182fa:	fc 81       	ldd	r31, Y+4	; 0x04
   182fc:	81 ea       	ldi	r24, 0xA1	; 161
   182fe:	9a e0       	ldi	r25, 0x0A	; 10
   18300:	90 87       	std	Z+8, r25	; 0x08
   18302:	87 83       	std	Z+7, r24	; 0x07
   radiohandleaddr->handlefunc = wakeupMe;
   18304:	eb 81       	ldd	r30, Y+3	; 0x03
   18306:	fc 81       	ldd	r31, Y+4	; 0x04
   18308:	87 ed       	ldi	r24, 0xD7	; 215
   1830a:	90 ec       	ldi	r25, 0xC0	; 192
   1830c:	93 87       	std	Z+11, r25	; 0x0b
   1830e:	82 87       	std	Z+10, r24	; 0x0a


   //close the interrupt
	currentatomic = _atomic_start();
   18310:	0e 94 d6 c4 	call	0x189ac
   18314:	8d 83       	std	Y+5, r24	; 0x05

   //call the radio handle set to store the data structure into the handle vectors
    getaddrfp();
   18316:	e9 81       	ldd	r30, Y+1	; 0x01
   18318:	fa 81       	ldd	r31, Y+2	; 0x02
   1831a:	09 95       	icall


   //set up the current thread into sleep mode
   (*current_thread)->state = STATE_SLEEP;
   1831c:	ee 81       	ldd	r30, Y+6	; 0x06
   1831e:	ff 81       	ldd	r31, Y+7	; 0x07
   18320:	01 90       	ld	r0, Z+
   18322:	f0 81       	ld	r31, Z
   18324:	e0 2d       	mov	r30, r0
   18326:	85 e0       	ldi	r24, 0x05	; 5
   18328:	82 83       	std	Z+2, r24	; 0x02

   //set up mythread so that later can wake up this thread
   mythread = *current_thread;
   1832a:	ee 81       	ldd	r30, Y+6	; 0x06
   1832c:	ff 81       	ldd	r31, Y+7	; 0x07
   1832e:	80 81       	ld	r24, Z
   18330:	91 81       	ldd	r25, Z+1	; 0x01
   18332:	90 93 76 0a 	sts	0x0A76, r25
   18336:	80 93 75 0a 	sts	0x0A75, r24


   //open the interrupt
   _atomic_end(currentatomic);
   1833a:	8d 81       	ldd	r24, Y+5	; 0x05
   1833c:	0e 94 f0 c4 	call	0x189e0

   sleepThread(time);
   18340:	8d 85       	ldd	r24, Y+13	; 0x0d
   18342:	9e 85       	ldd	r25, Y+14	; 0x0e
   18344:	0e 94 e0 c5 	call	0x18bc0

   return radioReceiveDataReady;
   18348:	80 91 80 0a 	lds	r24, 0x0A80
   1834c:	99 27       	eor	r25, r25
   1834e:	2e 96       	adiw	r28, 0x0e	; 14
   18350:	0f b6       	in	r0, 0x3f	; 63
   18352:	f8 94       	cli
   18354:	de bf       	out	0x3e, r29	; 62
   18356:	0f be       	out	0x3f, r0	; 63
   18358:	cd bf       	out	0x3d, r28	; 61
   1835a:	df 91       	pop	r29
   1835c:	cf 91       	pop	r28
   1835e:	08 95       	ret

00018360 <sendSerialMsg>:

thread* mythreadserial;

void sendSerialMsg()
{
   18360:	cf 93       	push	r28
   18362:	df 93       	push	r29
   18364:	cd b7       	in	r28, 0x3d	; 61
   18366:	de b7       	in	r29, 0x3e	; 62
   18368:	22 97       	sbiw	r28, 0x02	; 2
   1836a:	0f b6       	in	r0, 0x3f	; 63
   1836c:	f8 94       	cli
   1836e:	de bf       	out	0x3e, r29	; 62
   18370:	0f be       	out	0x3f, r0	; 63
   18372:	cd bf       	out	0x3d, r28	; 61
 void (*serialsendfp)() = (void (*)(void))SERIAL_SEND_FUNCTION;
   18374:	88 e9       	ldi	r24, 0x98	; 152
   18376:	9a ee       	ldi	r25, 0xEA	; 234
   18378:	9a 83       	std	Y+2, r25	; 0x02
   1837a:	89 83       	std	Y+1, r24	; 0x01
 serialsendfp();
   1837c:	e9 81       	ldd	r30, Y+1	; 0x01
   1837e:	fa 81       	ldd	r31, Y+2	; 0x02
   18380:	09 95       	icall
   18382:	22 96       	adiw	r28, 0x02	; 2
   18384:	0f b6       	in	r0, 0x3f	; 63
   18386:	f8 94       	cli
   18388:	de bf       	out	0x3e, r29	; 62
   1838a:	0f be       	out	0x3f, r0	; 63
   1838c:	cd bf       	out	0x3d, r28	; 61
   1838e:	df 91       	pop	r29
   18390:	cf 91       	pop	r28
   18392:	08 95       	ret

00018394 <serialSend_string>:
}



//This function sends out a string

void serialSend_string(uint8_t *msg)
{
   18394:	cf 93       	push	r28
   18396:	df 93       	push	r29
   18398:	cd b7       	in	r28, 0x3d	; 61
   1839a:	de b7       	in	r29, 0x3e	; 62
   1839c:	23 97       	sbiw	r28, 0x03	; 3
   1839e:	0f b6       	in	r0, 0x3f	; 63
   183a0:	f8 94       	cli
   183a2:	de bf       	out	0x3e, r29	; 62
   183a4:	0f be       	out	0x3f, r0	; 63
   183a6:	cd bf       	out	0x3d, r28	; 61
   183a8:	9b 83       	std	Y+3, r25	; 0x03
   183aa:	8a 83       	std	Y+2, r24	; 0x02

    uint8_t temp = (uint8_t)String_length((char *)msg);
   183ac:	8a 81       	ldd	r24, Y+2	; 0x02
   183ae:	9b 81       	ldd	r25, Y+3	; 0x03
   183b0:	0e 94 2b c3 	call	0x18656
   183b4:	89 83       	std	Y+1, r24	; 0x01
	return serialSend(temp, msg);
   183b6:	8a 81       	ldd	r24, Y+2	; 0x02
   183b8:	9b 81       	ldd	r25, Y+3	; 0x03
   183ba:	bc 01       	movw	r22, r24
   183bc:	89 81       	ldd	r24, Y+1	; 0x01
   183be:	0e 94 61 c2 	call	0x184c2
   183c2:	23 96       	adiw	r28, 0x03	; 3
   183c4:	0f b6       	in	r0, 0x3f	; 63
   183c6:	f8 94       	cli
   183c8:	de bf       	out	0x3e, r29	; 62
   183ca:	0f be       	out	0x3f, r0	; 63
   183cc:	cd bf       	out	0x3d, r28	; 61
   183ce:	df 91       	pop	r29
   183d0:	cf 91       	pop	r28
   183d2:	08 95       	ret

000183d4 <serialSend_uint16>:

}


void serialSend_uint16(uint16_t value)
{
   183d4:	cf 93       	push	r28
   183d6:	df 93       	push	r29
   183d8:	cd b7       	in	r28, 0x3d	; 61
   183da:	de b7       	in	r29, 0x3e	; 62
   183dc:	24 97       	sbiw	r28, 0x04	; 4
   183de:	0f b6       	in	r0, 0x3f	; 63
   183e0:	f8 94       	cli
   183e2:	de bf       	out	0x3e, r29	; 62
   183e4:	0f be       	out	0x3f, r0	; 63
   183e6:	cd bf       	out	0x3d, r28	; 61
   183e8:	9c 83       	std	Y+4, r25	; 0x04
   183ea:	8b 83       	std	Y+3, r24	; 0x03
  uint8_t temp1,temp2;
  temp1 = (uint8_t) (value >> 8);
   183ec:	8b 81       	ldd	r24, Y+3	; 0x03
   183ee:	9c 81       	ldd	r25, Y+4	; 0x04
   183f0:	89 2f       	mov	r24, r25
   183f2:	99 27       	eor	r25, r25
   183f4:	8a 83       	std	Y+2, r24	; 0x02
  temp2 = (uint8_t) (value & 0x00ff);
   183f6:	8b 81       	ldd	r24, Y+3	; 0x03
   183f8:	89 83       	std	Y+1, r24	; 0x01

  serial_buffer[0] = temp1;
   183fa:	8a 81       	ldd	r24, Y+2	; 0x02
   183fc:	80 93 a7 0a 	sts	0x0AA7, r24
  serial_buffer[1] = temp2;
   18400:	89 81       	ldd	r24, Y+1	; 0x01
   18402:	80 93 a8 0a 	sts	0x0AA8, r24
  serial_buffer[2] = serial_buffer[3] = 0xee;
   18406:	8e ee       	ldi	r24, 0xEE	; 238
   18408:	80 93 aa 0a 	sts	0x0AAA, r24
   1840c:	80 91 aa 0a 	lds	r24, 0x0AAA
   18410:	80 93 a9 0a 	sts	0x0AA9, r24

  return serialSend(16, serial_buffer);
   18414:	87 ea       	ldi	r24, 0xA7	; 167
   18416:	9a e0       	ldi	r25, 0x0A	; 10
   18418:	bc 01       	movw	r22, r24
   1841a:	80 e1       	ldi	r24, 0x10	; 16
   1841c:	0e 94 61 c2 	call	0x184c2
   18420:	24 96       	adiw	r28, 0x04	; 4
   18422:	0f b6       	in	r0, 0x3f	; 63
   18424:	f8 94       	cli
   18426:	de bf       	out	0x3e, r29	; 62
   18428:	0f be       	out	0x3f, r0	; 63
   1842a:	cd bf       	out	0x3d, r28	; 61
   1842c:	df 91       	pop	r29
   1842e:	cf 91       	pop	r28
   18430:	08 95       	ret

00018432 <getCurrentSerialHandleAddr>:

}




serialhandletype *getCurrentSerialHandleAddr()
{
   18432:	cf 93       	push	r28
   18434:	df 93       	push	r29
   18436:	cd b7       	in	r28, 0x3d	; 61
   18438:	de b7       	in	r29, 0x3e	; 62
   1843a:	24 97       	sbiw	r28, 0x04	; 4
   1843c:	0f b6       	in	r0, 0x3f	; 63
   1843e:	f8 94       	cli
   18440:	de bf       	out	0x3e, r29	; 62
   18442:	0f be       	out	0x3f, r0	; 63
   18444:	cd bf       	out	0x3d, r28	; 61
   serialhandletype *currentserialhandle;

   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_RECEIVE_HANDLE;
   18446:	8c e9       	ldi	r24, 0x9C	; 156
   18448:	9a ee       	ldi	r25, 0xEA	; 234
   1844a:	9a 83       	std	Y+2, r25	; 0x02
   1844c:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   1844e:	4f 93       	push	r20
   18450:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   18452:	e9 81       	ldd	r30, Y+1	; 0x01
   18454:	fa 81       	ldd	r31, Y+2	; 0x02
   18456:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18458:	84 2f       	mov	r24, r20
   1845a:	95 2f       	mov	r25, r21
   1845c:	9c 83       	std	Y+4, r25	; 0x04
   1845e:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentserialhandle)
				 :
                );
    asm volatile("pop r21" "\n\t"
   18460:	5f 91       	pop	r21
   18462:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currentserialhandle;
   18464:	8b 81       	ldd	r24, Y+3	; 0x03
   18466:	9c 81       	ldd	r25, Y+4	; 0x04
   18468:	24 96       	adiw	r28, 0x04	; 4
   1846a:	0f b6       	in	r0, 0x3f	; 63
   1846c:	f8 94       	cli
   1846e:	de bf       	out	0x3e, r29	; 62
   18470:	0f be       	out	0x3f, r0	; 63
   18472:	cd bf       	out	0x3d, r28	; 61
   18474:	df 91       	pop	r29
   18476:	cf 91       	pop	r28
   18478:	08 95       	ret

0001847a <getCurrentSerialInfo>:
}






serialinfotype* getCurrentSerialInfo()
{
   1847a:	cf 93       	push	r28
   1847c:	df 93       	push	r29
   1847e:	cd b7       	in	r28, 0x3d	; 61
   18480:	de b7       	in	r29, 0x3e	; 62
   18482:	24 97       	sbiw	r28, 0x04	; 4
   18484:	0f b6       	in	r0, 0x3f	; 63
   18486:	f8 94       	cli
   18488:	de bf       	out	0x3e, r29	; 62
   1848a:	0f be       	out	0x3f, r0	; 63
   1848c:	cd bf       	out	0x3d, r28	; 61
   serialinfotype *currentserialinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_SEND_STRUCTURE_ADDRESS;
   1848e:	84 e9       	ldi	r24, 0x94	; 148
   18490:	9a ee       	ldi	r25, 0xEA	; 234
   18492:	9a 83       	std	Y+2, r25	; 0x02
   18494:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18496:	4f 93       	push	r20
   18498:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   1849a:	e9 81       	ldd	r30, Y+1	; 0x01
   1849c:	fa 81       	ldd	r31, Y+2	; 0x02
   1849e:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   184a0:	84 2f       	mov	r24, r20
   184a2:	95 2f       	mov	r25, r21
   184a4:	9c 83       	std	Y+4, r25	; 0x04
   184a6:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentserialinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
   184a8:	5f 91       	pop	r21
   184aa:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currentserialinfo;
   184ac:	8b 81       	ldd	r24, Y+3	; 0x03
   184ae:	9c 81       	ldd	r25, Y+4	; 0x04
   184b0:	24 96       	adiw	r28, 0x04	; 4
   184b2:	0f b6       	in	r0, 0x3f	; 63
   184b4:	f8 94       	cli
   184b6:	de bf       	out	0x3e, r29	; 62
   184b8:	0f be       	out	0x3f, r0	; 63
   184ba:	cd bf       	out	0x3d, r28	; 61
   184bc:	df 91       	pop	r29
   184be:	cf 91       	pop	r28
   184c0:	08 95       	ret

000184c2 <serialSend>:
}




void serialSend(uint8_t length, uint8_t *msg)
{
   184c2:	cf 93       	push	r28
   184c4:	df 93       	push	r29
   184c6:	cd b7       	in	r28, 0x3d	; 61
   184c8:	de b7       	in	r29, 0x3e	; 62
   184ca:	29 97       	sbiw	r28, 0x09	; 9
   184cc:	0f b6       	in	r0, 0x3f	; 63
   184ce:	f8 94       	cli
   184d0:	de bf       	out	0x3e, r29	; 62
   184d2:	0f be       	out	0x3f, r0	; 63
   184d4:	cd bf       	out	0x3d, r28	; 61
   184d6:	8f 83       	std	Y+7, r24	; 0x07
   184d8:	79 87       	std	Y+9, r23	; 0x09
   184da:	68 87       	std	Y+8, r22	; 0x08


   mutex* mserialsend;
   thread** current_thread;
   serialinfotype *serialinfoaddr;



   mserialsend = getSerialMutexAddress();
   184dc:	0e 94 9e be 	call	0x17d3c
   184e0:	9e 83       	std	Y+6, r25	; 0x06
   184e2:	8d 83       	std	Y+5, r24	; 0x05
   current_thread = getCurrentThread();
   184e4:	0e 94 74 c5 	call	0x18ae8
   184e8:	9c 83       	std	Y+4, r25	; 0x04
   184ea:	8b 83       	std	Y+3, r24	; 0x03
   serialinfoaddr = getCurrentSerialInfo();
   184ec:	0e 94 3d c2 	call	0x1847a
   184f0:	9a 83       	std	Y+2, r25	; 0x02
   184f2:	89 83       	std	Y+1, r24	; 0x01

   Mutex_lock(mserialsend);
   184f4:	8d 81       	ldd	r24, Y+5	; 0x05
   184f6:	9e 81       	ldd	r25, Y+6	; 0x06
   184f8:	0e 94 d1 bd 	call	0x17ba2

   serialinfoaddr->socket_msg_len = length;
   184fc:	e9 81       	ldd	r30, Y+1	; 0x01
   184fe:	fa 81       	ldd	r31, Y+2	; 0x02
   18500:	8f 81       	ldd	r24, Y+7	; 0x07
   18502:	80 83       	st	Z, r24
   serialinfoaddr->socket_msg = msg;
   18504:	e9 81       	ldd	r30, Y+1	; 0x01
   18506:	fa 81       	ldd	r31, Y+2	; 0x02
   18508:	88 85       	ldd	r24, Y+8	; 0x08
   1850a:	99 85       	ldd	r25, Y+9	; 0x09
   1850c:	92 83       	std	Z+2, r25	; 0x02
   1850e:	81 83       	std	Z+1, r24	; 0x01


   sendSerialMsg();
   18510:	0e 94 b0 c1 	call	0x18360

   sleepThread(30);
   18514:	8e e1       	ldi	r24, 0x1E	; 30
   18516:	90 e0       	ldi	r25, 0x00	; 0
   18518:	0e 94 e0 c5 	call	0x18bc0


   Mutex_unlock(mserialsend);
   1851c:	8d 81       	ldd	r24, Y+5	; 0x05
   1851e:	9e 81       	ldd	r25, Y+6	; 0x06
   18520:	0e 94 20 be 	call	0x17c40
   18524:	29 96       	adiw	r28, 0x09	; 9
   18526:	0f b6       	in	r0, 0x3f	; 63
   18528:	f8 94       	cli
   1852a:	de bf       	out	0x3e, r29	; 62
   1852c:	0f be       	out	0x3f, r0	; 63
   1852e:	cd bf       	out	0x3d, r28	; 61
   18530:	df 91       	pop	r29
   18532:	cf 91       	pop	r28
   18534:	08 95       	ret

00018536 <wakeupMeSerial>:

   return;
}



//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
   18536:	cf 93       	push	r28
   18538:	df 93       	push	r29
   1853a:	cd b7       	in	r28, 0x3d	; 61
   1853c:	de b7       	in	r29, 0x3e	; 62
  mythreadserial->state = STATE_ACTIVE;
   1853e:	e0 91 a5 0a 	lds	r30, 0x0AA5
   18542:	f0 91 a6 0a 	lds	r31, 0x0AA6
   18546:	82 e0       	ldi	r24, 0x02	; 2
   18548:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   1854a:	0e 94 45 c6 	call	0x18c8a
   1854e:	df 91       	pop	r29
   18550:	cf 91       	pop	r28
   18552:	08 95       	ret

00018554 <serialReceive>:


}



//In serial receive, the port is above 0, which means that such messages are delivered for the user applications.


void serialReceive(uint16_t port, uint8_t maxlength, uint8_t *msg)

{
   18554:	cf 93       	push	r28
   18556:	df 93       	push	r29
   18558:	cd b7       	in	r28, 0x3d	; 61
   1855a:	de b7       	in	r29, 0x3e	; 62
   1855c:	2c 97       	sbiw	r28, 0x0c	; 12
   1855e:	0f b6       	in	r0, 0x3f	; 63
   18560:	f8 94       	cli
   18562:	de bf       	out	0x3e, r29	; 62
   18564:	0f be       	out	0x3f, r0	; 63
   18566:	cd bf       	out	0x3d, r28	; 61
   18568:	99 87       	std	Y+9, r25	; 0x09
   1856a:	88 87       	std	Y+8, r24	; 0x08
   1856c:	6a 87       	std	Y+10, r22	; 0x0a
   1856e:	5c 87       	std	Y+12, r21	; 0x0c
   18570:	4b 87       	std	Y+11, r20	; 0x0b


   thread** current_thread;

   _atomic_t currentatomic;

   serialhandletype *serialhandleaddr;

   void (*getaddrfp)(void) = (void (*)(void))REGISTER_SERIAL_RECEIVE_EVENT;
   18572:	80 ea       	ldi	r24, 0xA0	; 160
   18574:	9a ee       	ldi	r25, 0xEA	; 234
   18576:	9a 83       	std	Y+2, r25	; 0x02
   18578:	89 83       	std	Y+1, r24	; 0x01

   current_thread = getCurrentThread();
   1857a:	0e 94 74 c5 	call	0x18ae8
   1857e:	9f 83       	std	Y+7, r25	; 0x07
   18580:	8e 83       	std	Y+6, r24	; 0x06

   serialhandleaddr = getCurrentSerialHandleAddr();
   18582:	0e 94 19 c2 	call	0x18432
   18586:	9c 83       	std	Y+4, r25	; 0x04
   18588:	8b 83       	std	Y+3, r24	; 0x03

   //set up the radiohandleaddr data structures

   serialhandleaddr->port = port;
   1858a:	eb 81       	ldd	r30, Y+3	; 0x03
   1858c:	fc 81       	ldd	r31, Y+4	; 0x04
   1858e:	88 85       	ldd	r24, Y+8	; 0x08
   18590:	99 85       	ldd	r25, Y+9	; 0x09
   18592:	91 83       	std	Z+1, r25	; 0x01
   18594:	80 83       	st	Z, r24
   serialhandleaddr->maxLength = maxlength;
   18596:	eb 81       	ldd	r30, Y+3	; 0x03
   18598:	fc 81       	ldd	r31, Y+4	; 0x04
   1859a:	8a 85       	ldd	r24, Y+10	; 0x0a
   1859c:	82 83       	std	Z+2, r24	; 0x02
   serialhandleaddr->data = msg;
   1859e:	eb 81       	ldd	r30, Y+3	; 0x03
   185a0:	fc 81       	ldd	r31, Y+4	; 0x04
   185a2:	8b 85       	ldd	r24, Y+11	; 0x0b
   185a4:	9c 85       	ldd	r25, Y+12	; 0x0c
   185a6:	94 83       	std	Z+4, r25	; 0x04
   185a8:	83 83       	std	Z+3, r24	; 0x03
   serialhandleaddr->handlefunc = wakeupMeSerial;
   185aa:	eb 81       	ldd	r30, Y+3	; 0x03
   185ac:	fc 81       	ldd	r31, Y+4	; 0x04
   185ae:	8b e9       	ldi	r24, 0x9B	; 155
   185b0:	92 ec       	ldi	r25, 0xC2	; 194
   185b2:	97 83       	std	Z+7, r25	; 0x07
   185b4:	86 83       	std	Z+6, r24	; 0x06


   //close the interrupt
	currentatomic = _atomic_start();
   185b6:	0e 94 d6 c4 	call	0x189ac
   185ba:	8d 83       	std	Y+5, r24	; 0x05

   //call the radio handle set to store the data structure into the handle vectors
    getaddrfp();
   185bc:	e9 81       	ldd	r30, Y+1	; 0x01
   185be:	fa 81       	ldd	r31, Y+2	; 0x02
   185c0:	09 95       	icall


   //set up the current thread into sleep mode
   (*current_thread)->state = STATE_SLEEP;
   185c2:	ee 81       	ldd	r30, Y+6	; 0x06
   185c4:	ff 81       	ldd	r31, Y+7	; 0x07
   185c6:	01 90       	ld	r0, Z+
   185c8:	f0 81       	ld	r31, Z
   185ca:	e0 2d       	mov	r30, r0
   185cc:	85 e0       	ldi	r24, 0x05	; 5
   185ce:	82 83       	std	Z+2, r24	; 0x02

   //set up mythread so that later can wake up this thread
   mythreadserial = *current_thread;
   185d0:	ee 81       	ldd	r30, Y+6	; 0x06
   185d2:	ff 81       	ldd	r31, Y+7	; 0x07
   185d4:	80 81       	ld	r24, Z
   185d6:	91 81       	ldd	r25, Z+1	; 0x01
   185d8:	90 93 a6 0a 	sts	0x0AA6, r25
   185dc:	80 93 a5 0a 	sts	0x0AA5, r24


   //open the interrupt
   _atomic_end(currentatomic);
   185e0:	8d 81       	ldd	r24, Y+5	; 0x05
   185e2:	0e 94 f0 c4 	call	0x189e0

    yield();
   185e6:	0e 94 2b c6 	call	0x18c56
   185ea:	2c 96       	adiw	r28, 0x0c	; 12
   185ec:	0f b6       	in	r0, 0x3f	; 63
   185ee:	f8 94       	cli
   185f0:	de bf       	out	0x3e, r29	; 62
   185f2:	0f be       	out	0x3f, r0	; 63
   185f4:	cd bf       	out	0x3d, r28	; 61
   185f6:	df 91       	pop	r29
   185f8:	cf 91       	pop	r28
   185fa:	08 95       	ret

000185fc <hex2value>:



uint16_t hex2value(uint8_t hex)
{
   185fc:	cf 93       	push	r28
   185fe:	df 93       	push	r29
   18600:	cd b7       	in	r28, 0x3d	; 61
   18602:	de b7       	in	r29, 0x3e	; 62
   18604:	24 97       	sbiw	r28, 0x04	; 4
   18606:	0f b6       	in	r0, 0x3f	; 63
   18608:	f8 94       	cli
   1860a:	de bf       	out	0x3e, r29	; 62
   1860c:	0f be       	out	0x3f, r0	; 63
   1860e:	cd bf       	out	0x3d, r28	; 61
   18610:	8c 83       	std	Y+4, r24	; 0x04
  char a = (char)hex;
   18612:	8c 81       	ldd	r24, Y+4	; 0x04
   18614:	8b 83       	std	Y+3, r24	; 0x03
  uint16_t high;

  if ((a>='0')&&(a<='9'))
   18616:	8b 81       	ldd	r24, Y+3	; 0x03
   18618:	80 33       	cpi	r24, 0x30	; 48
   1861a:	5c f0       	brlt	.+22     	; 0x18632
   1861c:	8b 81       	ldd	r24, Y+3	; 0x03
   1861e:	8a 33       	cpi	r24, 0x3A	; 58
   18620:	44 f4       	brge	.+16     	; 0x18632
	     high = a-'0';
   18622:	8b 81       	ldd	r24, Y+3	; 0x03
   18624:	99 27       	eor	r25, r25
   18626:	87 fd       	sbrc	r24, 7
   18628:	90 95       	com	r25
   1862a:	c0 97       	sbiw	r24, 0x30	; 48
   1862c:	9a 83       	std	Y+2, r25	; 0x02
   1862e:	89 83       	std	Y+1, r24	; 0x01
   18630:	07 c0       	rjmp	.+14     	; 0x18640
  else
		 high = a-'A'+ 10;
   18632:	8b 81       	ldd	r24, Y+3	; 0x03
   18634:	99 27       	eor	r25, r25
   18636:	87 fd       	sbrc	r24, 7
   18638:	90 95       	com	r25
   1863a:	c7 97       	sbiw	r24, 0x37	; 55
   1863c:	9a 83       	std	Y+2, r25	; 0x02
   1863e:	89 83       	std	Y+1, r24	; 0x01
  return high;
   18640:	89 81       	ldd	r24, Y+1	; 0x01
   18642:	9a 81       	ldd	r25, Y+2	; 0x02
   18644:	24 96       	adiw	r28, 0x04	; 4
   18646:	0f b6       	in	r0, 0x3f	; 63
   18648:	f8 94       	cli
   1864a:	de bf       	out	0x3e, r29	; 62
   1864c:	0f be       	out	0x3f, r0	; 63
   1864e:	cd bf       	out	0x3d, r28	; 61
   18650:	df 91       	pop	r29
   18652:	cf 91       	pop	r28
   18654:	08 95       	ret

00018656 <String_length>:

}


int String_length(char* s) {
   18656:	cf 93       	push	r28
   18658:	df 93       	push	r29
   1865a:	cd b7       	in	r28, 0x3d	; 61
   1865c:	de b7       	in	r29, 0x3e	; 62
   1865e:	24 97       	sbiw	r28, 0x04	; 4
   18660:	0f b6       	in	r0, 0x3f	; 63
   18662:	f8 94       	cli
   18664:	de bf       	out	0x3e, r29	; 62
   18666:	0f be       	out	0x3f, r0	; 63
   18668:	cd bf       	out	0x3d, r28	; 61
   1866a:	9c 83       	std	Y+4, r25	; 0x04
   1866c:	8b 83       	std	Y+3, r24	; 0x03
	int count=0;
   1866e:	1a 82       	std	Y+2, r1	; 0x02
   18670:	19 82       	std	Y+1, r1	; 0x01
	while(s[count] != '\0')
   18672:	05 c0       	rjmp	.+10     	; 0x1867e
		count++;
   18674:	89 81       	ldd	r24, Y+1	; 0x01
   18676:	9a 81       	ldd	r25, Y+2	; 0x02
   18678:	01 96       	adiw	r24, 0x01	; 1
   1867a:	9a 83       	std	Y+2, r25	; 0x02
   1867c:	89 83       	std	Y+1, r24	; 0x01
   1867e:	89 81       	ldd	r24, Y+1	; 0x01
   18680:	9a 81       	ldd	r25, Y+2	; 0x02
   18682:	9c 01       	movw	r18, r24
   18684:	8b 81       	ldd	r24, Y+3	; 0x03
   18686:	9c 81       	ldd	r25, Y+4	; 0x04
   18688:	f9 01       	movw	r30, r18
   1868a:	e8 0f       	add	r30, r24
   1868c:	f9 1f       	adc	r31, r25
   1868e:	80 81       	ld	r24, Z
   18690:	88 23       	and	r24, r24
   18692:	81 f7       	brne	.-32     	; 0x18674
	return count;
   18694:	89 81       	ldd	r24, Y+1	; 0x01
   18696:	9a 81       	ldd	r25, Y+2	; 0x02
   18698:	24 96       	adiw	r28, 0x04	; 4
   1869a:	0f b6       	in	r0, 0x3f	; 63
   1869c:	f8 94       	cli
   1869e:	de bf       	out	0x3e, r29	; 62
   186a0:	0f be       	out	0x3f, r0	; 63
   186a2:	cd bf       	out	0x3d, r28	; 61
   186a4:	df 91       	pop	r29
   186a6:	cf 91       	pop	r28
   186a8:	08 95       	ret

000186aa <mystrncpy>:
}




void mystrncpy(char *dest, const char *src, uint16_t n)
{
   186aa:	cf 93       	push	r28
   186ac:	df 93       	push	r29
   186ae:	cd b7       	in	r28, 0x3d	; 61
   186b0:	de b7       	in	r29, 0x3e	; 62
   186b2:	28 97       	sbiw	r28, 0x08	; 8
   186b4:	0f b6       	in	r0, 0x3f	; 63
   186b6:	f8 94       	cli
   186b8:	de bf       	out	0x3e, r29	; 62
   186ba:	0f be       	out	0x3f, r0	; 63
   186bc:	cd bf       	out	0x3d, r28	; 61
   186be:	9c 83       	std	Y+4, r25	; 0x04
   186c0:	8b 83       	std	Y+3, r24	; 0x03
   186c2:	7e 83       	std	Y+6, r23	; 0x06
   186c4:	6d 83       	std	Y+5, r22	; 0x05
   186c6:	58 87       	std	Y+8, r21	; 0x08
   186c8:	4f 83       	std	Y+7, r20	; 0x07
	uint16_t i;
	for (i=0;i<n;i++)
   186ca:	1a 82       	std	Y+2, r1	; 0x02
   186cc:	19 82       	std	Y+1, r1	; 0x01
   186ce:	15 c0       	rjmp	.+42     	; 0x186fa
		dest[i] = src[i];
   186d0:	29 81       	ldd	r18, Y+1	; 0x01
   186d2:	3a 81       	ldd	r19, Y+2	; 0x02
   186d4:	8b 81       	ldd	r24, Y+3	; 0x03
   186d6:	9c 81       	ldd	r25, Y+4	; 0x04
   186d8:	d9 01       	movw	r26, r18
   186da:	a8 0f       	add	r26, r24
   186dc:	b9 1f       	adc	r27, r25
   186de:	29 81       	ldd	r18, Y+1	; 0x01
   186e0:	3a 81       	ldd	r19, Y+2	; 0x02
   186e2:	8d 81       	ldd	r24, Y+5	; 0x05
   186e4:	9e 81       	ldd	r25, Y+6	; 0x06
   186e6:	f9 01       	movw	r30, r18
   186e8:	e8 0f       	add	r30, r24
   186ea:	f9 1f       	adc	r31, r25
   186ec:	80 81       	ld	r24, Z
   186ee:	8c 93       	st	X, r24
   186f0:	89 81       	ldd	r24, Y+1	; 0x01
   186f2:	9a 81       	ldd	r25, Y+2	; 0x02
   186f4:	01 96       	adiw	r24, 0x01	; 1
   186f6:	9a 83       	std	Y+2, r25	; 0x02
   186f8:	89 83       	std	Y+1, r24	; 0x01
   186fa:	29 81       	ldd	r18, Y+1	; 0x01
   186fc:	3a 81       	ldd	r19, Y+2	; 0x02
   186fe:	8f 81       	ldd	r24, Y+7	; 0x07
   18700:	98 85       	ldd	r25, Y+8	; 0x08
   18702:	28 17       	cp	r18, r24
   18704:	39 07       	cpc	r19, r25
   18706:	20 f3       	brcs	.-56     	; 0x186d0
   18708:	28 96       	adiw	r28, 0x08	; 8
   1870a:	0f b6       	in	r0, 0x3f	; 63
   1870c:	f8 94       	cli
   1870e:	de bf       	out	0x3e, r29	; 62
   18710:	0f be       	out	0x3f, r0	; 63
   18712:	cd bf       	out	0x3d, r28	; 61
   18714:	df 91       	pop	r29
   18716:	cf 91       	pop	r28
   18718:	08 95       	ret

0001871a <mystrcpy>:
}


void mystrcpy(char *dest, const char *src)
{
   1871a:	cf 93       	push	r28
   1871c:	df 93       	push	r29
   1871e:	cd b7       	in	r28, 0x3d	; 61
   18720:	de b7       	in	r29, 0x3e	; 62
   18722:	26 97       	sbiw	r28, 0x06	; 6
   18724:	0f b6       	in	r0, 0x3f	; 63
   18726:	f8 94       	cli
   18728:	de bf       	out	0x3e, r29	; 62
   1872a:	0f be       	out	0x3f, r0	; 63
   1872c:	cd bf       	out	0x3d, r28	; 61
   1872e:	9c 83       	std	Y+4, r25	; 0x04
   18730:	8b 83       	std	Y+3, r24	; 0x03
   18732:	7e 83       	std	Y+6, r23	; 0x06
   18734:	6d 83       	std	Y+5, r22	; 0x05
	int i;
	i = 0;
   18736:	1a 82       	std	Y+2, r1	; 0x02
   18738:	19 82       	std	Y+1, r1	; 0x01
	while (src[i]!='\0')
   1873a:	17 c0       	rjmp	.+46     	; 0x1876a
	{ dest[i] = src[i];
   1873c:	89 81       	ldd	r24, Y+1	; 0x01
   1873e:	9a 81       	ldd	r25, Y+2	; 0x02
   18740:	9c 01       	movw	r18, r24
   18742:	8b 81       	ldd	r24, Y+3	; 0x03
   18744:	9c 81       	ldd	r25, Y+4	; 0x04
   18746:	d9 01       	movw	r26, r18
   18748:	a8 0f       	add	r26, r24
   1874a:	b9 1f       	adc	r27, r25
   1874c:	89 81       	ldd	r24, Y+1	; 0x01
   1874e:	9a 81       	ldd	r25, Y+2	; 0x02
   18750:	9c 01       	movw	r18, r24
   18752:	8d 81       	ldd	r24, Y+5	; 0x05
   18754:	9e 81       	ldd	r25, Y+6	; 0x06
   18756:	f9 01       	movw	r30, r18
   18758:	e8 0f       	add	r30, r24
   1875a:	f9 1f       	adc	r31, r25
   1875c:	80 81       	ld	r24, Z
   1875e:	8c 93       	st	X, r24
	i++;
   18760:	89 81       	ldd	r24, Y+1	; 0x01
   18762:	9a 81       	ldd	r25, Y+2	; 0x02
   18764:	01 96       	adiw	r24, 0x01	; 1
   18766:	9a 83       	std	Y+2, r25	; 0x02
   18768:	89 83       	std	Y+1, r24	; 0x01
   1876a:	89 81       	ldd	r24, Y+1	; 0x01
   1876c:	9a 81       	ldd	r25, Y+2	; 0x02
   1876e:	9c 01       	movw	r18, r24
   18770:	8d 81       	ldd	r24, Y+5	; 0x05
   18772:	9e 81       	ldd	r25, Y+6	; 0x06
   18774:	f9 01       	movw	r30, r18
   18776:	e8 0f       	add	r30, r24
   18778:	f9 1f       	adc	r31, r25
   1877a:	80 81       	ld	r24, Z
   1877c:	88 23       	and	r24, r24
   1877e:	f1 f6       	brne	.-68     	; 0x1873c
	}
	dest[i] = '\0';
   18780:	89 81       	ldd	r24, Y+1	; 0x01
   18782:	9a 81       	ldd	r25, Y+2	; 0x02
   18784:	9c 01       	movw	r18, r24
   18786:	8b 81       	ldd	r24, Y+3	; 0x03
   18788:	9c 81       	ldd	r25, Y+4	; 0x04
   1878a:	f9 01       	movw	r30, r18
   1878c:	e8 0f       	add	r30, r24
   1878e:	f9 1f       	adc	r31, r25
   18790:	10 82       	st	Z, r1
   18792:	26 96       	adiw	r28, 0x06	; 6
   18794:	0f b6       	in	r0, 0x3f	; 63
   18796:	f8 94       	cli
   18798:	de bf       	out	0x3e, r29	; 62
   1879a:	0f be       	out	0x3f, r0	; 63
   1879c:	cd bf       	out	0x3d, r28	; 61
   1879e:	df 91       	pop	r29
   187a0:	cf 91       	pop	r28
   187a2:	08 95       	ret

000187a4 <dec2char>:
}


char dec2char(uint8_t value) {
   187a4:	cf 93       	push	r28
   187a6:	df 93       	push	r29
   187a8:	cd b7       	in	r28, 0x3d	; 61
   187aa:	de b7       	in	r29, 0x3e	; 62
   187ac:	23 97       	sbiw	r28, 0x03	; 3
   187ae:	0f b6       	in	r0, 0x3f	; 63
   187b0:	f8 94       	cli
   187b2:	de bf       	out	0x3e, r29	; 62
   187b4:	0f be       	out	0x3f, r0	; 63
   187b6:	cd bf       	out	0x3d, r28	; 61
   187b8:	89 83       	std	Y+1, r24	; 0x01

	if (/*value >= 0) &&*/(value <=9))
   187ba:	89 81       	ldd	r24, Y+1	; 0x01
   187bc:	8a 30       	cpi	r24, 0x0A	; 10
   187be:	48 f4       	brcc	.+18     	; 0x187d2
		return (char) (value + 0x30);
   187c0:	89 81       	ldd	r24, Y+1	; 0x01
   187c2:	80 5d       	subi	r24, 0xD0	; 208
   187c4:	28 2f       	mov	r18, r24
   187c6:	33 27       	eor	r19, r19
   187c8:	27 fd       	sbrc	r18, 7
   187ca:	30 95       	com	r19
   187cc:	3b 83       	std	Y+3, r19	; 0x03
   187ce:	2a 83       	std	Y+2, r18	; 0x02
   187d0:	02 c0       	rjmp	.+4      	; 0x187d6
	else
		return 0;
   187d2:	1b 82       	std	Y+3, r1	; 0x03
   187d4:	1a 82       	std	Y+2, r1	; 0x02
   187d6:	8a 81       	ldd	r24, Y+2	; 0x02
   187d8:	9b 81       	ldd	r25, Y+3	; 0x03
   187da:	23 96       	adiw	r28, 0x03	; 3
   187dc:	0f b6       	in	r0, 0x3f	; 63
   187de:	f8 94       	cli
   187e0:	de bf       	out	0x3e, r29	; 62
   187e2:	0f be       	out	0x3f, r0	; 63
   187e4:	cd bf       	out	0x3d, r28	; 61
   187e6:	df 91       	pop	r29
   187e8:	cf 91       	pop	r28
   187ea:	08 95       	ret

000187ec <String_intToString>:
}


char *String_intToString(int num)
{
   187ec:	0f 93       	push	r16
   187ee:	1f 93       	push	r17
   187f0:	cf 93       	push	r28
   187f2:	df 93       	push	r29
   187f4:	cd b7       	in	r28, 0x3d	; 61
   187f6:	de b7       	in	r29, 0x3e	; 62
   187f8:	2a 97       	sbiw	r28, 0x0a	; 10
   187fa:	0f b6       	in	r0, 0x3f	; 63
   187fc:	f8 94       	cli
   187fe:	de bf       	out	0x3e, r29	; 62
   18800:	0f be       	out	0x3f, r0	; 63
   18802:	cd bf       	out	0x3d, r28	; 61
   18804:	98 87       	std	Y+8, r25	; 0x08
   18806:	8f 83       	std	Y+7, r24	; 0x07
	static char temp[7];
	int internal;
	uint8_t length;
	uint8_t i;
	uint8_t offset = 5;
   18808:	85 e0       	ldi	r24, 0x05	; 5
   1880a:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t remainder;

	if (num <0)
   1880c:	8f 81       	ldd	r24, Y+7	; 0x07
   1880e:	98 85       	ldd	r25, Y+8	; 0x08
   18810:	99 23       	and	r25, r25
   18812:	44 f4       	brge	.+16     	; 0x18824
		internal = -num;
   18814:	8f 81       	ldd	r24, Y+7	; 0x07
   18816:	98 85       	ldd	r25, Y+8	; 0x08
   18818:	90 95       	com	r25
   1881a:	81 95       	neg	r24
   1881c:	9f 4f       	sbci	r25, 0xFF	; 255
   1881e:	9e 83       	std	Y+6, r25	; 0x06
   18820:	8d 83       	std	Y+5, r24	; 0x05
   18822:	04 c0       	rjmp	.+8      	; 0x1882c
	else
		internal = num;
   18824:	8f 81       	ldd	r24, Y+7	; 0x07
   18826:	98 85       	ldd	r25, Y+8	; 0x08
   18828:	9e 83       	std	Y+6, r25	; 0x06
   1882a:	8d 83       	std	Y+5, r24	; 0x05

	temp[6] = '\0';
   1882c:	10 92 70 0a 	sts	0x0A70, r1

	do
	{
		remainder = internal%10;
   18830:	8d 81       	ldd	r24, Y+5	; 0x05
   18832:	9e 81       	ldd	r25, Y+6	; 0x06
   18834:	2a e0       	ldi	r18, 0x0A	; 10
   18836:	30 e0       	ldi	r19, 0x00	; 0
   18838:	b9 01       	movw	r22, r18
   1883a:	0e 94 0b c8 	call	0x19016
   1883e:	89 83       	std	Y+1, r24	; 0x01
		temp[offset]= dec2char(remainder);
   18840:	8a 81       	ldd	r24, Y+2	; 0x02
   18842:	08 2f       	mov	r16, r24
   18844:	11 27       	eor	r17, r17
   18846:	89 81       	ldd	r24, Y+1	; 0x01
   18848:	0e 94 d2 c3 	call	0x187a4
   1884c:	f8 01       	movw	r30, r16
   1884e:	e6 59       	subi	r30, 0x96	; 150
   18850:	f5 4f       	sbci	r31, 0xF5	; 245
   18852:	80 83       	st	Z, r24
		internal = internal/10;
   18854:	8d 81       	ldd	r24, Y+5	; 0x05
   18856:	9e 81       	ldd	r25, Y+6	; 0x06
   18858:	2a e0       	ldi	r18, 0x0A	; 10
   1885a:	30 e0       	ldi	r19, 0x00	; 0
   1885c:	b9 01       	movw	r22, r18
   1885e:	0e 94 0b c8 	call	0x19016
   18862:	cb 01       	movw	r24, r22
   18864:	9e 83       	std	Y+6, r25	; 0x06
   18866:	8d 83       	std	Y+5, r24	; 0x05
		offset--;
   18868:	8a 81       	ldd	r24, Y+2	; 0x02
   1886a:	81 50       	subi	r24, 0x01	; 1
   1886c:	8a 83       	std	Y+2, r24	; 0x02
	}
	while (internal!=0);
   1886e:	8d 81       	ldd	r24, Y+5	; 0x05
   18870:	9e 81       	ldd	r25, Y+6	; 0x06
   18872:	00 97       	sbiw	r24, 0x00	; 0
   18874:	e9 f6       	brne	.-70     	; 0x18830

	if (num<0)
   18876:	8f 81       	ldd	r24, Y+7	; 0x07
   18878:	98 85       	ldd	r25, Y+8	; 0x08
   1887a:	99 23       	and	r25, r25
   1887c:	94 f4       	brge	.+36     	; 0x188a2
	{temp[offset] = '-';
   1887e:	8a 81       	ldd	r24, Y+2	; 0x02
   18880:	99 27       	eor	r25, r25
   18882:	fc 01       	movw	r30, r24
   18884:	e6 59       	subi	r30, 0x96	; 150
   18886:	f5 4f       	sbci	r31, 0xF5	; 245
   18888:	8d e2       	ldi	r24, 0x2D	; 45
   1888a:	80 83       	st	Z, r24
	 if (offset ==0)
   1888c:	8a 81       	ldd	r24, Y+2	; 0x02
   1888e:	88 23       	and	r24, r24
   18890:	29 f4       	brne	.+10     	; 0x1889c
		 return temp;
   18892:	8a e6       	ldi	r24, 0x6A	; 106
   18894:	9a e0       	ldi	r25, 0x0A	; 10
   18896:	9a 87       	std	Y+10, r25	; 0x0a
   18898:	89 87       	std	Y+9, r24	; 0x09
   1889a:	27 c0       	rjmp	.+78     	; 0x188ea
	 else
		 offset--;
   1889c:	8a 81       	ldd	r24, Y+2	; 0x02
   1889e:	81 50       	subi	r24, 0x01	; 1
   188a0:	8a 83       	std	Y+2, r24	; 0x02

	}




	{
		length = 7-offset-1;
   188a2:	86 e0       	ldi	r24, 0x06	; 6
   188a4:	9a 81       	ldd	r25, Y+2	; 0x02
   188a6:	89 1b       	sub	r24, r25
   188a8:	8c 83       	std	Y+4, r24	; 0x04
		for (i=0;i<length;i++)
   188aa:	1b 82       	std	Y+3, r1	; 0x03
   188ac:	16 c0       	rjmp	.+44     	; 0x188da
			temp[i] = temp[i+offset+1];
   188ae:	8b 81       	ldd	r24, Y+3	; 0x03
   188b0:	48 2f       	mov	r20, r24
   188b2:	55 27       	eor	r21, r21
   188b4:	8b 81       	ldd	r24, Y+3	; 0x03
   188b6:	28 2f       	mov	r18, r24
   188b8:	33 27       	eor	r19, r19
   188ba:	8a 81       	ldd	r24, Y+2	; 0x02
   188bc:	99 27       	eor	r25, r25
   188be:	82 0f       	add	r24, r18
   188c0:	93 1f       	adc	r25, r19
   188c2:	01 96       	adiw	r24, 0x01	; 1
   188c4:	fc 01       	movw	r30, r24
   188c6:	e6 59       	subi	r30, 0x96	; 150
   188c8:	f5 4f       	sbci	r31, 0xF5	; 245
   188ca:	80 81       	ld	r24, Z
   188cc:	fa 01       	movw	r30, r20
   188ce:	e6 59       	subi	r30, 0x96	; 150
   188d0:	f5 4f       	sbci	r31, 0xF5	; 245
   188d2:	80 83       	st	Z, r24
   188d4:	8b 81       	ldd	r24, Y+3	; 0x03
   188d6:	8f 5f       	subi	r24, 0xFF	; 255
   188d8:	8b 83       	std	Y+3, r24	; 0x03
   188da:	9b 81       	ldd	r25, Y+3	; 0x03
   188dc:	8c 81       	ldd	r24, Y+4	; 0x04
   188de:	98 17       	cp	r25, r24
   188e0:	30 f3       	brcs	.-52     	; 0x188ae
	}
	return temp;
   188e2:	8a e6       	ldi	r24, 0x6A	; 106
   188e4:	9a e0       	ldi	r25, 0x0A	; 10
   188e6:	9a 87       	std	Y+10, r25	; 0x0a
   188e8:	89 87       	std	Y+9, r24	; 0x09
   188ea:	89 85       	ldd	r24, Y+9	; 0x09
   188ec:	9a 85       	ldd	r25, Y+10	; 0x0a
   188ee:	2a 96       	adiw	r28, 0x0a	; 10
   188f0:	0f b6       	in	r0, 0x3f	; 63
   188f2:	f8 94       	cli
   188f4:	de bf       	out	0x3e, r29	; 62
   188f6:	0f be       	out	0x3f, r0	; 63
   188f8:	cd bf       	out	0x3d, r28	; 61
   188fa:	df 91       	pop	r29
   188fc:	cf 91       	pop	r28
   188fe:	1f 91       	pop	r17
   18900:	0f 91       	pop	r16
   18902:	08 95       	ret

00018904 <String_append>:
}



void String_append(char *base, char *string)
{
   18904:	cf 93       	push	r28
   18906:	df 93       	push	r29
   18908:	cd b7       	in	r28, 0x3d	; 61
   1890a:	de b7       	in	r29, 0x3e	; 62
   1890c:	29 97       	sbiw	r28, 0x09	; 9
   1890e:	0f b6       	in	r0, 0x3f	; 63
   18910:	f8 94       	cli
   18912:	de bf       	out	0x3e, r29	; 62
   18914:	0f be       	out	0x3f, r0	; 63
   18916:	cd bf       	out	0x3d, r28	; 61
   18918:	9f 83       	std	Y+7, r25	; 0x07
   1891a:	8e 83       	std	Y+6, r24	; 0x06
   1891c:	79 87       	std	Y+9, r23	; 0x09
   1891e:	68 87       	std	Y+8, r22	; 0x08

	int length1, length2;
	uint8_t i;
	length1 = String_length(base);
   18920:	8e 81       	ldd	r24, Y+6	; 0x06
   18922:	9f 81       	ldd	r25, Y+7	; 0x07
   18924:	0e 94 2b c3 	call	0x18656
   18928:	9d 83       	std	Y+5, r25	; 0x05
   1892a:	8c 83       	std	Y+4, r24	; 0x04
	length2 = String_length(string);
   1892c:	88 85       	ldd	r24, Y+8	; 0x08
   1892e:	99 85       	ldd	r25, Y+9	; 0x09
   18930:	0e 94 2b c3 	call	0x18656
   18934:	9b 83       	std	Y+3, r25	; 0x03
   18936:	8a 83       	std	Y+2, r24	; 0x02
	for (i=0;i<length2;i++)
   18938:	19 82       	std	Y+1, r1	; 0x01
   1893a:	1a c0       	rjmp	.+52     	; 0x18970
	{
		base[i+length1] = string[i];
   1893c:	89 81       	ldd	r24, Y+1	; 0x01
   1893e:	28 2f       	mov	r18, r24
   18940:	33 27       	eor	r19, r19
   18942:	8c 81       	ldd	r24, Y+4	; 0x04
   18944:	9d 81       	ldd	r25, Y+5	; 0x05
   18946:	82 0f       	add	r24, r18
   18948:	93 1f       	adc	r25, r19
   1894a:	9c 01       	movw	r18, r24
   1894c:	8e 81       	ldd	r24, Y+6	; 0x06
   1894e:	9f 81       	ldd	r25, Y+7	; 0x07
   18950:	d9 01       	movw	r26, r18
   18952:	a8 0f       	add	r26, r24
   18954:	b9 1f       	adc	r27, r25
   18956:	89 81       	ldd	r24, Y+1	; 0x01
   18958:	99 27       	eor	r25, r25
   1895a:	9c 01       	movw	r18, r24
   1895c:	88 85       	ldd	r24, Y+8	; 0x08
   1895e:	99 85       	ldd	r25, Y+9	; 0x09
   18960:	f9 01       	movw	r30, r18
   18962:	e8 0f       	add	r30, r24
   18964:	f9 1f       	adc	r31, r25
   18966:	80 81       	ld	r24, Z
   18968:	8c 93       	st	X, r24
   1896a:	89 81       	ldd	r24, Y+1	; 0x01
   1896c:	8f 5f       	subi	r24, 0xFF	; 255
   1896e:	89 83       	std	Y+1, r24	; 0x01
   18970:	89 81       	ldd	r24, Y+1	; 0x01
   18972:	28 2f       	mov	r18, r24
   18974:	33 27       	eor	r19, r19
   18976:	8a 81       	ldd	r24, Y+2	; 0x02
   18978:	9b 81       	ldd	r25, Y+3	; 0x03
   1897a:	28 17       	cp	r18, r24
   1897c:	39 07       	cpc	r19, r25
   1897e:	f4 f2       	brlt	.-68     	; 0x1893c

	}
	base[length1+length2] = '\0';
   18980:	2c 81       	ldd	r18, Y+4	; 0x04
   18982:	3d 81       	ldd	r19, Y+5	; 0x05
   18984:	8a 81       	ldd	r24, Y+2	; 0x02
   18986:	9b 81       	ldd	r25, Y+3	; 0x03
   18988:	82 0f       	add	r24, r18
   1898a:	93 1f       	adc	r25, r19
   1898c:	9c 01       	movw	r18, r24
   1898e:	8e 81       	ldd	r24, Y+6	; 0x06
   18990:	9f 81       	ldd	r25, Y+7	; 0x07
   18992:	f9 01       	movw	r30, r18
   18994:	e8 0f       	add	r30, r24
   18996:	f9 1f       	adc	r31, r25
   18998:	10 82       	st	Z, r1
   1899a:	29 96       	adiw	r28, 0x09	; 9
   1899c:	0f b6       	in	r0, 0x3f	; 63
   1899e:	f8 94       	cli
   189a0:	de bf       	out	0x3e, r29	; 62
   189a2:	0f be       	out	0x3f, r0	; 63
   189a4:	cd bf       	out	0x3d, r28	; 61
   189a6:	df 91       	pop	r29
   189a8:	cf 91       	pop	r28
   189aa:	08 95       	ret

000189ac <_atomic_start>:
volatile uint16_t * old_stack_ptr ;


_atomic_t _atomic_start(void)
{
   189ac:	cf 93       	push	r28
   189ae:	df 93       	push	r29
   189b0:	cd b7       	in	r28, 0x3d	; 61
   189b2:	de b7       	in	r29, 0x3e	; 62
   189b4:	21 97       	sbiw	r28, 0x01	; 1
   189b6:	0f b6       	in	r0, 0x3f	; 63
   189b8:	f8 94       	cli
   189ba:	de bf       	out	0x3e, r29	; 62
   189bc:	0f be       	out	0x3f, r0	; 63
   189be:	cd bf       	out	0x3d, r28	; 61
  _atomic_t result = SREG;
   189c0:	ef e5       	ldi	r30, 0x5F	; 95
   189c2:	f0 e0       	ldi	r31, 0x00	; 0
   189c4:	80 81       	ld	r24, Z
   189c6:	89 83       	std	Y+1, r24	; 0x01
  asm volatile("cli" "\n\t"::);
   189c8:	f8 94       	cli
  return result;
   189ca:	89 81       	ldd	r24, Y+1	; 0x01
   189cc:	99 27       	eor	r25, r25
   189ce:	21 96       	adiw	r28, 0x01	; 1
   189d0:	0f b6       	in	r0, 0x3f	; 63
   189d2:	f8 94       	cli
   189d4:	de bf       	out	0x3e, r29	; 62
   189d6:	0f be       	out	0x3f, r0	; 63
   189d8:	cd bf       	out	0x3d, r28	; 61
   189da:	df 91       	pop	r29
   189dc:	cf 91       	pop	r28
   189de:	08 95       	ret

000189e0 <_atomic_end>:
}



void _atomic_end(_atomic_t oldSreg)
{
   189e0:	cf 93       	push	r28
   189e2:	df 93       	push	r29
   189e4:	cd b7       	in	r28, 0x3d	; 61
   189e6:	de b7       	in	r29, 0x3e	; 62
   189e8:	21 97       	sbiw	r28, 0x01	; 1
   189ea:	0f b6       	in	r0, 0x3f	; 63
   189ec:	f8 94       	cli
   189ee:	de bf       	out	0x3e, r29	; 62
   189f0:	0f be       	out	0x3f, r0	; 63
   189f2:	cd bf       	out	0x3d, r28	; 61
   189f4:	89 83       	std	Y+1, r24	; 0x01
  SREG = oldSreg;
   189f6:	ef e5       	ldi	r30, 0x5F	; 95
   189f8:	f0 e0       	ldi	r31, 0x00	; 0
   189fa:	89 81       	ldd	r24, Y+1	; 0x01
   189fc:	80 83       	st	Z, r24
   189fe:	21 96       	adiw	r28, 0x01	; 1
   18a00:	0f b6       	in	r0, 0x3f	; 63
   18a02:	f8 94       	cli
   18a04:	de bf       	out	0x3e, r29	; 62
   18a06:	0f be       	out	0x3f, r0	; 63
   18a08:	cd bf       	out	0x3d, r28	; 61
   18a0a:	df 91       	pop	r29
   18a0c:	cf 91       	pop	r28
   18a0e:	08 95       	ret

00018a10 <rnd>:
}



int rnd()
{
   18a10:	cf 93       	push	r28
   18a12:	df 93       	push	r29
   18a14:	cd b7       	in	r28, 0x3d	; 61
   18a16:	de b7       	in	r29, 0x3e	; 62
   18a18:	24 97       	sbiw	r28, 0x04	; 4
   18a1a:	0f b6       	in	r0, 0x3f	; 63
   18a1c:	f8 94       	cli
   18a1e:	de bf       	out	0x3e, r29	; 62
   18a20:	0f be       	out	0x3f, r0	; 63
   18a22:	cd bf       	out	0x3d, r28	; 61

	 int ret;
   void (*getrandomfp)(void) = (void (*)(void))GET_RANDOM_NUMBER_FUNCTION;
   18a24:	8c eb       	ldi	r24, 0xBC	; 188
   18a26:	9a ee       	ldi	r25, 0xEA	; 234
   18a28:	9a 83       	std	Y+2, r25	; 0x02
   18a2a:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18a2c:	4f 93       	push	r20
   18a2e:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getrandomfp();
   18a30:	e9 81       	ldd	r30, Y+1	; 0x01
   18a32:	fa 81       	ldd	r31, Y+2	; 0x02
   18a34:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18a36:	84 2f       	mov	r24, r20
   18a38:	95 2f       	mov	r25, r21
   18a3a:	9c 83       	std	Y+4, r25	; 0x04
   18a3c:	8b 83       	std	Y+3, r24	; 0x03
	              "mov %B0, r21" "\n\t"
				 :"=r" (ret)
				 :
                );
   asm volatile("pop r21" "\n\t"
   18a3e:	5f 91       	pop	r21
   18a40:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return ret;
   18a42:	8b 81       	ldd	r24, Y+3	; 0x03
   18a44:	9c 81       	ldd	r25, Y+4	; 0x04
   18a46:	24 96       	adiw	r28, 0x04	; 4
   18a48:	0f b6       	in	r0, 0x3f	; 63
   18a4a:	f8 94       	cli
   18a4c:	de bf       	out	0x3e, r29	; 62
   18a4e:	0f be       	out	0x3f, r0	; 63
   18a50:	cd bf       	out	0x3d, r28	; 61
   18a52:	df 91       	pop	r29
   18a54:	cf 91       	pop	r28
   18a56:	08 95       	ret

00018a58 <getnodeID>:

}



uint16_t getnodeID()
	{
   18a58:	cf 93       	push	r28
   18a5a:	df 93       	push	r29
   18a5c:	cd b7       	in	r28, 0x3d	; 61
   18a5e:	de b7       	in	r29, 0x3e	; 62
   18a60:	24 97       	sbiw	r28, 0x04	; 4
   18a62:	0f b6       	in	r0, 0x3f	; 63
   18a64:	f8 94       	cli
   18a66:	de bf       	out	0x3e, r29	; 62
   18a68:	0f be       	out	0x3f, r0	; 63
   18a6a:	cd bf       	out	0x3d, r28	; 61

	   int ret;
	   void (*fp)(void) = (void (*)(void))GET_NODE_ID_FUNCTION;
   18a6c:	8c ec       	ldi	r24, 0xCC	; 204
   18a6e:	9a ee       	ldi	r25, 0xEA	; 234
   18a70:	9a 83       	std	Y+2, r25	; 0x02
   18a72:	89 83       	std	Y+1, r24	; 0x01
	   asm volatile("push r20" "\n\t"
   18a74:	4f 93       	push	r20
   18a76:	5f 93       	push	r21
					"push r21" "\n\t"
					::);
	   fp();
   18a78:	e9 81       	ldd	r30, Y+1	; 0x01
   18a7a:	fa 81       	ldd	r31, Y+2	; 0x02
   18a7c:	09 95       	icall
	   asm volatile(" mov %A0, r20" "\n\t"
   18a7e:	84 2f       	mov	r24, r20
   18a80:	95 2f       	mov	r25, r21
   18a82:	9c 83       	std	Y+4, r25	; 0x04
   18a84:	8b 83       	std	Y+3, r24	; 0x03
					  "mov %B0, r21" "\n\t"
					 :"=r" (ret)
					 :
					);
	   asm volatile("pop r21" "\n\t"
   18a86:	5f 91       	pop	r21
   18a88:	4f 91       	pop	r20
					 "pop r20" "\n\t"
					  ::);
	   return ret;
   18a8a:	8b 81       	ldd	r24, Y+3	; 0x03
   18a8c:	9c 81       	ldd	r25, Y+4	; 0x04
   18a8e:	24 96       	adiw	r28, 0x04	; 4
   18a90:	0f b6       	in	r0, 0x3f	; 63
   18a92:	f8 94       	cli
   18a94:	de bf       	out	0x3e, r29	; 62
   18a96:	0f be       	out	0x3f, r0	; 63
   18a98:	cd bf       	out	0x3d, r28	; 61
   18a9a:	df 91       	pop	r29
   18a9c:	cf 91       	pop	r28
   18a9e:	08 95       	ret

00018aa0 <setnodeID>:

	}


void setnodeID(uint16_t nodeid)
	{
   18aa0:	cf 93       	push	r28
   18aa2:	df 93       	push	r29
   18aa4:	cd b7       	in	r28, 0x3d	; 61
   18aa6:	de b7       	in	r29, 0x3e	; 62
   18aa8:	24 97       	sbiw	r28, 0x04	; 4
   18aaa:	0f b6       	in	r0, 0x3f	; 63
   18aac:	f8 94       	cli
   18aae:	de bf       	out	0x3e, r29	; 62
   18ab0:	0f be       	out	0x3f, r0	; 63
   18ab2:	cd bf       	out	0x3d, r28	; 61
   18ab4:	9c 83       	std	Y+4, r25	; 0x04
   18ab6:	8b 83       	std	Y+3, r24	; 0x03



	   void (*fp)(void) = (void (*)(void))SET_NODE_ID_FUNCTION;
   18ab8:	80 ed       	ldi	r24, 0xD0	; 208
   18aba:	9a ee       	ldi	r25, 0xEA	; 234
   18abc:	9a 83       	std	Y+2, r25	; 0x02
   18abe:	89 83       	std	Y+1, r24	; 0x01
	   asm volatile("push r20" "\n\t"
   18ac0:	4f 93       	push	r20
   18ac2:	5f 93       	push	r21
					"push r21" "\n\t"
					::);

	   asm volatile(" mov r20, %A0" "\n\t"
   18ac4:	8b 81       	ldd	r24, Y+3	; 0x03
   18ac6:	9c 81       	ldd	r25, Y+4	; 0x04
   18ac8:	48 2f       	mov	r20, r24
   18aca:	59 2f       	mov	r21, r25
					  "mov r21, %B0" "\n\t"
					 :
					 :"r" (nodeid)
					);
	   fp();
   18acc:	e9 81       	ldd	r30, Y+1	; 0x01
   18ace:	fa 81       	ldd	r31, Y+2	; 0x02
   18ad0:	09 95       	icall
	   asm volatile("pop r21" "\n\t"
   18ad2:	5f 91       	pop	r21
   18ad4:	4f 91       	pop	r20
   18ad6:	24 96       	adiw	r28, 0x04	; 4
   18ad8:	0f b6       	in	r0, 0x3f	; 63
   18ada:	f8 94       	cli
   18adc:	de bf       	out	0x3e, r29	; 62
   18ade:	0f be       	out	0x3f, r0	; 63
   18ae0:	cd bf       	out	0x3d, r28	; 61
   18ae2:	df 91       	pop	r29
   18ae4:	cf 91       	pop	r28
   18ae6:	08 95       	ret

00018ae8 <getCurrentThread>:

//Warning: this returns the address of the currentthread pointer. 

thread **getCurrentThread()
{
   18ae8:	cf 93       	push	r28
   18aea:	df 93       	push	r29
   18aec:	cd b7       	in	r28, 0x3d	; 61
   18aee:	de b7       	in	r29, 0x3e	; 62
   18af0:	24 97       	sbiw	r28, 0x04	; 4
   18af2:	0f b6       	in	r0, 0x3f	; 63
   18af4:	f8 94       	cli
   18af6:	de bf       	out	0x3e, r29	; 62
   18af8:	0f be       	out	0x3f, r0	; 63
   18afa:	cd bf       	out	0x3d, r28	; 61
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   18afc:	8c e0       	ldi	r24, 0x0C	; 12
   18afe:	9a ee       	ldi	r25, 0xEA	; 234
   18b00:	9a 83       	std	Y+2, r25	; 0x02
   18b02:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18b04:	4f 93       	push	r20
   18b06:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   18b08:	e9 81       	ldd	r30, Y+1	; 0x01
   18b0a:	fa 81       	ldd	r31, Y+2	; 0x02
   18b0c:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18b0e:	84 2f       	mov	r24, r20
   18b10:	95 2f       	mov	r25, r21
   18b12:	9c 83       	std	Y+4, r25	; 0x04
   18b14:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   18b16:	5f 91       	pop	r21
   18b18:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
   18b1a:	8b 81       	ldd	r24, Y+3	; 0x03
   18b1c:	9c 81       	ldd	r25, Y+4	; 0x04
   18b1e:	24 96       	adiw	r28, 0x04	; 4
   18b20:	0f b6       	in	r0, 0x3f	; 63
   18b22:	f8 94       	cli
   18b24:	de bf       	out	0x3e, r29	; 62
   18b26:	0f be       	out	0x3f, r0	; 63
   18b28:	cd bf       	out	0x3d, r28	; 61
   18b2a:	df 91       	pop	r29
   18b2c:	cf 91       	pop	r28
   18b2e:	08 95       	ret

00018b30 <getKernelStackPtr>:
}


void **getKernelStackPtr()
	{
   18b30:	cf 93       	push	r28
   18b32:	df 93       	push	r29
   18b34:	cd b7       	in	r28, 0x3d	; 61
   18b36:	de b7       	in	r29, 0x3e	; 62
   18b38:	24 97       	sbiw	r28, 0x04	; 4
   18b3a:	0f b6       	in	r0, 0x3f	; 63
   18b3c:	f8 94       	cli
   18b3e:	de bf       	out	0x3e, r29	; 62
   18b40:	0f be       	out	0x3f, r0	; 63
   18b42:	cd bf       	out	0x3d, r28	; 61
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   18b44:	88 e0       	ldi	r24, 0x08	; 8
   18b46:	9b ee       	ldi	r25, 0xEB	; 235
   18b48:	9a 83       	std	Y+2, r25	; 0x02
   18b4a:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18b4c:	4f 93       	push	r20
   18b4e:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   18b50:	e9 81       	ldd	r30, Y+1	; 0x01
   18b52:	fa 81       	ldd	r31, Y+2	; 0x02
   18b54:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18b56:	84 2f       	mov	r24, r20
   18b58:	95 2f       	mov	r25, r21
   18b5a:	9c 83       	std	Y+4, r25	; 0x04
   18b5c:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
   18b5e:	5f 91       	pop	r21
   18b60:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
   18b62:	8b 81       	ldd	r24, Y+3	; 0x03
   18b64:	9c 81       	ldd	r25, Y+4	; 0x04
   18b66:	24 96       	adiw	r28, 0x04	; 4
   18b68:	0f b6       	in	r0, 0x3f	; 63
   18b6a:	f8 94       	cli
   18b6c:	de bf       	out	0x3e, r29	; 62
   18b6e:	0f be       	out	0x3f, r0	; 63
   18b70:	cd bf       	out	0x3d, r28	; 61
   18b72:	df 91       	pop	r29
   18b74:	cf 91       	pop	r28
   18b76:	08 95       	ret

00018b78 <getCurrentThreadIndex>:
}







uint8_t getCurrentThreadIndex()
{
   18b78:	cf 93       	push	r28
   18b7a:	df 93       	push	r29
   18b7c:	cd b7       	in	r28, 0x3d	; 61
   18b7e:	de b7       	in	r29, 0x3e	; 62
   18b80:	24 97       	sbiw	r28, 0x04	; 4
   18b82:	0f b6       	in	r0, 0x3f	; 63
   18b84:	f8 94       	cli
   18b86:	de bf       	out	0x3e, r29	; 62
   18b88:	0f be       	out	0x3f, r0	; 63
   18b8a:	cd bf       	out	0x3d, r28	; 61
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   18b8c:	8c e1       	ldi	r24, 0x1C	; 28
   18b8e:	9a ee       	ldi	r25, 0xEA	; 234
   18b90:	9a 83       	std	Y+2, r25	; 0x02
   18b92:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18b94:	4f 93       	push	r20
   18b96:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   18b98:	e9 81       	ldd	r30, Y+1	; 0x01
   18b9a:	fa 81       	ldd	r31, Y+2	; 0x02
   18b9c:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18b9e:	84 2f       	mov	r24, r20
   18ba0:	95 2f       	mov	r25, r21
   18ba2:	9c 83       	std	Y+4, r25	; 0x04
   18ba4:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
   18ba6:	5f 91       	pop	r21
   18ba8:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
   18baa:	8b 81       	ldd	r24, Y+3	; 0x03
   18bac:	99 27       	eor	r25, r25
   18bae:	24 96       	adiw	r28, 0x04	; 4
   18bb0:	0f b6       	in	r0, 0x3f	; 63
   18bb2:	f8 94       	cli
   18bb4:	de bf       	out	0x3e, r29	; 62
   18bb6:	0f be       	out	0x3f, r0	; 63
   18bb8:	cd bf       	out	0x3d, r28	; 61
   18bba:	df 91       	pop	r29
   18bbc:	cf 91       	pop	r28
   18bbe:	08 95       	ret

00018bc0 <sleepThread>:
}


void sleepThread(int milliseconds)
{
   18bc0:	cf 93       	push	r28
   18bc2:	df 93       	push	r29
   18bc4:	cd b7       	in	r28, 0x3d	; 61
   18bc6:	de b7       	in	r29, 0x3e	; 62
   18bc8:	24 97       	sbiw	r28, 0x04	; 4
   18bca:	0f b6       	in	r0, 0x3f	; 63
   18bcc:	f8 94       	cli
   18bce:	de bf       	out	0x3e, r29	; 62
   18bd0:	0f be       	out	0x3f, r0	; 63
   18bd2:	cd bf       	out	0x3d, r28	; 61
   18bd4:	9c 83       	std	Y+4, r25	; 0x04
   18bd6:	8b 83       	std	Y+3, r24	; 0x03
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
   18bd8:	0e 94 74 c5 	call	0x18ae8
   18bdc:	9a 83       	std	Y+2, r25	; 0x02
   18bde:	89 83       	std	Y+1, r24	; 0x01
     
   (*current_thread)->state = 4;
   18be0:	e9 81       	ldd	r30, Y+1	; 0x01
   18be2:	fa 81       	ldd	r31, Y+2	; 0x02
   18be4:	01 90       	ld	r0, Z+
   18be6:	f0 81       	ld	r31, Z
   18be8:	e0 2d       	mov	r30, r0
   18bea:	84 e0       	ldi	r24, 0x04	; 4
   18bec:	82 83       	std	Z+2, r24	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   18bee:	e9 81       	ldd	r30, Y+1	; 0x01
   18bf0:	fa 81       	ldd	r31, Y+2	; 0x02
   18bf2:	01 90       	ld	r0, Z+
   18bf4:	f0 81       	ld	r31, Z
   18bf6:	e0 2d       	mov	r30, r0
   18bf8:	8b 81       	ldd	r24, Y+3	; 0x03
   18bfa:	9c 81       	ldd	r25, Y+4	; 0x04
   18bfc:	94 8f       	std	Z+28, r25	; 0x1c
   18bfe:	83 8f       	std	Z+27, r24	; 0x1b
   
   yield(); 
   18c00:	0e 94 2b c6 	call	0x18c56
   18c04:	24 96       	adiw	r28, 0x04	; 4
   18c06:	0f b6       	in	r0, 0x3f	; 63
   18c08:	f8 94       	cli
   18c0a:	de bf       	out	0x3e, r29	; 62
   18c0c:	0f be       	out	0x3f, r0	; 63
   18c0e:	cd bf       	out	0x3d, r28	; 61
   18c10:	df 91       	pop	r29
   18c12:	cf 91       	pop	r28
   18c14:	08 95       	ret

00018c16 <hibernateThread>:
}


void hibernateThread()
{
   18c16:	cf 93       	push	r28
   18c18:	df 93       	push	r29
   18c1a:	cd b7       	in	r28, 0x3d	; 61
   18c1c:	de b7       	in	r29, 0x3e	; 62
   18c1e:	22 97       	sbiw	r28, 0x02	; 2
   18c20:	0f b6       	in	r0, 0x3f	; 63
   18c22:	f8 94       	cli
   18c24:	de bf       	out	0x3e, r29	; 62
   18c26:	0f be       	out	0x3f, r0	; 63
   18c28:	cd bf       	out	0x3d, r28	; 61
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
   18c2a:	0e 94 74 c5 	call	0x18ae8
   18c2e:	9a 83       	std	Y+2, r25	; 0x02
   18c30:	89 83       	std	Y+1, r24	; 0x01
     
   (*current_thread)->state = 5; 
   18c32:	e9 81       	ldd	r30, Y+1	; 0x01
   18c34:	fa 81       	ldd	r31, Y+2	; 0x02
   18c36:	01 90       	ld	r0, Z+
   18c38:	f0 81       	ld	r31, Z
   18c3a:	e0 2d       	mov	r30, r0
   18c3c:	85 e0       	ldi	r24, 0x05	; 5
   18c3e:	82 83       	std	Z+2, r24	; 0x02
   yield(); 
   18c40:	0e 94 2b c6 	call	0x18c56
   18c44:	22 96       	adiw	r28, 0x02	; 2
   18c46:	0f b6       	in	r0, 0x3f	; 63
   18c48:	f8 94       	cli
   18c4a:	de bf       	out	0x3e, r29	; 62
   18c4c:	0f be       	out	0x3f, r0	; 63
   18c4e:	cd bf       	out	0x3d, r28	; 61
   18c50:	df 91       	pop	r29
   18c52:	cf 91       	pop	r28
   18c54:	08 95       	ret

00018c56 <yield>:
}


void yield()
{
   18c56:	cf 93       	push	r28
   18c58:	df 93       	push	r29
   18c5a:	cd b7       	in	r28, 0x3d	; 61
   18c5c:	de b7       	in	r29, 0x3e	; 62
   18c5e:	22 97       	sbiw	r28, 0x02	; 2
   18c60:	0f b6       	in	r0, 0x3f	; 63
   18c62:	f8 94       	cli
   18c64:	de bf       	out	0x3e, r29	; 62
   18c66:	0f be       	out	0x3f, r0	; 63
   18c68:	cd bf       	out	0x3d, r28	; 61
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
   18c6a:	80 e0       	ldi	r24, 0x00	; 0
   18c6c:	9a ee       	ldi	r25, 0xEA	; 234
   18c6e:	9a 83       	std	Y+2, r25	; 0x02
   18c70:	89 83       	std	Y+1, r24	; 0x01
 yieldfp();                              
   18c72:	e9 81       	ldd	r30, Y+1	; 0x01
   18c74:	fa 81       	ldd	r31, Y+2	; 0x02
   18c76:	09 95       	icall
   18c78:	22 96       	adiw	r28, 0x02	; 2
   18c7a:	0f b6       	in	r0, 0x3f	; 63
   18c7c:	f8 94       	cli
   18c7e:	de bf       	out	0x3e, r29	; 62
   18c80:	0f be       	out	0x3f, r0	; 63
   18c82:	cd bf       	out	0x3d, r28	; 61
   18c84:	df 91       	pop	r29
   18c86:	cf 91       	pop	r28
   18c88:	08 95       	ret

00018c8a <syscall_postThreadTask>:
}



void syscall_postThreadTask()
{
   18c8a:	cf 93       	push	r28
   18c8c:	df 93       	push	r29
   18c8e:	cd b7       	in	r28, 0x3d	; 61
   18c90:	de b7       	in	r29, 0x3e	; 62
   18c92:	22 97       	sbiw	r28, 0x02	; 2
   18c94:	0f b6       	in	r0, 0x3f	; 63
   18c96:	f8 94       	cli
   18c98:	de bf       	out	0x3e, r29	; 62
   18c9a:	0f be       	out	0x3f, r0	; 63
   18c9c:	cd bf       	out	0x3d, r28	; 61
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
   18c9e:	88 e6       	ldi	r24, 0x68	; 104
   18ca0:	9a ee       	ldi	r25, 0xEA	; 234
   18ca2:	9a 83       	std	Y+2, r25	; 0x02
   18ca4:	89 83       	std	Y+1, r24	; 0x01
 postthreadfp();                              
   18ca6:	e9 81       	ldd	r30, Y+1	; 0x01
   18ca8:	fa 81       	ldd	r31, Y+2	; 0x02
   18caa:	09 95       	icall
   18cac:	22 96       	adiw	r28, 0x02	; 2
   18cae:	0f b6       	in	r0, 0x3f	; 63
   18cb0:	f8 94       	cli
   18cb2:	de bf       	out	0x3e, r29	; 62
   18cb4:	0f be       	out	0x3f, r0	; 63
   18cb6:	cd bf       	out	0x3d, r28	; 61
   18cb8:	df 91       	pop	r29
   18cba:	cf 91       	pop	r28
   18cbc:	08 95       	ret

00018cbe <syscall_postThreadTask_nologging>:
}

void syscall_postThreadTask_nologging()
{
   18cbe:	cf 93       	push	r28
   18cc0:	df 93       	push	r29
   18cc2:	cd b7       	in	r28, 0x3d	; 61
   18cc4:	de b7       	in	r29, 0x3e	; 62
   18cc6:	22 97       	sbiw	r28, 0x02	; 2
   18cc8:	0f b6       	in	r0, 0x3f	; 63
   18cca:	f8 94       	cli
   18ccc:	de bf       	out	0x3e, r29	; 62
   18cce:	0f be       	out	0x3f, r0	; 63
   18cd0:	cd bf       	out	0x3d, r28	; 61
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK_NOLOG; 
   18cd2:	80 ef       	ldi	r24, 0xF0	; 240
   18cd4:	9a ee       	ldi	r25, 0xEA	; 234
   18cd6:	9a 83       	std	Y+2, r25	; 0x02
   18cd8:	89 83       	std	Y+1, r24	; 0x01
 postthreadfp();                              
   18cda:	e9 81       	ldd	r30, Y+1	; 0x01
   18cdc:	fa 81       	ldd	r31, Y+2	; 0x02
   18cde:	09 95       	icall
   18ce0:	22 96       	adiw	r28, 0x02	; 2
   18ce2:	0f b6       	in	r0, 0x3f	; 63
   18ce4:	f8 94       	cli
   18ce6:	de bf       	out	0x3e, r29	; 62
   18ce8:	0f be       	out	0x3f, r0	; 63
   18cea:	cd bf       	out	0x3d, r28	; 61
   18cec:	df 91       	pop	r29
   18cee:	cf 91       	pop	r28
   18cf0:	08 95       	ret

00018cf2 <debugValue>:
}


void debugValue(uint16_t v1, uint16_t v2, uint16_t v3)
{
   18cf2:	cf 93       	push	r28
   18cf4:	df 93       	push	r29
   18cf6:	cd b7       	in	r28, 0x3d	; 61
   18cf8:	de b7       	in	r29, 0x3e	; 62
   18cfa:	28 97       	sbiw	r28, 0x08	; 8
   18cfc:	0f b6       	in	r0, 0x3f	; 63
   18cfe:	f8 94       	cli
   18d00:	de bf       	out	0x3e, r29	; 62
   18d02:	0f be       	out	0x3f, r0	; 63
   18d04:	cd bf       	out	0x3d, r28	; 61
   18d06:	9c 83       	std	Y+4, r25	; 0x04
   18d08:	8b 83       	std	Y+3, r24	; 0x03
   18d0a:	7e 83       	std	Y+6, r23	; 0x06
   18d0c:	6d 83       	std	Y+5, r22	; 0x05
   18d0e:	58 87       	std	Y+8, r21	; 0x08
   18d10:	4f 83       	std	Y+7, r20	; 0x07

  void (*fp)(void) = (void (*)(void))DEBUG_VALUE_SYSCALL; 
   18d12:	8c e6       	ldi	r24, 0x6C	; 108
   18d14:	9a ee       	ldi	r25, 0xEA	; 234
   18d16:	9a 83       	std	Y+2, r25	; 0x02
   18d18:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r8" "\n\t"
   18d1a:	8f 92       	push	r8
   18d1c:	9f 92       	push	r9
   18d1e:	af 92       	push	r10
   18d20:	bf 92       	push	r11
   18d22:	cf 92       	push	r12
   18d24:	df 92       	push	r13
                "push r9" "\n\t"
                "push r10" "\n\t"
                "push r11" "\n\t"
				"push r12" "\n\t"
				"push r13" "\n\t"
                ::);
   
   asm volatile(" mov r8, %A0" "\n\t"
   18d26:	8b 81       	ldd	r24, Y+3	; 0x03
   18d28:	9c 81       	ldd	r25, Y+4	; 0x04
   18d2a:	88 2e       	mov	r8, r24
   18d2c:	99 2e       	mov	r9, r25
	             "mov r9, %B0" "\n\t"
				 :
				 :"r" (v1)
                );


   asm volatile(" mov r10, %A0" "\n\t"
   18d2e:	8d 81       	ldd	r24, Y+5	; 0x05
   18d30:	9e 81       	ldd	r25, Y+6	; 0x06
   18d32:	a8 2e       	mov	r10, r24
   18d34:	b9 2e       	mov	r11, r25
	             "mov r11, %B0" "\n\t"
				 :
				 :"r" (v2)
                );
 
   asm volatile(" mov r12, %A0" "\n\t"
   18d36:	8f 81       	ldd	r24, Y+7	; 0x07
   18d38:	98 85       	ldd	r25, Y+8	; 0x08
   18d3a:	c8 2e       	mov	r12, r24
   18d3c:	d9 2e       	mov	r13, r25
	             "mov r13, %B0" "\n\t"
				 :
				 :"r" (v3)
                );


  fp(); 
   18d3e:	e9 81       	ldd	r30, Y+1	; 0x01
   18d40:	fa 81       	ldd	r31, Y+2	; 0x02
   18d42:	09 95       	icall

  asm volatile("pop r13" "\n\t"
   18d44:	df 90       	pop	r13
   18d46:	cf 90       	pop	r12
	           "pop r12" "\n\t"
	              ::);

  asm volatile("pop r11" "\n\t"
   18d48:	bf 90       	pop	r11
   18d4a:	af 90       	pop	r10
	           "pop r10" "\n\t"
	              ::);

  asm volatile("pop r9" "\n\t"
   18d4c:	9f 90       	pop	r9
   18d4e:	8f 90       	pop	r8
   18d50:	28 96       	adiw	r28, 0x08	; 8
   18d52:	0f b6       	in	r0, 0x3f	; 63
   18d54:	f8 94       	cli
   18d56:	de bf       	out	0x3e, r29	; 62
   18d58:	0f be       	out	0x3f, r0	; 63
   18d5a:	cd bf       	out	0x3d, r28	; 61
   18d5c:	df 91       	pop	r29
   18d5e:	cf 91       	pop	r28
   18d60:	08 95       	ret

00018d62 <postTask>:
	           "pop r8" "\n\t"
	              ::);
  return; 


}


void postTask(void (*tp) (void), uint16_t priority)
{
   18d62:	cf 93       	push	r28
   18d64:	df 93       	push	r29
   18d66:	cd b7       	in	r28, 0x3d	; 61
   18d68:	de b7       	in	r29, 0x3e	; 62
   18d6a:	26 97       	sbiw	r28, 0x06	; 6
   18d6c:	0f b6       	in	r0, 0x3f	; 63
   18d6e:	f8 94       	cli
   18d70:	de bf       	out	0x3e, r29	; 62
   18d72:	0f be       	out	0x3f, r0	; 63
   18d74:	cd bf       	out	0x3d, r28	; 61
   18d76:	9c 83       	std	Y+4, r25	; 0x04
   18d78:	8b 83       	std	Y+3, r24	; 0x03
   18d7a:	7e 83       	std	Y+6, r23	; 0x06
   18d7c:	6d 83       	std	Y+5, r22	; 0x05
   void (*fp)(void) = (void (*)(void))POST_TASK_SYSCALL; 
   18d7e:	88 e5       	ldi	r24, 0x58	; 88
   18d80:	9a ee       	ldi	r25, 0xEA	; 234
   18d82:	9a 83       	std	Y+2, r25	; 0x02
   18d84:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18d86:	4f 93       	push	r20
   18d88:	5f 93       	push	r21
   18d8a:	6f 93       	push	r22
   18d8c:	7f 93       	push	r23
                "push r21" "\n\t"
				"push r22" "\n\t"
				"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   18d8e:	8b 81       	ldd	r24, Y+3	; 0x03
   18d90:	9c 81       	ldd	r25, Y+4	; 0x04
   18d92:	48 2f       	mov	r20, r24
   18d94:	59 2f       	mov	r21, r25
	             "mov r21, %B0" "\n\t"
				 :
				 :"r" (tp)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   18d96:	8d 81       	ldd	r24, Y+5	; 0x05
   18d98:	9e 81       	ldd	r25, Y+6	; 0x06
   18d9a:	68 2f       	mov	r22, r24
   18d9c:	79 2f       	mov	r23, r25
	             "mov r23, %B0" "\n\t"
				 :
				 :"r" (priority)
                );

  fp(); 
   18d9e:	e9 81       	ldd	r30, Y+1	; 0x01
   18da0:	fa 81       	ldd	r31, Y+2	; 0x02
   18da2:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   18da4:	7f 91       	pop	r23
   18da6:	6f 91       	pop	r22
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   18da8:	5f 91       	pop	r21
   18daa:	4f 91       	pop	r20
   18dac:	26 96       	adiw	r28, 0x06	; 6
   18dae:	0f b6       	in	r0, 0x3f	; 63
   18db0:	f8 94       	cli
   18db2:	de bf       	out	0x3e, r29	; 62
   18db4:	0f be       	out	0x3f, r0	; 63
   18db6:	cd bf       	out	0x3d, r28	; 61
   18db8:	df 91       	pop	r29
   18dba:	cf 91       	pop	r28
   18dbc:	08 95       	ret

00018dbe <postTaskWithoutLogging>:
	           "pop r20" "\n\t"
	              ::);
  return; 


}




void postTaskWithoutLogging(void (*tp) (void), uint16_t priority)
{
   18dbe:	cf 93       	push	r28
   18dc0:	df 93       	push	r29
   18dc2:	cd b7       	in	r28, 0x3d	; 61
   18dc4:	de b7       	in	r29, 0x3e	; 62
   18dc6:	26 97       	sbiw	r28, 0x06	; 6
   18dc8:	0f b6       	in	r0, 0x3f	; 63
   18dca:	f8 94       	cli
   18dcc:	de bf       	out	0x3e, r29	; 62
   18dce:	0f be       	out	0x3f, r0	; 63
   18dd0:	cd bf       	out	0x3d, r28	; 61
   18dd2:	9c 83       	std	Y+4, r25	; 0x04
   18dd4:	8b 83       	std	Y+3, r24	; 0x03
   18dd6:	7e 83       	std	Y+6, r23	; 0x06
   18dd8:	6d 83       	std	Y+5, r22	; 0x05
   void (*fp)(void) = (void (*)(void))POST_TASK_SYSCALL; 
   18dda:	88 e5       	ldi	r24, 0x58	; 88
   18ddc:	9a ee       	ldi	r25, 0xEA	; 234
   18dde:	9a 83       	std	Y+2, r25	; 0x02
   18de0:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18de2:	4f 93       	push	r20
   18de4:	5f 93       	push	r21
   18de6:	6f 93       	push	r22
   18de8:	7f 93       	push	r23
                "push r21" "\n\t"
				"push r22" "\n\t"
				"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   18dea:	8b 81       	ldd	r24, Y+3	; 0x03
   18dec:	9c 81       	ldd	r25, Y+4	; 0x04
   18dee:	48 2f       	mov	r20, r24
   18df0:	59 2f       	mov	r21, r25
	             "mov r21, %B0" "\n\t"
				 :
				 :"r" (tp)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   18df2:	8d 81       	ldd	r24, Y+5	; 0x05
   18df4:	9e 81       	ldd	r25, Y+6	; 0x06
   18df6:	68 2f       	mov	r22, r24
   18df8:	79 2f       	mov	r23, r25
	             "mov r23, %B0" "\n\t"
				 :
				 :"r" (priority)
                );

  fp(); 
   18dfa:	e9 81       	ldd	r30, Y+1	; 0x01
   18dfc:	fa 81       	ldd	r31, Y+2	; 0x02
   18dfe:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   18e00:	7f 91       	pop	r23
   18e02:	6f 91       	pop	r22
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   18e04:	5f 91       	pop	r21
   18e06:	4f 91       	pop	r20
   18e08:	26 96       	adiw	r28, 0x06	; 6
   18e0a:	0f b6       	in	r0, 0x3f	; 63
   18e0c:	f8 94       	cli
   18e0e:	de bf       	out	0x3e, r29	; 62
   18e10:	0f be       	out	0x3f, r0	; 63
   18e12:	cd bf       	out	0x3d, r28	; 61
   18e14:	df 91       	pop	r29
   18e16:	cf 91       	pop	r28
   18e18:	08 95       	ret

00018e1a <getCurrentThreadControlBlockAddr>:
	           "pop r20" "\n\t"
	              ::);
  return; 


}


thread_create_block_type *getCurrentThreadControlBlockAddr()
{
   18e1a:	cf 93       	push	r28
   18e1c:	df 93       	push	r29
   18e1e:	cd b7       	in	r28, 0x3d	; 61
   18e20:	de b7       	in	r29, 0x3e	; 62
   18e22:	24 97       	sbiw	r28, 0x04	; 4
   18e24:	0f b6       	in	r0, 0x3f	; 63
   18e26:	f8 94       	cli
   18e28:	de bf       	out	0x3e, r29	; 62
   18e2a:	0f be       	out	0x3f, r0	; 63
   18e2c:	cd bf       	out	0x3d, r28	; 61
   thread_create_block_type *blockinfo; 
   void (*getaddrfp)(void) = (void (*)(void))GET_THREAD_CONTROL_BLOCK; 
   18e2e:	84 ed       	ldi	r24, 0xD4	; 212
   18e30:	9a ee       	ldi	r25, 0xEA	; 234
   18e32:	9a 83       	std	Y+2, r25	; 0x02
   18e34:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18e36:	4f 93       	push	r20
   18e38:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   18e3a:	e9 81       	ldd	r30, Y+1	; 0x01
   18e3c:	fa 81       	ldd	r31, Y+2	; 0x02
   18e3e:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18e40:	84 2f       	mov	r24, r20
   18e42:	95 2f       	mov	r25, r21
   18e44:	9c 83       	std	Y+4, r25	; 0x04
   18e46:	8b 83       	std	Y+3, r24	; 0x03
	              " mov %B0, r21" "\n\t"
				 :"=r" (blockinfo)
				 :
               );
    asm volatile("pop r21" "\n\t"
   18e48:	5f 91       	pop	r21
   18e4a:	4f 91       	pop	r20
	               "pop r20" "\n\t"
	               ::);
   return blockinfo; 
   18e4c:	8b 81       	ldd	r24, Y+3	; 0x03
   18e4e:	9c 81       	ldd	r25, Y+4	; 0x04
   18e50:	24 96       	adiw	r28, 0x04	; 4
   18e52:	0f b6       	in	r0, 0x3f	; 63
   18e54:	f8 94       	cli
   18e56:	de bf       	out	0x3e, r29	; 62
   18e58:	0f be       	out	0x3f, r0	; 63
   18e5a:	cd bf       	out	0x3d, r28	; 61
   18e5c:	df 91       	pop	r29
   18e5e:	cf 91       	pop	r28
   18e60:	08 95       	ret

00018e62 <getCurrentThreadControlMutexAddr>:
}


void *getCurrentThreadControlMutexAddr()
{
   18e62:	cf 93       	push	r28
   18e64:	df 93       	push	r29
   18e66:	cd b7       	in	r28, 0x3d	; 61
   18e68:	de b7       	in	r29, 0x3e	; 62
   18e6a:	24 97       	sbiw	r28, 0x04	; 4
   18e6c:	0f b6       	in	r0, 0x3f	; 63
   18e6e:	f8 94       	cli
   18e70:	de bf       	out	0x3e, r29	; 62
   18e72:	0f be       	out	0x3f, r0	; 63
   18e74:	cd bf       	out	0x3d, r28	; 61
   void *blockinfo; 
   void (*getaddrfp)(void) = (void (*)(void))GET_THREAD_CONTROL_MUTEX; 
   18e76:	88 ed       	ldi	r24, 0xD8	; 216
   18e78:	9a ee       	ldi	r25, 0xEA	; 234
   18e7a:	9a 83       	std	Y+2, r25	; 0x02
   18e7c:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18e7e:	4f 93       	push	r20
   18e80:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   18e82:	e9 81       	ldd	r30, Y+1	; 0x01
   18e84:	fa 81       	ldd	r31, Y+2	; 0x02
   18e86:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18e88:	84 2f       	mov	r24, r20
   18e8a:	95 2f       	mov	r25, r21
   18e8c:	9c 83       	std	Y+4, r25	; 0x04
   18e8e:	8b 83       	std	Y+3, r24	; 0x03
	              " mov %B0, r21" "\n\t"
				 :"=r" (blockinfo)
				 :
               );
    asm volatile("pop r21" "\n\t"
   18e90:	5f 91       	pop	r21
   18e92:	4f 91       	pop	r20
	               "pop r20" "\n\t"
	               ::);
   return blockinfo; 
   18e94:	8b 81       	ldd	r24, Y+3	; 0x03
   18e96:	9c 81       	ldd	r25, Y+4	; 0x04
   18e98:	24 96       	adiw	r28, 0x04	; 4
   18e9a:	0f b6       	in	r0, 0x3f	; 63
   18e9c:	f8 94       	cli
   18e9e:	de bf       	out	0x3e, r29	; 62
   18ea0:	0f be       	out	0x3f, r0	; 63
   18ea2:	cd bf       	out	0x3d, r28	; 61
   18ea4:	df 91       	pop	r29
   18ea6:	cf 91       	pop	r28
   18ea8:	08 95       	ret

00018eaa <createThread>:
}





void createThread(void (*fp)(), uint8_t* ram_start, uint8_t *stack_ptr, uint8_t priority, char *threadname)
{
   18eaa:	0f 93       	push	r16
   18eac:	1f 93       	push	r17
   18eae:	cf 93       	push	r28
   18eb0:	df 93       	push	r29
   18eb2:	cd b7       	in	r28, 0x3d	; 61
   18eb4:	de b7       	in	r29, 0x3e	; 62
   18eb6:	2f 97       	sbiw	r28, 0x0f	; 15
   18eb8:	0f b6       	in	r0, 0x3f	; 63
   18eba:	f8 94       	cli
   18ebc:	de bf       	out	0x3e, r29	; 62
   18ebe:	0f be       	out	0x3f, r0	; 63
   18ec0:	cd bf       	out	0x3d, r28	; 61
   18ec2:	98 87       	std	Y+8, r25	; 0x08
   18ec4:	8f 83       	std	Y+7, r24	; 0x07
   18ec6:	7a 87       	std	Y+10, r23	; 0x0a
   18ec8:	69 87       	std	Y+9, r22	; 0x09
   18eca:	5c 87       	std	Y+12, r21	; 0x0c
   18ecc:	4b 87       	std	Y+11, r20	; 0x0b
   18ece:	2d 87       	std	Y+13, r18	; 0x0d
   18ed0:	1f 87       	std	Y+15, r17	; 0x0f
   18ed2:	0e 87       	std	Y+14, r16	; 0x0e
 
 
   mutex* createthreadmutex; 
   thread_create_block_type *threadblock;
   void (*getaddrfp)(void) = (void (*)(void))CREATE_THERAD_SYSCALL;
   18ed4:	8c ed       	ldi	r24, 0xDC	; 220
   18ed6:	9a ee       	ldi	r25, 0xEA	; 234
   18ed8:	9a 83       	std	Y+2, r25	; 0x02
   18eda:	89 83       	std	Y+1, r24	; 0x01

  
   threadblock = getCurrentThreadControlBlockAddr(); 
   18edc:	0e 94 0d c7 	call	0x18e1a
   18ee0:	9c 83       	std	Y+4, r25	; 0x04
   18ee2:	8b 83       	std	Y+3, r24	; 0x03
   createthreadmutex = (mutex *)getCurrentThreadControlMutexAddr(); 
   18ee4:	0e 94 31 c7 	call	0x18e62
   18ee8:	9e 83       	std	Y+6, r25	; 0x06
   18eea:	8d 83       	std	Y+5, r24	; 0x05
   
   Mutex_lock(createthreadmutex);
   18eec:	8d 81       	ldd	r24, Y+5	; 0x05
   18eee:	9e 81       	ldd	r25, Y+6	; 0x06
   18ef0:	0e 94 d1 bd 	call	0x17ba2
     
   threadblock-> fp = fp; 
   18ef4:	eb 81       	ldd	r30, Y+3	; 0x03
   18ef6:	fc 81       	ldd	r31, Y+4	; 0x04
   18ef8:	8f 81       	ldd	r24, Y+7	; 0x07
   18efa:	98 85       	ldd	r25, Y+8	; 0x08
   18efc:	91 83       	std	Z+1, r25	; 0x01
   18efe:	80 83       	st	Z, r24
   threadblock->ram_start = ram_start; 
   18f00:	eb 81       	ldd	r30, Y+3	; 0x03
   18f02:	fc 81       	ldd	r31, Y+4	; 0x04
   18f04:	89 85       	ldd	r24, Y+9	; 0x09
   18f06:	9a 85       	ldd	r25, Y+10	; 0x0a
   18f08:	93 83       	std	Z+3, r25	; 0x03
   18f0a:	82 83       	std	Z+2, r24	; 0x02
   threadblock->stack_ptr = stack_ptr; 
   18f0c:	eb 81       	ldd	r30, Y+3	; 0x03
   18f0e:	fc 81       	ldd	r31, Y+4	; 0x04
   18f10:	8b 85       	ldd	r24, Y+11	; 0x0b
   18f12:	9c 85       	ldd	r25, Y+12	; 0x0c
   18f14:	95 83       	std	Z+5, r25	; 0x05
   18f16:	84 83       	std	Z+4, r24	; 0x04
   threadblock->priority = priority;
   18f18:	eb 81       	ldd	r30, Y+3	; 0x03
   18f1a:	fc 81       	ldd	r31, Y+4	; 0x04
   18f1c:	8d 85       	ldd	r24, Y+13	; 0x0d
   18f1e:	86 83       	std	Z+6, r24	; 0x06
   threadblock->threadname = threadname; 
   18f20:	eb 81       	ldd	r30, Y+3	; 0x03
   18f22:	fc 81       	ldd	r31, Y+4	; 0x04
   18f24:	8e 85       	ldd	r24, Y+14	; 0x0e
   18f26:	9f 85       	ldd	r25, Y+15	; 0x0f
   18f28:	90 87       	std	Z+8, r25	; 0x08
   18f2a:	87 83       	std	Z+7, r24	; 0x07

   getaddrfp(); 
   18f2c:	e9 81       	ldd	r30, Y+1	; 0x01
   18f2e:	fa 81       	ldd	r31, Y+2	; 0x02
   18f30:	09 95       	icall
   
   sleepThread(20); 
   18f32:	84 e1       	ldi	r24, 0x14	; 20
   18f34:	90 e0       	ldi	r25, 0x00	; 0
   18f36:	0e 94 e0 c5 	call	0x18bc0
   
  
   Mutex_unlock(createthreadmutex); 
   18f3a:	8d 81       	ldd	r24, Y+5	; 0x05
   18f3c:	9e 81       	ldd	r25, Y+6	; 0x06
   18f3e:	0e 94 20 be 	call	0x17c40
   18f42:	2f 96       	adiw	r28, 0x0f	; 15
   18f44:	0f b6       	in	r0, 0x3f	; 63
   18f46:	f8 94       	cli
   18f48:	de bf       	out	0x3e, r29	; 62
   18f4a:	0f be       	out	0x3f, r0	; 63
   18f4c:	cd bf       	out	0x3d, r28	; 61
   18f4e:	df 91       	pop	r29
   18f50:	cf 91       	pop	r28
   18f52:	1f 91       	pop	r17
   18f54:	0f 91       	pop	r16
   18f56:	08 95       	ret

00018f58 <setThreadTerminateHandler>:

   return; 
}




void setThreadTerminateHandler(void (*tp) (void))
{
   18f58:	cf 93       	push	r28
   18f5a:	df 93       	push	r29
   18f5c:	cd b7       	in	r28, 0x3d	; 61
   18f5e:	de b7       	in	r29, 0x3e	; 62
   18f60:	24 97       	sbiw	r28, 0x04	; 4
   18f62:	0f b6       	in	r0, 0x3f	; 63
   18f64:	f8 94       	cli
   18f66:	de bf       	out	0x3e, r29	; 62
   18f68:	0f be       	out	0x3f, r0	; 63
   18f6a:	cd bf       	out	0x3d, r28	; 61
   18f6c:	9c 83       	std	Y+4, r25	; 0x04
   18f6e:	8b 83       	std	Y+3, r24	; 0x03
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_THREAD_TERMINATE_TASK; 
   18f70:	80 e0       	ldi	r24, 0x00	; 0
   18f72:	9b ee       	ldi	r25, 0xEB	; 235
   18f74:	9a 83       	std	Y+2, r25	; 0x02
   18f76:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18f78:	4f 93       	push	r20
   18f7a:	5f 93       	push	r21
                "push r21" "\n\t"
				        ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   18f7c:	8b 81       	ldd	r24, Y+3	; 0x03
   18f7e:	9c 81       	ldd	r25, Y+4	; 0x04
   18f80:	48 2f       	mov	r20, r24
   18f82:	59 2f       	mov	r21, r25
	             "mov r21, %B0" "\n\t"
				 :
				 :"r" (tp)
                );


  fp(); 
   18f84:	e9 81       	ldd	r30, Y+1	; 0x01
   18f86:	fa 81       	ldd	r31, Y+2	; 0x02
   18f88:	09 95       	icall

  asm volatile("pop r21" "\n\t"
   18f8a:	5f 91       	pop	r21
   18f8c:	4f 91       	pop	r20
   18f8e:	24 96       	adiw	r28, 0x04	; 4
   18f90:	0f b6       	in	r0, 0x3f	; 63
   18f92:	f8 94       	cli
   18f94:	de bf       	out	0x3e, r29	; 62
   18f96:	0f be       	out	0x3f, r0	; 63
   18f98:	cd bf       	out	0x3d, r28	; 61
   18f9a:	df 91       	pop	r29
   18f9c:	cf 91       	pop	r28
   18f9e:	08 95       	ret

00018fa0 <setTimerFunction>:
	             "pop r20" "\n\t"
	             ::);

  return; 


}


void setTimerFunction(uint16_t period, uint8_t type, void (*callback)(void))
{
   18fa0:	cf 93       	push	r28
   18fa2:	df 93       	push	r29
   18fa4:	cd b7       	in	r28, 0x3d	; 61
   18fa6:	de b7       	in	r29, 0x3e	; 62
   18fa8:	29 97       	sbiw	r28, 0x09	; 9
   18faa:	0f b6       	in	r0, 0x3f	; 63
   18fac:	f8 94       	cli
   18fae:	de bf       	out	0x3e, r29	; 62
   18fb0:	0f be       	out	0x3f, r0	; 63
   18fb2:	cd bf       	out	0x3d, r28	; 61
   18fb4:	9e 83       	std	Y+6, r25	; 0x06
   18fb6:	8d 83       	std	Y+5, r24	; 0x05
   18fb8:	6f 83       	std	Y+7, r22	; 0x07
   18fba:	59 87       	std	Y+9, r21	; 0x09
   18fbc:	48 87       	std	Y+8, r20	; 0x08
	
	 void (*fp)(void) = (void (*)(void))SYSCALL_TIMER_FIRE_TASK; 
   18fbe:	84 e0       	ldi	r24, 0x04	; 4
   18fc0:	9b ee       	ldi	r25, 0xEB	; 235
   18fc2:	9c 83       	std	Y+4, r25	; 0x04
   18fc4:	8b 83       	std	Y+3, r24	; 0x03
 	 uint16_t type16; 

   type16 = type; 
   18fc6:	8f 81       	ldd	r24, Y+7	; 0x07
   18fc8:	99 27       	eor	r25, r25
   18fca:	9a 83       	std	Y+2, r25	; 0x02
   18fcc:	89 83       	std	Y+1, r24	; 0x01
   
   asm volatile("push r18" "\n\t"
   18fce:	2f 93       	push	r18
   18fd0:	3f 93       	push	r19
   18fd2:	4f 93       	push	r20
   18fd4:	5f 93       	push	r21
   18fd6:	6f 93       	push	r22
   18fd8:	7f 93       	push	r23
                "push r19" "\n\t"
								"push r20" "\n\t"
								"push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"								
                ::);
   
   asm volatile(" mov r18, %A0" "\n\t"
   18fda:	8d 81       	ldd	r24, Y+5	; 0x05
   18fdc:	9e 81       	ldd	r25, Y+6	; 0x06
   18fde:	28 2f       	mov	r18, r24
   18fe0:	39 2f       	mov	r19, r25
	               "mov r19, %B0" "\n\t"
				 :
				 :"r" (period)
                );



   asm volatile(" mov r20, %A0" "\n\t"
   18fe2:	89 81       	ldd	r24, Y+1	; 0x01
   18fe4:	9a 81       	ldd	r25, Y+2	; 0x02
   18fe6:	48 2f       	mov	r20, r24
   18fe8:	59 2f       	mov	r21, r25
	               "mov r21, %B0" "\n\t"
				 :
				 :"r" (type16)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   18fea:	88 85       	ldd	r24, Y+8	; 0x08
   18fec:	99 85       	ldd	r25, Y+9	; 0x09
   18fee:	68 2f       	mov	r22, r24
   18ff0:	79 2f       	mov	r23, r25
	              " mov r23, %B0" "\n\t"
				 :
				 :"r" (callback)
                );

  fp(); 
   18ff2:	eb 81       	ldd	r30, Y+3	; 0x03
   18ff4:	fc 81       	ldd	r31, Y+4	; 0x04
   18ff6:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   18ff8:	7f 91       	pop	r23
   18ffa:	6f 91       	pop	r22
	             "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   18ffc:	5f 91       	pop	r21
   18ffe:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
	              	
	asm volatile("pop r19" "\n\t"
   19000:	3f 91       	pop	r19
   19002:	2f 91       	pop	r18
   19004:	29 96       	adiw	r28, 0x09	; 9
   19006:	0f b6       	in	r0, 0x3f	; 63
   19008:	f8 94       	cli
   1900a:	de bf       	out	0x3e, r29	; 62
   1900c:	0f be       	out	0x3f, r0	; 63
   1900e:	cd bf       	out	0x3d, r28	; 61
   19010:	df 91       	pop	r29
   19012:	cf 91       	pop	r28
   19014:	08 95       	ret

00019016 <__divmodhi4>:
   19016:	97 fb       	bst	r25, 7
   19018:	09 2e       	mov	r0, r25
   1901a:	07 26       	eor	r0, r23
   1901c:	0a d0       	rcall	.+20     	; 0x19032
   1901e:	77 fd       	sbrc	r23, 7
   19020:	04 d0       	rcall	.+8      	; 0x1902a
   19022:	0c d0       	rcall	.+24     	; 0x1903c
   19024:	06 d0       	rcall	.+12     	; 0x19032
   19026:	00 20       	and	r0, r0
   19028:	1a f4       	brpl	.+6      	; 0x19030

0001902a <__divmodhi4_neg2>:
   1902a:	70 95       	com	r23
   1902c:	61 95       	neg	r22
   1902e:	7f 4f       	sbci	r23, 0xFF	; 255

00019030 <__divmodhi4_exit>:
   19030:	08 95       	ret

00019032 <__divmodhi4_neg1>:
   19032:	f6 f7       	brtc	.-4      	; 0x19030
   19034:	90 95       	com	r25
   19036:	81 95       	neg	r24
   19038:	9f 4f       	sbci	r25, 0xFF	; 255
   1903a:	08 95       	ret

0001903c <__udivmodhi4>:
   1903c:	aa 1b       	sub	r26, r26
   1903e:	bb 1b       	sub	r27, r27
   19040:	51 e1       	ldi	r21, 0x11	; 17
   19042:	07 c0       	rjmp	.+14     	; 0x19052

00019044 <__udivmodhi4_loop>:
   19044:	aa 1f       	adc	r26, r26
   19046:	bb 1f       	adc	r27, r27
   19048:	a6 17       	cp	r26, r22
   1904a:	b7 07       	cpc	r27, r23
   1904c:	10 f0       	brcs	.+4      	; 0x19052
   1904e:	a6 1b       	sub	r26, r22
   19050:	b7 0b       	sbc	r27, r23

00019052 <__udivmodhi4_ep>:
   19052:	88 1f       	adc	r24, r24
   19054:	99 1f       	adc	r25, r25
   19056:	5a 95       	dec	r21
   19058:	a9 f7       	brne	.-22     	; 0x19044
   1905a:	80 95       	com	r24
   1905c:	90 95       	com	r25
   1905e:	bc 01       	movw	r22, r24
   19060:	cd 01       	movw	r24, r26
   19062:	08 95       	ret
