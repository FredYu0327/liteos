
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000022da  00016800  00016800  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          0000005c  00800a5a  00800a5a  0000234e  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  00002350  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  00002758  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 000001a0  00000000  00000000  000027dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000092d  00000000  00000000  0000297c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004aba  00000000  00000000  000032a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000eab  00000000  00000000  00007d63  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001bfb  00000000  00000000  00008c0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000700  00000000  00000000  0000a809  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000273  00000000  00000000  0000af09  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00016800 <__vectors>:
   16800:	0c 94 46 b4 	jmp	0x1688c
   16804:	0c 94 63 b4 	jmp	0x168c6
   16808:	0c 94 63 b4 	jmp	0x168c6
   1680c:	0c 94 63 b4 	jmp	0x168c6
   16810:	0c 94 63 b4 	jmp	0x168c6
   16814:	0c 94 63 b4 	jmp	0x168c6
   16818:	0c 94 63 b4 	jmp	0x168c6
   1681c:	0c 94 63 b4 	jmp	0x168c6
   16820:	0c 94 63 b4 	jmp	0x168c6
   16824:	0c 94 63 b4 	jmp	0x168c6
   16828:	0c 94 63 b4 	jmp	0x168c6
   1682c:	0c 94 63 b4 	jmp	0x168c6
   16830:	0c 94 63 b4 	jmp	0x168c6
   16834:	0c 94 63 b4 	jmp	0x168c6
   16838:	0c 94 63 b4 	jmp	0x168c6
   1683c:	0c 94 63 b4 	jmp	0x168c6
   16840:	0c 94 63 b4 	jmp	0x168c6
   16844:	0c 94 63 b4 	jmp	0x168c6
   16848:	0c 94 63 b4 	jmp	0x168c6
   1684c:	0c 94 63 b4 	jmp	0x168c6
   16850:	0c 94 63 b4 	jmp	0x168c6
   16854:	0c 94 63 b4 	jmp	0x168c6
   16858:	0c 94 63 b4 	jmp	0x168c6
   1685c:	0c 94 63 b4 	jmp	0x168c6
   16860:	0c 94 63 b4 	jmp	0x168c6
   16864:	0c 94 63 b4 	jmp	0x168c6
   16868:	0c 94 63 b4 	jmp	0x168c6
   1686c:	0c 94 63 b4 	jmp	0x168c6
   16870:	0c 94 63 b4 	jmp	0x168c6
   16874:	0c 94 63 b4 	jmp	0x168c6
   16878:	0c 94 63 b4 	jmp	0x168c6
   1687c:	0c 94 63 b4 	jmp	0x168c6
   16880:	0c 94 63 b4 	jmp	0x168c6
   16884:	0c 94 63 b4 	jmp	0x168c6
   16888:	0c 94 63 b4 	jmp	0x168c6

0001688c <__ctors_end>:
   1688c:	11 24       	eor	r1, r1
   1688e:	1f be       	out	0x3f, r1	; 63
   16890:	c2 e2       	ldi	r28, 0x22	; 34
   16892:	db e0       	ldi	r29, 0x0B	; 11
   16894:	de bf       	out	0x3e, r29	; 62
   16896:	cd bf       	out	0x3d, r28	; 61

00016898 <__do_copy_data>:
   16898:	1a e0       	ldi	r17, 0x0A	; 10
   1689a:	aa e5       	ldi	r26, 0x5A	; 90
   1689c:	ba e0       	ldi	r27, 0x0A	; 10
   1689e:	ea ed       	ldi	r30, 0xDA	; 218
   168a0:	fa e8       	ldi	r31, 0x8A	; 138
   168a2:	01 e0       	ldi	r16, 0x01	; 1
   168a4:	0b bf       	out	0x3b, r16	; 59
   168a6:	02 c0       	rjmp	.+4      	; 0x168ac
   168a8:	07 90       	elpm	r0, Z+
   168aa:	0d 92       	st	X+, r0
   168ac:	aa 35       	cpi	r26, 0x5A	; 90
   168ae:	b1 07       	cpc	r27, r17
   168b0:	d9 f7       	brne	.-10     	; 0x168a8

000168b2 <__do_clear_bss>:
   168b2:	1a e0       	ldi	r17, 0x0A	; 10
   168b4:	aa e5       	ldi	r26, 0x5A	; 90
   168b6:	ba e0       	ldi	r27, 0x0A	; 10
   168b8:	01 c0       	rjmp	.+2      	; 0x168bc

000168ba <.do_clear_bss_loop>:
   168ba:	1d 92       	st	X+, r1

000168bc <.do_clear_bss_start>:
   168bc:	a6 3b       	cpi	r26, 0xB6	; 182
   168be:	b1 07       	cpc	r27, r17
   168c0:	e1 f7       	brne	.-8      	; 0x168ba
   168c2:	0c 94 78 b4 	jmp	0x168f0

000168c6 <__bad_interrupt>:
   168c6:	0c 94 00 b4 	jmp	0x16800

000168ca <foo_stack>:




void foo_stack(){
   168ca:	cf 93       	push	r28
   168cc:	df 93       	push	r29
   168ce:	cd b7       	in	r28, 0x3d	; 61
   168d0:	de b7       	in	r29, 0x3e	; 62
   168d2:	2a 97       	sbiw	r28, 0x0a	; 10
   168d4:	0f b6       	in	r0, 0x3f	; 63
   168d6:	f8 94       	cli
   168d8:	de bf       	out	0x3e, r29	; 62
   168da:	0f be       	out	0x3f, r0	; 63
   168dc:	cd bf       	out	0x3d, r28	; 61
   168de:	2a 96       	adiw	r28, 0x0a	; 10
   168e0:	0f b6       	in	r0, 0x3f	; 63
   168e2:	f8 94       	cli
   168e4:	de bf       	out	0x3e, r29	; 62
   168e6:	0f be       	out	0x3f, r0	; 63
   168e8:	cd bf       	out	0x3d, r28	; 61
   168ea:	df 91       	pop	r29
   168ec:	cf 91       	pop	r28
   168ee:	08 95       	ret

000168f0 <main>:
	
	uint8_t local[10];
 
	 
	return; 

}

int main()
{
   168f0:	cf 93       	push	r28
   168f2:	df 93       	push	r29
   168f4:	cd b7       	in	r28, 0x3d	; 61
   168f6:	de b7       	in	r29, 0x3e	; 62
   168f8:	21 97       	sbiw	r28, 0x01	; 1
   168fa:	0f b6       	in	r0, 0x3f	; 63
   168fc:	f8 94       	cli
   168fe:	de bf       	out	0x3e, r29	; 62
   16900:	0f be       	out	0x3f, r0	; 63
   16902:	cd bf       	out	0x3d, r28	; 61
 uint8_t index;  
 __asm__ __volatile__("sei" ::); 
   16904:	78 94       	sei
 
 
 

while (1)
{ 
 //hibernateThread();
 //counter2++;
 //radioSend_string("Hello, world!\n"); 
 
 sleepThread(1000);
   16906:	88 ee       	ldi	r24, 0xE8	; 232
   16908:	93 e0       	ldi	r25, 0x03	; 3
   1690a:	0e 94 1b c3 	call	0x18636
 redToggle();
   1690e:	0e 94 ee b9 	call	0x173dc
 foo_stack();
   16912:	0e 94 65 b4 	call	0x168ca
  
}
   16916:	f7 cf       	rjmp	.-18     	; 0x16906

00016918 <get_light>:
#include "thread.h"
#include "system.h"

int get_light()
{
   16918:	cf 93       	push	r28
   1691a:	df 93       	push	r29
   1691c:	cd b7       	in	r28, 0x3d	; 61
   1691e:	de b7       	in	r29, 0x3e	; 62
   16920:	24 97       	sbiw	r28, 0x04	; 4
   16922:	0f b6       	in	r0, 0x3f	; 63
   16924:	f8 94       	cli
   16926:	de bf       	out	0x3e, r29	; 62
   16928:	0f be       	out	0x3f, r0	; 63
   1692a:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADC_READ_LIGHT;
   1692c:	80 e4       	ldi	r24, 0x40	; 64
   1692e:	9a ee       	ldi	r25, 0xEA	; 234
   16930:	9a 83       	std	Y+2, r25	; 0x02
   16932:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   16934:	0e 94 af c2 	call	0x1855e
   16938:	9c 83       	std	Y+4, r25	; 0x04
   1693a:	8b 83       	std	Y+3, r24	; 0x03
   fp(); 
   1693c:	e9 81       	ldd	r30, Y+1	; 0x01
   1693e:	fa 81       	ldd	r31, Y+2	; 0x02
   16940:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   16942:	eb 81       	ldd	r30, Y+3	; 0x03
   16944:	fc 81       	ldd	r31, Y+4	; 0x04
   16946:	01 90       	ld	r0, Z+
   16948:	f0 81       	ld	r31, Z
   1694a:	e0 2d       	mov	r30, r0
   1694c:	83 8d       	ldd	r24, Z+27	; 0x1b
   1694e:	94 8d       	ldd	r25, Z+28	; 0x1c
   16950:	24 96       	adiw	r28, 0x04	; 4
   16952:	0f b6       	in	r0, 0x3f	; 63
   16954:	f8 94       	cli
   16956:	de bf       	out	0x3e, r29	; 62
   16958:	0f be       	out	0x3f, r0	; 63
   1695a:	cd bf       	out	0x3d, r28	; 61
   1695c:	df 91       	pop	r29
   1695e:	cf 91       	pop	r28
   16960:	08 95       	ret

00016962 <get_temp>:
  
}


int get_temp()
{
   16962:	cf 93       	push	r28
   16964:	df 93       	push	r29
   16966:	cd b7       	in	r28, 0x3d	; 61
   16968:	de b7       	in	r29, 0x3e	; 62
   1696a:	24 97       	sbiw	r28, 0x04	; 4
   1696c:	0f b6       	in	r0, 0x3f	; 63
   1696e:	f8 94       	cli
   16970:	de bf       	out	0x3e, r29	; 62
   16972:	0f be       	out	0x3f, r0	; 63
   16974:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADC_READ_TEMP;
   16976:	84 e4       	ldi	r24, 0x44	; 68
   16978:	9a ee       	ldi	r25, 0xEA	; 234
   1697a:	9a 83       	std	Y+2, r25	; 0x02
   1697c:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   1697e:	0e 94 af c2 	call	0x1855e
   16982:	9c 83       	std	Y+4, r25	; 0x04
   16984:	8b 83       	std	Y+3, r24	; 0x03
   fp(); 
   16986:	e9 81       	ldd	r30, Y+1	; 0x01
   16988:	fa 81       	ldd	r31, Y+2	; 0x02
   1698a:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   1698c:	eb 81       	ldd	r30, Y+3	; 0x03
   1698e:	fc 81       	ldd	r31, Y+4	; 0x04
   16990:	01 90       	ld	r0, Z+
   16992:	f0 81       	ld	r31, Z
   16994:	e0 2d       	mov	r30, r0
   16996:	83 8d       	ldd	r24, Z+27	; 0x1b
   16998:	94 8d       	ldd	r25, Z+28	; 0x1c
   1699a:	24 96       	adiw	r28, 0x04	; 4
   1699c:	0f b6       	in	r0, 0x3f	; 63
   1699e:	f8 94       	cli
   169a0:	de bf       	out	0x3e, r29	; 62
   169a2:	0f be       	out	0x3f, r0	; 63
   169a4:	cd bf       	out	0x3d, r28	; 61
   169a6:	df 91       	pop	r29
   169a8:	cf 91       	pop	r28
   169aa:	08 95       	ret

000169ac <get_magx>:

}


int get_magx()
{
   169ac:	cf 93       	push	r28
   169ae:	df 93       	push	r29
   169b0:	cd b7       	in	r28, 0x3d	; 61
   169b2:	de b7       	in	r29, 0x3e	; 62
   169b4:	25 97       	sbiw	r28, 0x05	; 5
   169b6:	0f b6       	in	r0, 0x3f	; 63
   169b8:	f8 94       	cli
   169ba:	de bf       	out	0x3e, r29	; 62
   169bc:	0f be       	out	0x3f, r0	; 63
   169be:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   
   {_atomic_t test = _atomic_start();
   169c0:	0e 94 11 c2 	call	0x18422
   169c4:	8b 83       	std	Y+3, r24	; 0x03
   
   void (*fp)() = (void (*)(void))ADC_READ_MAGX;
   169c6:	88 e4       	ldi	r24, 0x48	; 72
   169c8:	9a ee       	ldi	r25, 0xEA	; 234
   169ca:	9a 83       	std	Y+2, r25	; 0x02
   169cc:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   169ce:	0e 94 af c2 	call	0x1855e
   169d2:	9d 83       	std	Y+5, r25	; 0x05
   169d4:	8c 83       	std	Y+4, r24	; 0x04
   fp(); 
   169d6:	e9 81       	ldd	r30, Y+1	; 0x01
   169d8:	fa 81       	ldd	r31, Y+2	; 0x02
   169da:	09 95       	icall
   
   _atomic_end(test);
   169dc:	8b 81       	ldd	r24, Y+3	; 0x03
   169de:	0e 94 2b c2 	call	0x18456
  }
   return (*current_thread)->data.adcstate.adcreading;  
   169e2:	ec 81       	ldd	r30, Y+4	; 0x04
   169e4:	fd 81       	ldd	r31, Y+5	; 0x05
   169e6:	01 90       	ld	r0, Z+
   169e8:	f0 81       	ld	r31, Z
   169ea:	e0 2d       	mov	r30, r0
   169ec:	83 8d       	ldd	r24, Z+27	; 0x1b
   169ee:	94 8d       	ldd	r25, Z+28	; 0x1c
   169f0:	25 96       	adiw	r28, 0x05	; 5
   169f2:	0f b6       	in	r0, 0x3f	; 63
   169f4:	f8 94       	cli
   169f6:	de bf       	out	0x3e, r29	; 62
   169f8:	0f be       	out	0x3f, r0	; 63
   169fa:	cd bf       	out	0x3d, r28	; 61
   169fc:	df 91       	pop	r29
   169fe:	cf 91       	pop	r28
   16a00:	08 95       	ret

00016a02 <get_magy>:

}


int get_magy()
{
   16a02:	cf 93       	push	r28
   16a04:	df 93       	push	r29
   16a06:	cd b7       	in	r28, 0x3d	; 61
   16a08:	de b7       	in	r29, 0x3e	; 62
   16a0a:	25 97       	sbiw	r28, 0x05	; 5
   16a0c:	0f b6       	in	r0, 0x3f	; 63
   16a0e:	f8 94       	cli
   16a10:	de bf       	out	0x3e, r29	; 62
   16a12:	0f be       	out	0x3f, r0	; 63
   16a14:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
  {_atomic_t test = _atomic_start();
   16a16:	0e 94 11 c2 	call	0x18422
   16a1a:	8b 83       	std	Y+3, r24	; 0x03
   void (*fp)() = (void (*)(void))ADC_READ_MAGY;
   16a1c:	8c e4       	ldi	r24, 0x4C	; 76
   16a1e:	9a ee       	ldi	r25, 0xEA	; 234
   16a20:	9a 83       	std	Y+2, r25	; 0x02
   16a22:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   16a24:	0e 94 af c2 	call	0x1855e
   16a28:	9d 83       	std	Y+5, r25	; 0x05
   16a2a:	8c 83       	std	Y+4, r24	; 0x04
   fp(); 
   16a2c:	e9 81       	ldd	r30, Y+1	; 0x01
   16a2e:	fa 81       	ldd	r31, Y+2	; 0x02
   16a30:	09 95       	icall
   
      
   _atomic_end(test);
   16a32:	8b 81       	ldd	r24, Y+3	; 0x03
   16a34:	0e 94 2b c2 	call	0x18456
  }
   return (*current_thread)->data.adcstate.adcreading;  
   16a38:	ec 81       	ldd	r30, Y+4	; 0x04
   16a3a:	fd 81       	ldd	r31, Y+5	; 0x05
   16a3c:	01 90       	ld	r0, Z+
   16a3e:	f0 81       	ld	r31, Z
   16a40:	e0 2d       	mov	r30, r0
   16a42:	83 8d       	ldd	r24, Z+27	; 0x1b
   16a44:	94 8d       	ldd	r25, Z+28	; 0x1c
   16a46:	25 96       	adiw	r28, 0x05	; 5
   16a48:	0f b6       	in	r0, 0x3f	; 63
   16a4a:	f8 94       	cli
   16a4c:	de bf       	out	0x3e, r29	; 62
   16a4e:	0f be       	out	0x3f, r0	; 63
   16a50:	cd bf       	out	0x3d, r28	; 61
   16a52:	df 91       	pop	r29
   16a54:	cf 91       	pop	r28
   16a56:	08 95       	ret

00016a58 <get_accx>:
}


int get_accx()
{
   16a58:	cf 93       	push	r28
   16a5a:	df 93       	push	r29
   16a5c:	cd b7       	in	r28, 0x3d	; 61
   16a5e:	de b7       	in	r29, 0x3e	; 62
   16a60:	24 97       	sbiw	r28, 0x04	; 4
   16a62:	0f b6       	in	r0, 0x3f	; 63
   16a64:	f8 94       	cli
   16a66:	de bf       	out	0x3e, r29	; 62
   16a68:	0f be       	out	0x3f, r0	; 63
   16a6a:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADC_READ_ACCX;
   16a6c:	80 e5       	ldi	r24, 0x50	; 80
   16a6e:	9a ee       	ldi	r25, 0xEA	; 234
   16a70:	9a 83       	std	Y+2, r25	; 0x02
   16a72:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   16a74:	0e 94 af c2 	call	0x1855e
   16a78:	9c 83       	std	Y+4, r25	; 0x04
   16a7a:	8b 83       	std	Y+3, r24	; 0x03
   fp(); 
   16a7c:	e9 81       	ldd	r30, Y+1	; 0x01
   16a7e:	fa 81       	ldd	r31, Y+2	; 0x02
   16a80:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   16a82:	eb 81       	ldd	r30, Y+3	; 0x03
   16a84:	fc 81       	ldd	r31, Y+4	; 0x04
   16a86:	01 90       	ld	r0, Z+
   16a88:	f0 81       	ld	r31, Z
   16a8a:	e0 2d       	mov	r30, r0
   16a8c:	83 8d       	ldd	r24, Z+27	; 0x1b
   16a8e:	94 8d       	ldd	r25, Z+28	; 0x1c
   16a90:	24 96       	adiw	r28, 0x04	; 4
   16a92:	0f b6       	in	r0, 0x3f	; 63
   16a94:	f8 94       	cli
   16a96:	de bf       	out	0x3e, r29	; 62
   16a98:	0f be       	out	0x3f, r0	; 63
   16a9a:	cd bf       	out	0x3d, r28	; 61
   16a9c:	df 91       	pop	r29
   16a9e:	cf 91       	pop	r28
   16aa0:	08 95       	ret

00016aa2 <get_accy>:
}


int get_accy()
{
   16aa2:	cf 93       	push	r28
   16aa4:	df 93       	push	r29
   16aa6:	cd b7       	in	r28, 0x3d	; 61
   16aa8:	de b7       	in	r29, 0x3e	; 62
   16aaa:	24 97       	sbiw	r28, 0x04	; 4
   16aac:	0f b6       	in	r0, 0x3f	; 63
   16aae:	f8 94       	cli
   16ab0:	de bf       	out	0x3e, r29	; 62
   16ab2:	0f be       	out	0x3f, r0	; 63
   16ab4:	cd bf       	out	0x3d, r28	; 61
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADC_READ_ACCY;
   16ab6:	84 e5       	ldi	r24, 0x54	; 84
   16ab8:	9a ee       	ldi	r25, 0xEA	; 234
   16aba:	9a 83       	std	Y+2, r25	; 0x02
   16abc:	89 83       	std	Y+1, r24	; 0x01
   current_thread = getCurrentThread();    
   16abe:	0e 94 af c2 	call	0x1855e
   16ac2:	9c 83       	std	Y+4, r25	; 0x04
   16ac4:	8b 83       	std	Y+3, r24	; 0x03
   fp(); 
   16ac6:	e9 81       	ldd	r30, Y+1	; 0x01
   16ac8:	fa 81       	ldd	r31, Y+2	; 0x02
   16aca:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   16acc:	eb 81       	ldd	r30, Y+3	; 0x03
   16ace:	fc 81       	ldd	r31, Y+4	; 0x04
   16ad0:	01 90       	ld	r0, Z+
   16ad2:	f0 81       	ld	r31, Z
   16ad4:	e0 2d       	mov	r30, r0
   16ad6:	83 8d       	ldd	r24, Z+27	; 0x1b
   16ad8:	94 8d       	ldd	r25, Z+28	; 0x1c
   16ada:	24 96       	adiw	r28, 0x04	; 4
   16adc:	0f b6       	in	r0, 0x3f	; 63
   16ade:	f8 94       	cli
   16ae0:	de bf       	out	0x3e, r29	; 62
   16ae2:	0f be       	out	0x3f, r0	; 63
   16ae4:	cd bf       	out	0x3d, r28	; 61
   16ae6:	df 91       	pop	r29
   16ae8:	cf 91       	pop	r28
   16aea:	08 95       	ret

00016aec <getCurrentEEPROMInfo>:



genericByteStorageTaskNode *getCurrentEEPROMInfo()
{
   16aec:	cf 93       	push	r28
   16aee:	df 93       	push	r29
   16af0:	cd b7       	in	r28, 0x3d	; 61
   16af2:	de b7       	in	r29, 0x3e	; 62
   16af4:	24 97       	sbiw	r28, 0x04	; 4
   16af6:	0f b6       	in	r0, 0x3f	; 63
   16af8:	f8 94       	cli
   16afa:	de bf       	out	0x3e, r29	; 62
   16afc:	0f be       	out	0x3f, r0	; 63
   16afe:	cd bf       	out	0x3d, r28	; 61
   genericByteStorageTaskNode *currenteeprominfoaddr;

   void (*getaddrfp)(void) = (void (*)(void))GET_EEPROM_STRUCTURE_HANDLE;
   16b00:	84 ea       	ldi	r24, 0xA4	; 164
   16b02:	9a ee       	ldi	r25, 0xEA	; 234
   16b04:	9a 83       	std	Y+2, r25	; 0x02
   16b06:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   16b08:	4f 93       	push	r20
   16b0a:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   16b0c:	e9 81       	ldd	r30, Y+1	; 0x01
   16b0e:	fa 81       	ldd	r31, Y+2	; 0x02
   16b10:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   16b12:	84 2f       	mov	r24, r20
   16b14:	95 2f       	mov	r25, r21
   16b16:	9c 83       	std	Y+4, r25	; 0x04
   16b18:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currenteeprominfoaddr)
				 :
                );
    asm volatile("pop r21" "\n\t"
   16b1a:	5f 91       	pop	r21
   16b1c:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currenteeprominfoaddr;
   16b1e:	8b 81       	ldd	r24, Y+3	; 0x03
   16b20:	9c 81       	ldd	r25, Y+4	; 0x04
   16b22:	24 96       	adiw	r28, 0x04	; 4
   16b24:	0f b6       	in	r0, 0x3f	; 63
   16b26:	f8 94       	cli
   16b28:	de bf       	out	0x3e, r29	; 62
   16b2a:	0f be       	out	0x3f, r0	; 63
   16b2c:	cd bf       	out	0x3d, r28	; 61
   16b2e:	df 91       	pop	r29
   16b30:	cf 91       	pop	r28
   16b32:	08 95       	ret

00016b34 <readFromEEPROM>:
}




//Turn off the interrupt, access the location, and use system call to implement poll based imlementation provided by avr libc

void readFromEEPROM(uint16_t addr, uint16_t nBytes, uint8_t *buffer)
{
   16b34:	cf 93       	push	r28
   16b36:	df 93       	push	r29
   16b38:	cd b7       	in	r28, 0x3d	; 61
   16b3a:	de b7       	in	r29, 0x3e	; 62
   16b3c:	2b 97       	sbiw	r28, 0x0b	; 11
   16b3e:	0f b6       	in	r0, 0x3f	; 63
   16b40:	f8 94       	cli
   16b42:	de bf       	out	0x3e, r29	; 62
   16b44:	0f be       	out	0x3f, r0	; 63
   16b46:	cd bf       	out	0x3d, r28	; 61
   16b48:	9f 83       	std	Y+7, r25	; 0x07
   16b4a:	8e 83       	std	Y+6, r24	; 0x06
   16b4c:	79 87       	std	Y+9, r23	; 0x09
   16b4e:	68 87       	std	Y+8, r22	; 0x08
   16b50:	5b 87       	std	Y+11, r21	; 0x0b
   16b52:	4a 87       	std	Y+10, r20	; 0x0a


	_atomic_t currentatomic;

	currentatomic = _atomic_start();
   16b54:	0e 94 11 c2 	call	0x18422
   16b58:	8d 83       	std	Y+5, r24	; 0x05


    genericByteStorageTaskNode *eeprominfoaddr;
    eeprominfoaddr = getCurrentEEPROMInfo();
   16b5a:	0e 94 76 b5 	call	0x16aec
   16b5e:	9c 83       	std	Y+4, r25	; 0x04
   16b60:	8b 83       	std	Y+3, r24	; 0x03

	void (*getaddrfp)(void) = (void (*)(void))READ_EEPROM_TASK;
   16b62:	88 ea       	ldi	r24, 0xA8	; 168
   16b64:	9a ee       	ldi	r25, 0xEA	; 234
   16b66:	9a 83       	std	Y+2, r25	; 0x02
   16b68:	89 83       	std	Y+1, r24	; 0x01

    eeprominfoaddr-> addr = addr;
   16b6a:	eb 81       	ldd	r30, Y+3	; 0x03
   16b6c:	fc 81       	ldd	r31, Y+4	; 0x04
   16b6e:	8e 81       	ldd	r24, Y+6	; 0x06
   16b70:	9f 81       	ldd	r25, Y+7	; 0x07
   16b72:	91 83       	std	Z+1, r25	; 0x01
   16b74:	80 83       	st	Z, r24
   	eeprominfoaddr-> nBytes = nBytes;
   16b76:	eb 81       	ldd	r30, Y+3	; 0x03
   16b78:	fc 81       	ldd	r31, Y+4	; 0x04
   16b7a:	88 85       	ldd	r24, Y+8	; 0x08
   16b7c:	99 85       	ldd	r25, Y+9	; 0x09
   16b7e:	93 83       	std	Z+3, r25	; 0x03
   16b80:	82 83       	std	Z+2, r24	; 0x02
   	eeprominfoaddr-> buffer = buffer;
   16b82:	eb 81       	ldd	r30, Y+3	; 0x03
   16b84:	fc 81       	ldd	r31, Y+4	; 0x04
   16b86:	8a 85       	ldd	r24, Y+10	; 0x0a
   16b88:	9b 85       	ldd	r25, Y+11	; 0x0b
   16b8a:	95 83       	std	Z+5, r25	; 0x05
   16b8c:	84 83       	std	Z+4, r24	; 0x04


    getaddrfp();
   16b8e:	e9 81       	ldd	r30, Y+1	; 0x01
   16b90:	fa 81       	ldd	r31, Y+2	; 0x02
   16b92:	09 95       	icall

	_atomic_end(currentatomic);
   16b94:	8d 81       	ldd	r24, Y+5	; 0x05
   16b96:	0e 94 2b c2 	call	0x18456
   16b9a:	2b 96       	adiw	r28, 0x0b	; 11
   16b9c:	0f b6       	in	r0, 0x3f	; 63
   16b9e:	f8 94       	cli
   16ba0:	de bf       	out	0x3e, r29	; 62
   16ba2:	0f be       	out	0x3f, r0	; 63
   16ba4:	cd bf       	out	0x3d, r28	; 61
   16ba6:	df 91       	pop	r29
   16ba8:	cf 91       	pop	r28
   16baa:	08 95       	ret

00016bac <writeToEEPROM>:
}




//Turn off the interrupt, access the location, and use system call to implement poll based implementation provided by avr libc

void writeToEEPROM(uint16_t addr, uint16_t nBytes, uint8_t *buffer)
{
   16bac:	cf 93       	push	r28
   16bae:	df 93       	push	r29
   16bb0:	cd b7       	in	r28, 0x3d	; 61
   16bb2:	de b7       	in	r29, 0x3e	; 62
   16bb4:	2b 97       	sbiw	r28, 0x0b	; 11
   16bb6:	0f b6       	in	r0, 0x3f	; 63
   16bb8:	f8 94       	cli
   16bba:	de bf       	out	0x3e, r29	; 62
   16bbc:	0f be       	out	0x3f, r0	; 63
   16bbe:	cd bf       	out	0x3d, r28	; 61
   16bc0:	9f 83       	std	Y+7, r25	; 0x07
   16bc2:	8e 83       	std	Y+6, r24	; 0x06
   16bc4:	79 87       	std	Y+9, r23	; 0x09
   16bc6:	68 87       	std	Y+8, r22	; 0x08
   16bc8:	5b 87       	std	Y+11, r21	; 0x0b
   16bca:	4a 87       	std	Y+10, r20	; 0x0a

	_atomic_t currentatomic;

	currentatomic = _atomic_start();
   16bcc:	0e 94 11 c2 	call	0x18422
   16bd0:	8d 83       	std	Y+5, r24	; 0x05

    genericByteStorageTaskNode *eeprominfoaddr;
    eeprominfoaddr = getCurrentEEPROMInfo();
   16bd2:	0e 94 76 b5 	call	0x16aec
   16bd6:	9c 83       	std	Y+4, r25	; 0x04
   16bd8:	8b 83       	std	Y+3, r24	; 0x03

	void (*getaddrfp)(void) = (void (*)(void))WRITE_EEPROM_TASK;
   16bda:	8c ea       	ldi	r24, 0xAC	; 172
   16bdc:	9a ee       	ldi	r25, 0xEA	; 234
   16bde:	9a 83       	std	Y+2, r25	; 0x02
   16be0:	89 83       	std	Y+1, r24	; 0x01

    eeprominfoaddr-> addr = addr;
   16be2:	eb 81       	ldd	r30, Y+3	; 0x03
   16be4:	fc 81       	ldd	r31, Y+4	; 0x04
   16be6:	8e 81       	ldd	r24, Y+6	; 0x06
   16be8:	9f 81       	ldd	r25, Y+7	; 0x07
   16bea:	91 83       	std	Z+1, r25	; 0x01
   16bec:	80 83       	st	Z, r24
	  eeprominfoaddr-> nBytes = nBytes;
   16bee:	eb 81       	ldd	r30, Y+3	; 0x03
   16bf0:	fc 81       	ldd	r31, Y+4	; 0x04
   16bf2:	88 85       	ldd	r24, Y+8	; 0x08
   16bf4:	99 85       	ldd	r25, Y+9	; 0x09
   16bf6:	93 83       	std	Z+3, r25	; 0x03
   16bf8:	82 83       	std	Z+2, r24	; 0x02
	  eeprominfoaddr-> buffer = buffer;
   16bfa:	eb 81       	ldd	r30, Y+3	; 0x03
   16bfc:	fc 81       	ldd	r31, Y+4	; 0x04
   16bfe:	8a 85       	ldd	r24, Y+10	; 0x0a
   16c00:	9b 85       	ldd	r25, Y+11	; 0x0b
   16c02:	95 83       	std	Z+5, r25	; 0x05
   16c04:	84 83       	std	Z+4, r24	; 0x04


    getaddrfp();
   16c06:	e9 81       	ldd	r30, Y+1	; 0x01
   16c08:	fa 81       	ldd	r31, Y+2	; 0x02
   16c0a:	09 95       	icall

	_atomic_end(currentatomic);
   16c0c:	8d 81       	ldd	r24, Y+5	; 0x05
   16c0e:	0e 94 2b c2 	call	0x18456
   16c12:	2b 96       	adiw	r28, 0x0b	; 11
   16c14:	0f b6       	in	r0, 0x3f	; 63
   16c16:	f8 94       	cli
   16c18:	de bf       	out	0x3e, r29	; 62
   16c1a:	0f be       	out	0x3f, r0	; 63
   16c1c:	cd bf       	out	0x3d, r28	; 61
   16c1e:	df 91       	pop	r29
   16c20:	cf 91       	pop	r28
   16c22:	08 95       	ret

00016c24 <getEventBlockAddress>:
volatile uint16_t globalpageoffset;
volatile uint8_t *globalbuffer;

void *getEventBlockAddress()
{
   16c24:	cf 93       	push	r28
   16c26:	df 93       	push	r29
   16c28:	cd b7       	in	r28, 0x3d	; 61
   16c2a:	de b7       	in	r29, 0x3e	; 62
   16c2c:	24 97       	sbiw	r28, 0x04	; 4
   16c2e:	0f b6       	in	r0, 0x3f	; 63
   16c30:	f8 94       	cli
   16c32:	de bf       	out	0x3e, r29	; 62
   16c34:	0f be       	out	0x3f, r0	; 63
   16c36:	cd bf       	out	0x3d, r28	; 61
   
   void *retaddr; 
   void (*getaddrfp)(void) = (void (*)(void))GET_LOGGER_BLOCK_ADDRESS;
   16c38:	80 ee       	ldi	r24, 0xE0	; 224
   16c3a:	9a ee       	ldi	r25, 0xEA	; 234
   16c3c:	9a 83       	std	Y+2, r25	; 0x02
   16c3e:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   16c40:	4f 93       	push	r20
   16c42:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   16c44:	e9 81       	ldd	r30, Y+1	; 0x01
   16c46:	fa 81       	ldd	r31, Y+2	; 0x02
   16c48:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   16c4a:	84 2f       	mov	r24, r20
   16c4c:	95 2f       	mov	r25, r21
   16c4e:	9c 83       	std	Y+4, r25	; 0x04
   16c50:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (retaddr)
				 :);
    asm volatile("pop r21" "\n\t"
   16c52:	5f 91       	pop	r21
   16c54:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return retaddr;
   16c56:	8b 81       	ldd	r24, Y+3	; 0x03
   16c58:	9c 81       	ldd	r25, Y+4	; 0x04
   16c5a:	24 96       	adiw	r28, 0x04	; 4
   16c5c:	0f b6       	in	r0, 0x3f	; 63
   16c5e:	f8 94       	cli
   16c60:	de bf       	out	0x3e, r29	; 62
   16c62:	0f be       	out	0x3f, r0	; 63
   16c64:	cd bf       	out	0x3d, r28	; 61
   16c66:	df 91       	pop	r29
   16c68:	cf 91       	pop	r28
   16c6a:	08 95       	ret

00016c6c <enableTracing>:
}



void enableTracing()
{    
   16c6c:	cf 93       	push	r28
   16c6e:	df 93       	push	r29
   16c70:	cd b7       	in	r28, 0x3d	; 61
   16c72:	de b7       	in	r29, 0x3e	; 62
   16c74:	22 97       	sbiw	r28, 0x02	; 2
   16c76:	0f b6       	in	r0, 0x3f	; 63
   16c78:	f8 94       	cli
   16c7a:	de bf       	out	0x3e, r29	; 62
   16c7c:	0f be       	out	0x3f, r0	; 63
   16c7e:	cd bf       	out	0x3d, r28	; 61
   void (*getaddrfp)(void) = (void (*)(void))ENABLE_TRACING_SYSCALL;
   16c80:	84 ee       	ldi	r24, 0xE4	; 228
   16c82:	9a ee       	ldi	r25, 0xEA	; 234
   16c84:	9a 83       	std	Y+2, r25	; 0x02
   16c86:	89 83       	std	Y+1, r24	; 0x01
   getaddrfp();
   16c88:	e9 81       	ldd	r30, Y+1	; 0x01
   16c8a:	fa 81       	ldd	r31, Y+2	; 0x02
   16c8c:	09 95       	icall
   16c8e:	22 96       	adiw	r28, 0x02	; 2
   16c90:	0f b6       	in	r0, 0x3f	; 63
   16c92:	f8 94       	cli
   16c94:	de bf       	out	0x3e, r29	; 62
   16c96:	0f be       	out	0x3f, r0	; 63
   16c98:	cd bf       	out	0x3d, r28	; 61
   16c9a:	df 91       	pop	r29
   16c9c:	cf 91       	pop	r28
   16c9e:	08 95       	ret

00016ca0 <disableTracing>:
   return;
}



void disableTracing()
{     
   16ca0:	cf 93       	push	r28
   16ca2:	df 93       	push	r29
   16ca4:	cd b7       	in	r28, 0x3d	; 61
   16ca6:	de b7       	in	r29, 0x3e	; 62
   16ca8:	22 97       	sbiw	r28, 0x02	; 2
   16caa:	0f b6       	in	r0, 0x3f	; 63
   16cac:	f8 94       	cli
   16cae:	de bf       	out	0x3e, r29	; 62
   16cb0:	0f be       	out	0x3f, r0	; 63
   16cb2:	cd bf       	out	0x3d, r28	; 61
   void (*getaddrfp)(void) = (void (*)(void))DISABLE_TRACING_SYSCALL;
   16cb4:	88 ee       	ldi	r24, 0xE8	; 232
   16cb6:	9a ee       	ldi	r25, 0xEA	; 234
   16cb8:	9a 83       	std	Y+2, r25	; 0x02
   16cba:	89 83       	std	Y+1, r24	; 0x01
   getaddrfp();
   16cbc:	e9 81       	ldd	r30, Y+1	; 0x01
   16cbe:	fa 81       	ldd	r31, Y+2	; 0x02
   16cc0:	09 95       	icall
   16cc2:	22 96       	adiw	r28, 0x02	; 2
   16cc4:	0f b6       	in	r0, 0x3f	; 63
   16cc6:	f8 94       	cli
   16cc8:	de bf       	out	0x3e, r29	; 62
   16cca:	0f be       	out	0x3f, r0	; 63
   16ccc:	cd bf       	out	0x3d, r28	; 61
   16cce:	df 91       	pop	r29
   16cd0:	cf 91       	pop	r28
   16cd2:	08 95       	ret

00016cd4 <addUserTracePoint>:
   return;
}





void addUserTracePoint(uint16_t pagenum, uint16_t pageoffset)
{
   16cd4:	cf 93       	push	r28
   16cd6:	df 93       	push	r29
   16cd8:	cd b7       	in	r28, 0x3d	; 61
   16cda:	de b7       	in	r29, 0x3e	; 62
   16cdc:	26 97       	sbiw	r28, 0x06	; 6
   16cde:	0f b6       	in	r0, 0x3f	; 63
   16ce0:	f8 94       	cli
   16ce2:	de bf       	out	0x3e, r29	; 62
   16ce4:	0f be       	out	0x3f, r0	; 63
   16ce6:	cd bf       	out	0x3d, r28	; 61
   16ce8:	9c 83       	std	Y+4, r25	; 0x04
   16cea:	8b 83       	std	Y+3, r24	; 0x03
   16cec:	7e 83       	std	Y+6, r23	; 0x06
   16cee:	6d 83       	std	Y+5, r22	; 0x05
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_ADD_TRACE_POINT; 
   16cf0:	88 ef       	ldi	r24, 0xF8	; 248
   16cf2:	9a ee       	ldi	r25, 0xEA	; 234
   16cf4:	9a 83       	std	Y+2, r25	; 0x02
   16cf6:	89 83       	std	Y+1, r24	; 0x01
   globalpagenum = pagenum;
   16cf8:	8b 81       	ldd	r24, Y+3	; 0x03
   16cfa:	9c 81       	ldd	r25, Y+4	; 0x04
   16cfc:	90 93 66 0a 	sts	0x0A66, r25
   16d00:	80 93 65 0a 	sts	0x0A65, r24
   globalpageoffset = pageoffset; 
   16d04:	8d 81       	ldd	r24, Y+5	; 0x05
   16d06:	9e 81       	ldd	r25, Y+6	; 0x06
   16d08:	90 93 64 0a 	sts	0x0A64, r25
   16d0c:	80 93 63 0a 	sts	0x0A63, r24
   
   asm volatile("push r20" "\n\t"
   16d10:	4f 93       	push	r20
   16d12:	5f 93       	push	r21
   16d14:	6f 93       	push	r22
   16d16:	7f 93       	push	r23
                "push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   16d18:	80 91 65 0a 	lds	r24, 0x0A65
   16d1c:	90 91 66 0a 	lds	r25, 0x0A66
   16d20:	48 2f       	mov	r20, r24
   16d22:	59 2f       	mov	r21, r25
	             	" mov r21, %B0" "\n\t"
				 :
				 :"r" (globalpagenum)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   16d24:	80 91 63 0a 	lds	r24, 0x0A63
   16d28:	90 91 64 0a 	lds	r25, 0x0A64
   16d2c:	68 2f       	mov	r22, r24
   16d2e:	79 2f       	mov	r23, r25
	             	" mov r23, %B0" "\n\t"
				 :
				 :"r" (globalpageoffset)
                );

  fp(); 
   16d30:	e9 81       	ldd	r30, Y+1	; 0x01
   16d32:	fa 81       	ldd	r31, Y+2	; 0x02
   16d34:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   16d36:	7f 91       	pop	r23
   16d38:	6f 91       	pop	r22
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   16d3a:	5f 91       	pop	r21
   16d3c:	4f 91       	pop	r20
   16d3e:	26 96       	adiw	r28, 0x06	; 6
   16d40:	0f b6       	in	r0, 0x3f	; 63
   16d42:	f8 94       	cli
   16d44:	de bf       	out	0x3e, r29	; 62
   16d46:	0f be       	out	0x3f, r0	; 63
   16d48:	cd bf       	out	0x3d, r28	; 61
   16d4a:	df 91       	pop	r29
   16d4c:	cf 91       	pop	r28
   16d4e:	08 95       	ret

00016d50 <addUserTracePoint_longinstruction>:
	           "pop r20" "\n\t"
	              ::);
  return; 


}



void addUserTracePoint_longinstruction(uint16_t pagenum, uint16_t pageoffset)
{
   16d50:	cf 93       	push	r28
   16d52:	df 93       	push	r29
   16d54:	cd b7       	in	r28, 0x3d	; 61
   16d56:	de b7       	in	r29, 0x3e	; 62
   16d58:	26 97       	sbiw	r28, 0x06	; 6
   16d5a:	0f b6       	in	r0, 0x3f	; 63
   16d5c:	f8 94       	cli
   16d5e:	de bf       	out	0x3e, r29	; 62
   16d60:	0f be       	out	0x3f, r0	; 63
   16d62:	cd bf       	out	0x3d, r28	; 61
   16d64:	9c 83       	std	Y+4, r25	; 0x04
   16d66:	8b 83       	std	Y+3, r24	; 0x03
   16d68:	7e 83       	std	Y+6, r23	; 0x06
   16d6a:	6d 83       	std	Y+5, r22	; 0x05

	 
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_ADD_TRACE_POINT_LONG; 
   16d6c:	8c ef       	ldi	r24, 0xFC	; 252
   16d6e:	9a ee       	ldi	r25, 0xEA	; 234
   16d70:	9a 83       	std	Y+2, r25	; 0x02
   16d72:	89 83       	std	Y+1, r24	; 0x01
   	 globalpagenum = pagenum;
   16d74:	8b 81       	ldd	r24, Y+3	; 0x03
   16d76:	9c 81       	ldd	r25, Y+4	; 0x04
   16d78:	90 93 66 0a 	sts	0x0A66, r25
   16d7c:	80 93 65 0a 	sts	0x0A65, r24
	 globalpageoffset = pageoffset; 
   16d80:	8d 81       	ldd	r24, Y+5	; 0x05
   16d82:	9e 81       	ldd	r25, Y+6	; 0x06
   16d84:	90 93 64 0a 	sts	0x0A64, r25
   16d88:	80 93 63 0a 	sts	0x0A63, r24
   asm volatile("push r20" "\n\t"
   16d8c:	4f 93       	push	r20
   16d8e:	5f 93       	push	r21
   16d90:	6f 93       	push	r22
   16d92:	7f 93       	push	r23
                "push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   16d94:	80 91 65 0a 	lds	r24, 0x0A65
   16d98:	90 91 66 0a 	lds	r25, 0x0A66
   16d9c:	48 2f       	mov	r20, r24
   16d9e:	59 2f       	mov	r21, r25
	             	" mov r21, %B0" "\n\t"
				 :
				 :"r" (globalpagenum)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   16da0:	80 91 63 0a 	lds	r24, 0x0A63
   16da4:	90 91 64 0a 	lds	r25, 0x0A64
   16da8:	68 2f       	mov	r22, r24
   16daa:	79 2f       	mov	r23, r25
	             	" mov r23, %B0" "\n\t"
				 :
				 :"r" (globalpageoffset)
                );

  fp(); 
   16dac:	e9 81       	ldd	r30, Y+1	; 0x01
   16dae:	fa 81       	ldd	r31, Y+2	; 0x02
   16db0:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   16db2:	7f 91       	pop	r23
   16db4:	6f 91       	pop	r22
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   16db6:	5f 91       	pop	r21
   16db8:	4f 91       	pop	r20
   16dba:	26 96       	adiw	r28, 0x06	; 6
   16dbc:	0f b6       	in	r0, 0x3f	; 63
   16dbe:	f8 94       	cli
   16dc0:	de bf       	out	0x3e, r29	; 62
   16dc2:	0f be       	out	0x3f, r0	; 63
   16dc4:	cd bf       	out	0x3d, r28	; 61
   16dc6:	df 91       	pop	r29
   16dc8:	cf 91       	pop	r28
   16dca:	08 95       	ret

00016dcc <removeUserTracePoint>:
	           "pop r20" "\n\t"
	              ::);
  return; 


}



void removeUserTracePoint(uint16_t pagenum, uint16_t pageoffset, uint8_t *buffer)
{
   16dcc:	cf 93       	push	r28
   16dce:	df 93       	push	r29
   16dd0:	cd b7       	in	r28, 0x3d	; 61
   16dd2:	de b7       	in	r29, 0x3e	; 62
   16dd4:	28 97       	sbiw	r28, 0x08	; 8
   16dd6:	0f b6       	in	r0, 0x3f	; 63
   16dd8:	f8 94       	cli
   16dda:	de bf       	out	0x3e, r29	; 62
   16ddc:	0f be       	out	0x3f, r0	; 63
   16dde:	cd bf       	out	0x3d, r28	; 61
   16de0:	9c 83       	std	Y+4, r25	; 0x04
   16de2:	8b 83       	std	Y+3, r24	; 0x03
   16de4:	7e 83       	std	Y+6, r23	; 0x06
   16de6:	6d 83       	std	Y+5, r22	; 0x05
   16de8:	58 87       	std	Y+8, r21	; 0x08
   16dea:	4f 83       	std	Y+7, r20	; 0x07
	
	  
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_REMOVE_TRACE_POINT; 
   16dec:	8c e0       	ldi	r24, 0x0C	; 12
   16dee:	9b ee       	ldi	r25, 0xEB	; 235
   16df0:	9a 83       	std	Y+2, r25	; 0x02
   16df2:	89 83       	std	Y+1, r24	; 0x01
   globalpagenum = pagenum;
   16df4:	8b 81       	ldd	r24, Y+3	; 0x03
   16df6:	9c 81       	ldd	r25, Y+4	; 0x04
   16df8:	90 93 66 0a 	sts	0x0A66, r25
   16dfc:	80 93 65 0a 	sts	0x0A65, r24
   globalpageoffset = pageoffset; 
   16e00:	8d 81       	ldd	r24, Y+5	; 0x05
   16e02:	9e 81       	ldd	r25, Y+6	; 0x06
   16e04:	90 93 64 0a 	sts	0x0A64, r25
   16e08:	80 93 63 0a 	sts	0x0A63, r24
   globalbuffer = buffer; 
   16e0c:	8f 81       	ldd	r24, Y+7	; 0x07
   16e0e:	98 85       	ldd	r25, Y+8	; 0x08
   16e10:	90 93 62 0a 	sts	0x0A62, r25
   16e14:	80 93 61 0a 	sts	0x0A61, r24
   
   asm volatile(
   16e18:	2f 93       	push	r18
   16e1a:	3f 93       	push	r19
   16e1c:	4f 93       	push	r20
   16e1e:	5f 93       	push	r21
   16e20:	6f 93       	push	r22
   16e22:	7f 93       	push	r23
   							"push r18" "\n\t"
   							"push r19" "\n\t"
   							"push r20" "\n\t"
                "push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"
                ::);
                	
                	
   
   asm volatile(" mov r20, %A0" "\n\t"
   16e24:	80 91 65 0a 	lds	r24, 0x0A65
   16e28:	90 91 66 0a 	lds	r25, 0x0A66
   16e2c:	48 2f       	mov	r20, r24
   16e2e:	59 2f       	mov	r21, r25
	             	" mov r21, %B0" "\n\t"
				 :
				 :"r" (globalpagenum)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   16e30:	80 91 63 0a 	lds	r24, 0x0A63
   16e34:	90 91 64 0a 	lds	r25, 0x0A64
   16e38:	68 2f       	mov	r22, r24
   16e3a:	79 2f       	mov	r23, r25
	             	" mov r23, %B0" "\n\t"
				 :
				 :"r" (globalpageoffset)
                );
                
   asm volatile(" mov r18, %A0" "\n\t"
   16e3c:	80 91 61 0a 	lds	r24, 0x0A61
   16e40:	90 91 62 0a 	lds	r25, 0x0A62
   16e44:	28 2f       	mov	r18, r24
   16e46:	39 2f       	mov	r19, r25
	             	" mov r19, %B0" "\n\t"
				 :
				 :"r" (globalbuffer)
                );

  fp(); 
   16e48:	e9 81       	ldd	r30, Y+1	; 0x01
   16e4a:	fa 81       	ldd	r31, Y+2	; 0x02
   16e4c:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   16e4e:	7f 91       	pop	r23
   16e50:	6f 91       	pop	r22
	             "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   16e52:	5f 91       	pop	r21
   16e54:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
	              	
  asm volatile("pop r19" "\n\t"
   16e56:	3f 91       	pop	r19
   16e58:	2f 91       	pop	r18
   16e5a:	28 96       	adiw	r28, 0x08	; 8
   16e5c:	0f b6       	in	r0, 0x3f	; 63
   16e5e:	f8 94       	cli
   16e60:	de bf       	out	0x3e, r29	; 62
   16e62:	0f be       	out	0x3f, r0	; 63
   16e64:	cd bf       	out	0x3d, r28	; 61
   16e66:	df 91       	pop	r29
   16e68:	cf 91       	pop	r28
   16e6a:	08 95       	ret

00016e6c <removeUserTracePoint_longinstruction>:
	             "pop r18" "\n\t"
	              ::);
  return; 


}



void removeUserTracePoint_longinstruction(uint16_t pagenum, uint16_t pageoffset, uint8_t *buffer)
{
   16e6c:	cf 93       	push	r28
   16e6e:	df 93       	push	r29
   16e70:	cd b7       	in	r28, 0x3d	; 61
   16e72:	de b7       	in	r29, 0x3e	; 62
   16e74:	28 97       	sbiw	r28, 0x08	; 8
   16e76:	0f b6       	in	r0, 0x3f	; 63
   16e78:	f8 94       	cli
   16e7a:	de bf       	out	0x3e, r29	; 62
   16e7c:	0f be       	out	0x3f, r0	; 63
   16e7e:	cd bf       	out	0x3d, r28	; 61
   16e80:	9c 83       	std	Y+4, r25	; 0x04
   16e82:	8b 83       	std	Y+3, r24	; 0x03
   16e84:	7e 83       	std	Y+6, r23	; 0x06
   16e86:	6d 83       	std	Y+5, r22	; 0x05
   16e88:	58 87       	std	Y+8, r21	; 0x08
   16e8a:	4f 83       	std	Y+7, r20	; 0x07
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_REMOVE_TRACE_POINT_LONG; 
   16e8c:	80 e1       	ldi	r24, 0x10	; 16
   16e8e:	9b ee       	ldi	r25, 0xEB	; 235
   16e90:	9a 83       	std	Y+2, r25	; 0x02
   16e92:	89 83       	std	Y+1, r24	; 0x01
   
   globalpagenum = pagenum;
   16e94:	8b 81       	ldd	r24, Y+3	; 0x03
   16e96:	9c 81       	ldd	r25, Y+4	; 0x04
   16e98:	90 93 66 0a 	sts	0x0A66, r25
   16e9c:	80 93 65 0a 	sts	0x0A65, r24
   globalpageoffset = pageoffset; 
   16ea0:	8d 81       	ldd	r24, Y+5	; 0x05
   16ea2:	9e 81       	ldd	r25, Y+6	; 0x06
   16ea4:	90 93 64 0a 	sts	0x0A64, r25
   16ea8:	80 93 63 0a 	sts	0x0A63, r24
   globalbuffer = buffer; 
   16eac:	8f 81       	ldd	r24, Y+7	; 0x07
   16eae:	98 85       	ldd	r25, Y+8	; 0x08
   16eb0:	90 93 62 0a 	sts	0x0A62, r25
   16eb4:	80 93 61 0a 	sts	0x0A61, r24
   asm volatile("push r18" "\n\t"
   16eb8:	2f 93       	push	r18
   16eba:	3f 93       	push	r19
   16ebc:	4f 93       	push	r20
   16ebe:	5f 93       	push	r21
   16ec0:	6f 93       	push	r22
   16ec2:	7f 93       	push	r23
   							"push r19" "\n\t"
   							"push r20" "\n\t"
                "push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   16ec4:	80 91 65 0a 	lds	r24, 0x0A65
   16ec8:	90 91 66 0a 	lds	r25, 0x0A66
   16ecc:	48 2f       	mov	r20, r24
   16ece:	59 2f       	mov	r21, r25
	             	" mov r21, %B0" "\n\t"
				 :
				 :"r" (globalpagenum)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   16ed0:	80 91 63 0a 	lds	r24, 0x0A63
   16ed4:	90 91 64 0a 	lds	r25, 0x0A64
   16ed8:	68 2f       	mov	r22, r24
   16eda:	79 2f       	mov	r23, r25
	             	" mov r23, %B0" "\n\t"
				 :
				 :"r" (globalpageoffset)
                );
                
   asm volatile(" mov r18, %A0" "\n\t"
   16edc:	80 91 61 0a 	lds	r24, 0x0A61
   16ee0:	90 91 62 0a 	lds	r25, 0x0A62
   16ee4:	28 2f       	mov	r18, r24
   16ee6:	39 2f       	mov	r19, r25
	             	" mov r19, %B0" "\n\t"
				 :
				 :"r" (globalbuffer)
                );

  fp(); 
   16ee8:	e9 81       	ldd	r30, Y+1	; 0x01
   16eea:	fa 81       	ldd	r31, Y+2	; 0x02
   16eec:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   16eee:	7f 91       	pop	r23
   16ef0:	6f 91       	pop	r22
	             "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   16ef2:	5f 91       	pop	r21
   16ef4:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
	
	asm volatile("pop r19" "\n\t"
   16ef6:	3f 91       	pop	r19
   16ef8:	2f 91       	pop	r18
   16efa:	28 96       	adiw	r28, 0x08	; 8
   16efc:	0f b6       	in	r0, 0x3f	; 63
   16efe:	f8 94       	cli
   16f00:	de bf       	out	0x3e, r29	; 62
   16f02:	0f be       	out	0x3f, r0	; 63
   16f04:	cd bf       	out	0x3d, r28	; 61
   16f06:	df 91       	pop	r29
   16f08:	cf 91       	pop	r28
   16f0a:	08 95       	ret

00016f0c <getFilePathAddress>:



char *getFilePathAddress()
{
   16f0c:	cf 93       	push	r28
   16f0e:	df 93       	push	r29
   16f10:	cd b7       	in	r28, 0x3d	; 61
   16f12:	de b7       	in	r29, 0x3e	; 62
   16f14:	24 97       	sbiw	r28, 0x04	; 4
   16f16:	0f b6       	in	r0, 0x3f	; 63
   16f18:	f8 94       	cli
   16f1a:	de bf       	out	0x3e, r29	; 62
   16f1c:	0f be       	out	0x3f, r0	; 63
   16f1e:	cd bf       	out	0x3d, r28	; 61
   char *pathaddr;
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_PATH_ADDRESS;
   16f20:	80 e2       	ldi	r24, 0x20	; 32
   16f22:	9a ee       	ldi	r25, 0xEA	; 234
   16f24:	9a 83       	std	Y+2, r25	; 0x02
   16f26:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   16f28:	4f 93       	push	r20
   16f2a:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   16f2c:	e9 81       	ldd	r30, Y+1	; 0x01
   16f2e:	fa 81       	ldd	r31, Y+2	; 0x02
   16f30:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   16f32:	84 2f       	mov	r24, r20
   16f34:	95 2f       	mov	r25, r21
   16f36:	9c 83       	std	Y+4, r25	; 0x04
   16f38:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (pathaddr)
				 :);
    asm volatile("pop r21" "\n\t"
   16f3a:	5f 91       	pop	r21
   16f3c:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return pathaddr;
   16f3e:	8b 81       	ldd	r24, Y+3	; 0x03
   16f40:	9c 81       	ldd	r25, Y+4	; 0x04
   16f42:	24 96       	adiw	r28, 0x04	; 4
   16f44:	0f b6       	in	r0, 0x3f	; 63
   16f46:	f8 94       	cli
   16f48:	de bf       	out	0x3e, r29	; 62
   16f4a:	0f be       	out	0x3f, r0	; 63
   16f4c:	cd bf       	out	0x3d, r28	; 61
   16f4e:	df 91       	pop	r29
   16f50:	cf 91       	pop	r28
   16f52:	08 95       	ret

00016f54 <getFileModeAddress>:
}



char *getFileModeAddress()

{
   16f54:	cf 93       	push	r28
   16f56:	df 93       	push	r29
   16f58:	cd b7       	in	r28, 0x3d	; 61
   16f5a:	de b7       	in	r29, 0x3e	; 62
   16f5c:	24 97       	sbiw	r28, 0x04	; 4
   16f5e:	0f b6       	in	r0, 0x3f	; 63
   16f60:	f8 94       	cli
   16f62:	de bf       	out	0x3e, r29	; 62
   16f64:	0f be       	out	0x3f, r0	; 63
   16f66:	cd bf       	out	0x3d, r28	; 61
   char *modeaddr;
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_MODE_ADDRESS;
   16f68:	84 e2       	ldi	r24, 0x24	; 36
   16f6a:	9a ee       	ldi	r25, 0xEA	; 234
   16f6c:	9a 83       	std	Y+2, r25	; 0x02
   16f6e:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   16f70:	4f 93       	push	r20
   16f72:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   16f74:	e9 81       	ldd	r30, Y+1	; 0x01
   16f76:	fa 81       	ldd	r31, Y+2	; 0x02
   16f78:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   16f7a:	84 2f       	mov	r24, r20
   16f7c:	95 2f       	mov	r25, r21
   16f7e:	9c 83       	std	Y+4, r25	; 0x04
   16f80:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (modeaddr)
				 :);
    asm volatile("pop r21" "\n\t"
   16f82:	5f 91       	pop	r21
   16f84:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return modeaddr;
   16f86:	8b 81       	ldd	r24, Y+3	; 0x03
   16f88:	9c 81       	ldd	r25, Y+4	; 0x04
   16f8a:	24 96       	adiw	r28, 0x04	; 4
   16f8c:	0f b6       	in	r0, 0x3f	; 63
   16f8e:	f8 94       	cli
   16f90:	de bf       	out	0x3e, r29	; 62
   16f92:	0f be       	out	0x3f, r0	; 63
   16f94:	cd bf       	out	0x3d, r28	; 61
   16f96:	df 91       	pop	r29
   16f98:	cf 91       	pop	r28
   16f9a:	08 95       	ret

00016f9c <openFileSysCall>:
}




void openFileSysCall()
{
   16f9c:	cf 93       	push	r28
   16f9e:	df 93       	push	r29
   16fa0:	cd b7       	in	r28, 0x3d	; 61
   16fa2:	de b7       	in	r29, 0x3e	; 62
   16fa4:	22 97       	sbiw	r28, 0x02	; 2
   16fa6:	0f b6       	in	r0, 0x3f	; 63
   16fa8:	f8 94       	cli
   16faa:	de bf       	out	0x3e, r29	; 62
   16fac:	0f be       	out	0x3f, r0	; 63
   16fae:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))OPEN_FILE_SYSCALL;
   16fb0:	8c e2       	ldi	r24, 0x2C	; 44
   16fb2:	9a ee       	ldi	r25, 0xEA	; 234
   16fb4:	9a 83       	std	Y+2, r25	; 0x02
   16fb6:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   16fb8:	e9 81       	ldd	r30, Y+1	; 0x01
   16fba:	fa 81       	ldd	r31, Y+2	; 0x02
   16fbc:	09 95       	icall
   16fbe:	22 96       	adiw	r28, 0x02	; 2
   16fc0:	0f b6       	in	r0, 0x3f	; 63
   16fc2:	f8 94       	cli
   16fc4:	de bf       	out	0x3e, r29	; 62
   16fc6:	0f be       	out	0x3f, r0	; 63
   16fc8:	cd bf       	out	0x3d, r28	; 61
   16fca:	df 91       	pop	r29
   16fcc:	cf 91       	pop	r28
   16fce:	08 95       	ret

00016fd0 <closeFileSysCall>:
}



void closeFileSysCall()
{
   16fd0:	cf 93       	push	r28
   16fd2:	df 93       	push	r29
   16fd4:	cd b7       	in	r28, 0x3d	; 61
   16fd6:	de b7       	in	r29, 0x3e	; 62
   16fd8:	22 97       	sbiw	r28, 0x02	; 2
   16fda:	0f b6       	in	r0, 0x3f	; 63
   16fdc:	f8 94       	cli
   16fde:	de bf       	out	0x3e, r29	; 62
   16fe0:	0f be       	out	0x3f, r0	; 63
   16fe2:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))CLOSE_FILE_SYSCALL;
   16fe4:	80 e3       	ldi	r24, 0x30	; 48
   16fe6:	9a ee       	ldi	r25, 0xEA	; 234
   16fe8:	9a 83       	std	Y+2, r25	; 0x02
   16fea:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   16fec:	e9 81       	ldd	r30, Y+1	; 0x01
   16fee:	fa 81       	ldd	r31, Y+2	; 0x02
   16ff0:	09 95       	icall
   16ff2:	22 96       	adiw	r28, 0x02	; 2
   16ff4:	0f b6       	in	r0, 0x3f	; 63
   16ff6:	f8 94       	cli
   16ff8:	de bf       	out	0x3e, r29	; 62
   16ffa:	0f be       	out	0x3f, r0	; 63
   16ffc:	cd bf       	out	0x3d, r28	; 61
   16ffe:	df 91       	pop	r29
   17000:	cf 91       	pop	r28
   17002:	08 95       	ret

00017004 <readFileSysCall>:
}


void readFileSysCall()
{
   17004:	cf 93       	push	r28
   17006:	df 93       	push	r29
   17008:	cd b7       	in	r28, 0x3d	; 61
   1700a:	de b7       	in	r29, 0x3e	; 62
   1700c:	22 97       	sbiw	r28, 0x02	; 2
   1700e:	0f b6       	in	r0, 0x3f	; 63
   17010:	f8 94       	cli
   17012:	de bf       	out	0x3e, r29	; 62
   17014:	0f be       	out	0x3f, r0	; 63
   17016:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))READ_FILE_SYSCALL;
   17018:	84 e3       	ldi	r24, 0x34	; 52
   1701a:	9a ee       	ldi	r25, 0xEA	; 234
   1701c:	9a 83       	std	Y+2, r25	; 0x02
   1701e:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   17020:	e9 81       	ldd	r30, Y+1	; 0x01
   17022:	fa 81       	ldd	r31, Y+2	; 0x02
   17024:	09 95       	icall
   17026:	22 96       	adiw	r28, 0x02	; 2
   17028:	0f b6       	in	r0, 0x3f	; 63
   1702a:	f8 94       	cli
   1702c:	de bf       	out	0x3e, r29	; 62
   1702e:	0f be       	out	0x3f, r0	; 63
   17030:	cd bf       	out	0x3d, r28	; 61
   17032:	df 91       	pop	r29
   17034:	cf 91       	pop	r28
   17036:	08 95       	ret

00017038 <writeFileSysCall>:
}



void writeFileSysCall()
{
   17038:	cf 93       	push	r28
   1703a:	df 93       	push	r29
   1703c:	cd b7       	in	r28, 0x3d	; 61
   1703e:	de b7       	in	r29, 0x3e	; 62
   17040:	22 97       	sbiw	r28, 0x02	; 2
   17042:	0f b6       	in	r0, 0x3f	; 63
   17044:	f8 94       	cli
   17046:	de bf       	out	0x3e, r29	; 62
   17048:	0f be       	out	0x3f, r0	; 63
   1704a:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))WRITE_FILE_SYSCALL;
   1704c:	88 e3       	ldi	r24, 0x38	; 56
   1704e:	9a ee       	ldi	r25, 0xEA	; 234
   17050:	9a 83       	std	Y+2, r25	; 0x02
   17052:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   17054:	e9 81       	ldd	r30, Y+1	; 0x01
   17056:	fa 81       	ldd	r31, Y+2	; 0x02
   17058:	09 95       	icall
   1705a:	22 96       	adiw	r28, 0x02	; 2
   1705c:	0f b6       	in	r0, 0x3f	; 63
   1705e:	f8 94       	cli
   17060:	de bf       	out	0x3e, r29	; 62
   17062:	0f be       	out	0x3f, r0	; 63
   17064:	cd bf       	out	0x3d, r28	; 61
   17066:	df 91       	pop	r29
   17068:	cf 91       	pop	r28
   1706a:	08 95       	ret

0001706c <seekFileSysCall>:
}



void seekFileSysCall()
{
   1706c:	cf 93       	push	r28
   1706e:	df 93       	push	r29
   17070:	cd b7       	in	r28, 0x3d	; 61
   17072:	de b7       	in	r29, 0x3e	; 62
   17074:	22 97       	sbiw	r28, 0x02	; 2
   17076:	0f b6       	in	r0, 0x3f	; 63
   17078:	f8 94       	cli
   1707a:	de bf       	out	0x3e, r29	; 62
   1707c:	0f be       	out	0x3f, r0	; 63
   1707e:	cd bf       	out	0x3d, r28	; 61
 void (*filefp)() = (void (*)(void))SEEK_FILE_SYSCALL;
   17080:	8c e3       	ldi	r24, 0x3C	; 60
   17082:	9a ee       	ldi	r25, 0xEA	; 234
   17084:	9a 83       	std	Y+2, r25	; 0x02
   17086:	89 83       	std	Y+1, r24	; 0x01
 filefp();
   17088:	e9 81       	ldd	r30, Y+1	; 0x01
   1708a:	fa 81       	ldd	r31, Y+2	; 0x02
   1708c:	09 95       	icall
   1708e:	22 96       	adiw	r28, 0x02	; 2
   17090:	0f b6       	in	r0, 0x3f	; 63
   17092:	f8 94       	cli
   17094:	de bf       	out	0x3e, r29	; 62
   17096:	0f be       	out	0x3f, r0	; 63
   17098:	cd bf       	out	0x3d, r28	; 61
   1709a:	df 91       	pop	r29
   1709c:	cf 91       	pop	r28
   1709e:	08 95       	ret

000170a0 <mfopen>:
}




MYFILE *mfopen(char *pathname, char *mode)
{
   170a0:	cf 93       	push	r28
   170a2:	df 93       	push	r29
   170a4:	cd b7       	in	r28, 0x3d	; 61
   170a6:	de b7       	in	r29, 0x3e	; 62
   170a8:	2d 97       	sbiw	r28, 0x0d	; 13
   170aa:	0f b6       	in	r0, 0x3f	; 63
   170ac:	f8 94       	cli
   170ae:	de bf       	out	0x3e, r29	; 62
   170b0:	0f be       	out	0x3f, r0	; 63
   170b2:	cd bf       	out	0x3d, r28	; 61
   170b4:	9b 87       	std	Y+11, r25	; 0x0b
   170b6:	8a 87       	std	Y+10, r24	; 0x0a
   170b8:	7d 87       	std	Y+13, r23	; 0x0d
   170ba:	6c 87       	std	Y+12, r22	; 0x0c
   char *commonpathnameaddr;

   char *commonmodeaddr;

   uint8_t currentthreadindex;

   thread** current_thread;

   mutex *mfile;

   current_thread = getCurrentThread();
   170bc:	0e 94 af c2 	call	0x1855e
   170c0:	9c 83       	std	Y+4, r25	; 0x04
   170c2:	8b 83       	std	Y+3, r24	; 0x03

   currentthreadindex = getCurrentThreadIndex();
   170c4:	0e 94 f7 c2 	call	0x185ee
   170c8:	8d 83       	std	Y+5, r24	; 0x05

   commonpathnameaddr =  getFilePathAddress();
   170ca:	0e 94 86 b7 	call	0x16f0c
   170ce:	99 87       	std	Y+9, r25	; 0x09
   170d0:	88 87       	std	Y+8, r24	; 0x08

   commonmodeaddr = getFileModeAddress();
   170d2:	0e 94 aa b7 	call	0x16f54
   170d6:	9f 83       	std	Y+7, r25	; 0x07
   170d8:	8e 83       	std	Y+6, r24	; 0x06

   mfile = getFileMutexAddress();
   170da:	0e 94 fd bb 	call	0x177fa
   170de:	9a 83       	std	Y+2, r25	; 0x02
   170e0:	89 83       	std	Y+1, r24	; 0x01


   Mutex_lock(mfile);
   170e2:	89 81       	ldd	r24, Y+1	; 0x01
   170e4:	9a 81       	ldd	r25, Y+2	; 0x02
   170e6:	0e 94 0c bb 	call	0x17618

   mystrcpy(commonpathnameaddr, pathname);
   170ea:	8a 85       	ldd	r24, Y+10	; 0x0a
   170ec:	9b 85       	ldd	r25, Y+11	; 0x0b
   170ee:	28 85       	ldd	r18, Y+8	; 0x08
   170f0:	39 85       	ldd	r19, Y+9	; 0x09
   170f2:	bc 01       	movw	r22, r24
   170f4:	c9 01       	movw	r24, r18
   170f6:	0e 94 c8 c0 	call	0x18190
   mystrcpy(commonmodeaddr, mode);
   170fa:	8c 85       	ldd	r24, Y+12	; 0x0c
   170fc:	9d 85       	ldd	r25, Y+13	; 0x0d
   170fe:	2e 81       	ldd	r18, Y+6	; 0x06
   17100:	3f 81       	ldd	r19, Y+7	; 0x07
   17102:	bc 01       	movw	r22, r24
   17104:	c9 01       	movw	r24, r18
   17106:	0e 94 c8 c0 	call	0x18190

   openFileSysCall();
   1710a:	0e 94 ce b7 	call	0x16f9c

   Barrier_block(7, 1);
   1710e:	61 e0       	ldi	r22, 0x01	; 1
   17110:	87 e0       	ldi	r24, 0x07	; 7
   17112:	0e 94 7f bb 	call	0x176fe
   Mutex_unlock(mfile);
   17116:	89 81       	ldd	r24, Y+1	; 0x01
   17118:	9a 81       	ldd	r25, Y+2	; 0x02
   1711a:	0e 94 5b bb 	call	0x176b6

   return (MYFILE *)((*current_thread)->filedata.filestate.fileptr);
   1711e:	eb 81       	ldd	r30, Y+3	; 0x03
   17120:	fc 81       	ldd	r31, Y+4	; 0x04
   17122:	01 90       	ld	r0, Z+
   17124:	f0 81       	ld	r31, Z
   17126:	e0 2d       	mov	r30, r0
   17128:	87 8d       	ldd	r24, Z+31	; 0x1f
   1712a:	90 a1       	ldd	r25, Z+32	; 0x20
   1712c:	2d 96       	adiw	r28, 0x0d	; 13
   1712e:	0f b6       	in	r0, 0x3f	; 63
   17130:	f8 94       	cli
   17132:	de bf       	out	0x3e, r29	; 62
   17134:	0f be       	out	0x3f, r0	; 63
   17136:	cd bf       	out	0x3d, r28	; 61
   17138:	df 91       	pop	r29
   1713a:	cf 91       	pop	r28
   1713c:	08 95       	ret

0001713e <mfclose>:
}



void mfclose(MYFILE *fp)
{
   1713e:	cf 93       	push	r28
   17140:	df 93       	push	r29
   17142:	cd b7       	in	r28, 0x3d	; 61
   17144:	de b7       	in	r29, 0x3e	; 62
   17146:	27 97       	sbiw	r28, 0x07	; 7
   17148:	0f b6       	in	r0, 0x3f	; 63
   1714a:	f8 94       	cli
   1714c:	de bf       	out	0x3e, r29	; 62
   1714e:	0f be       	out	0x3f, r0	; 63
   17150:	cd bf       	out	0x3d, r28	; 61
   17152:	9f 83       	std	Y+7, r25	; 0x07
   17154:	8e 83       	std	Y+6, r24	; 0x06
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   17156:	0e 94 af c2 	call	0x1855e
   1715a:	9c 83       	std	Y+4, r25	; 0x04
   1715c:	8b 83       	std	Y+3, r24	; 0x03
   currentthreadindex = getCurrentThreadIndex();
   1715e:	0e 94 f7 c2 	call	0x185ee
   17162:	8d 83       	std	Y+5, r24	; 0x05
   mfile = getFileMutexAddress();
   17164:	0e 94 fd bb 	call	0x177fa
   17168:	9a 83       	std	Y+2, r25	; 0x02
   1716a:	89 83       	std	Y+1, r24	; 0x01

   Mutex_lock(mfile);
   1716c:	89 81       	ldd	r24, Y+1	; 0x01
   1716e:	9a 81       	ldd	r25, Y+2	; 0x02
   17170:	0e 94 0c bb 	call	0x17618

   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   17174:	eb 81       	ldd	r30, Y+3	; 0x03
   17176:	fc 81       	ldd	r31, Y+4	; 0x04
   17178:	01 90       	ld	r0, Z+
   1717a:	f0 81       	ld	r31, Z
   1717c:	e0 2d       	mov	r30, r0
   1717e:	8e 81       	ldd	r24, Y+6	; 0x06
   17180:	9f 81       	ldd	r25, Y+7	; 0x07
   17182:	90 a3       	std	Z+32, r25	; 0x20
   17184:	87 8f       	std	Z+31, r24	; 0x1f
   closeFileSysCall();
   17186:	0e 94 e8 b7 	call	0x16fd0

   Barrier_block(7, 2);
   1718a:	62 e0       	ldi	r22, 0x02	; 2
   1718c:	87 e0       	ldi	r24, 0x07	; 7
   1718e:	0e 94 7f bb 	call	0x176fe
   Mutex_unlock(mfile);
   17192:	89 81       	ldd	r24, Y+1	; 0x01
   17194:	9a 81       	ldd	r25, Y+2	; 0x02
   17196:	0e 94 5b bb 	call	0x176b6
   1719a:	27 96       	adiw	r28, 0x07	; 7
   1719c:	0f b6       	in	r0, 0x3f	; 63
   1719e:	f8 94       	cli
   171a0:	de bf       	out	0x3e, r29	; 62
   171a2:	0f be       	out	0x3f, r0	; 63
   171a4:	cd bf       	out	0x3d, r28	; 61
   171a6:	df 91       	pop	r29
   171a8:	cf 91       	pop	r28
   171aa:	08 95       	ret

000171ac <mfread>:

   return;

}

void mfread(MYFILE *fp, void *buffer, int nBytes)
{
   171ac:	cf 93       	push	r28
   171ae:	df 93       	push	r29
   171b0:	cd b7       	in	r28, 0x3d	; 61
   171b2:	de b7       	in	r29, 0x3e	; 62
   171b4:	2b 97       	sbiw	r28, 0x0b	; 11
   171b6:	0f b6       	in	r0, 0x3f	; 63
   171b8:	f8 94       	cli
   171ba:	de bf       	out	0x3e, r29	; 62
   171bc:	0f be       	out	0x3f, r0	; 63
   171be:	cd bf       	out	0x3d, r28	; 61
   171c0:	9f 83       	std	Y+7, r25	; 0x07
   171c2:	8e 83       	std	Y+6, r24	; 0x06
   171c4:	79 87       	std	Y+9, r23	; 0x09
   171c6:	68 87       	std	Y+8, r22	; 0x08
   171c8:	5b 87       	std	Y+11, r21	; 0x0b
   171ca:	4a 87       	std	Y+10, r20	; 0x0a
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   171cc:	0e 94 af c2 	call	0x1855e
   171d0:	9c 83       	std	Y+4, r25	; 0x04
   171d2:	8b 83       	std	Y+3, r24	; 0x03
   currentthreadindex = getCurrentThreadIndex();
   171d4:	0e 94 f7 c2 	call	0x185ee
   171d8:	8d 83       	std	Y+5, r24	; 0x05
   mfile = getFileMutexAddress();
   171da:	0e 94 fd bb 	call	0x177fa
   171de:	9a 83       	std	Y+2, r25	; 0x02
   171e0:	89 83       	std	Y+1, r24	; 0x01


   Mutex_lock(mfile);
   171e2:	89 81       	ldd	r24, Y+1	; 0x01
   171e4:	9a 81       	ldd	r25, Y+2	; 0x02
   171e6:	0e 94 0c bb 	call	0x17618
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   171ea:	eb 81       	ldd	r30, Y+3	; 0x03
   171ec:	fc 81       	ldd	r31, Y+4	; 0x04
   171ee:	01 90       	ld	r0, Z+
   171f0:	f0 81       	ld	r31, Z
   171f2:	e0 2d       	mov	r30, r0
   171f4:	8e 81       	ldd	r24, Y+6	; 0x06
   171f6:	9f 81       	ldd	r25, Y+7	; 0x07
   171f8:	90 a3       	std	Z+32, r25	; 0x20
   171fa:	87 8f       	std	Z+31, r24	; 0x1f
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   171fc:	eb 81       	ldd	r30, Y+3	; 0x03
   171fe:	fc 81       	ldd	r31, Y+4	; 0x04
   17200:	01 90       	ld	r0, Z+
   17202:	f0 81       	ld	r31, Z
   17204:	e0 2d       	mov	r30, r0
   17206:	88 85       	ldd	r24, Y+8	; 0x08
   17208:	99 85       	ldd	r25, Y+9	; 0x09
   1720a:	92 a3       	std	Z+34, r25	; 0x22
   1720c:	81 a3       	std	Z+33, r24	; 0x21
   (*current_thread)->filedata.filestate.bytes = nBytes;
   1720e:	eb 81       	ldd	r30, Y+3	; 0x03
   17210:	fc 81       	ldd	r31, Y+4	; 0x04
   17212:	01 90       	ld	r0, Z+
   17214:	f0 81       	ld	r31, Z
   17216:	e0 2d       	mov	r30, r0
   17218:	8a 85       	ldd	r24, Y+10	; 0x0a
   1721a:	9b 85       	ldd	r25, Y+11	; 0x0b
   1721c:	94 a3       	std	Z+36, r25	; 0x24
   1721e:	83 a3       	std	Z+35, r24	; 0x23

   readFileSysCall();
   17220:	0e 94 02 b8 	call	0x17004

   Barrier_block(7, 3);
   17224:	63 e0       	ldi	r22, 0x03	; 3
   17226:	87 e0       	ldi	r24, 0x07	; 7
   17228:	0e 94 7f bb 	call	0x176fe
   Mutex_unlock(mfile);
   1722c:	89 81       	ldd	r24, Y+1	; 0x01
   1722e:	9a 81       	ldd	r25, Y+2	; 0x02
   17230:	0e 94 5b bb 	call	0x176b6
   17234:	2b 96       	adiw	r28, 0x0b	; 11
   17236:	0f b6       	in	r0, 0x3f	; 63
   17238:	f8 94       	cli
   1723a:	de bf       	out	0x3e, r29	; 62
   1723c:	0f be       	out	0x3f, r0	; 63
   1723e:	cd bf       	out	0x3d, r28	; 61
   17240:	df 91       	pop	r29
   17242:	cf 91       	pop	r28
   17244:	08 95       	ret

00017246 <mfwrite>:

   return;

}



void mfwrite(MYFILE *fp, void *buffer, int nBytes)
{
   17246:	cf 93       	push	r28
   17248:	df 93       	push	r29
   1724a:	cd b7       	in	r28, 0x3d	; 61
   1724c:	de b7       	in	r29, 0x3e	; 62
   1724e:	2b 97       	sbiw	r28, 0x0b	; 11
   17250:	0f b6       	in	r0, 0x3f	; 63
   17252:	f8 94       	cli
   17254:	de bf       	out	0x3e, r29	; 62
   17256:	0f be       	out	0x3f, r0	; 63
   17258:	cd bf       	out	0x3d, r28	; 61
   1725a:	9f 83       	std	Y+7, r25	; 0x07
   1725c:	8e 83       	std	Y+6, r24	; 0x06
   1725e:	79 87       	std	Y+9, r23	; 0x09
   17260:	68 87       	std	Y+8, r22	; 0x08
   17262:	5b 87       	std	Y+11, r21	; 0x0b
   17264:	4a 87       	std	Y+10, r20	; 0x0a
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   17266:	0e 94 af c2 	call	0x1855e
   1726a:	9c 83       	std	Y+4, r25	; 0x04
   1726c:	8b 83       	std	Y+3, r24	; 0x03
   currentthreadindex = getCurrentThreadIndex();
   1726e:	0e 94 f7 c2 	call	0x185ee
   17272:	8d 83       	std	Y+5, r24	; 0x05
   mfile = getFileMutexAddress();
   17274:	0e 94 fd bb 	call	0x177fa
   17278:	9a 83       	std	Y+2, r25	; 0x02
   1727a:	89 83       	std	Y+1, r24	; 0x01


   Mutex_lock(mfile);
   1727c:	89 81       	ldd	r24, Y+1	; 0x01
   1727e:	9a 81       	ldd	r25, Y+2	; 0x02
   17280:	0e 94 0c bb 	call	0x17618
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   17284:	eb 81       	ldd	r30, Y+3	; 0x03
   17286:	fc 81       	ldd	r31, Y+4	; 0x04
   17288:	01 90       	ld	r0, Z+
   1728a:	f0 81       	ld	r31, Z
   1728c:	e0 2d       	mov	r30, r0
   1728e:	8e 81       	ldd	r24, Y+6	; 0x06
   17290:	9f 81       	ldd	r25, Y+7	; 0x07
   17292:	90 a3       	std	Z+32, r25	; 0x20
   17294:	87 8f       	std	Z+31, r24	; 0x1f
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   17296:	eb 81       	ldd	r30, Y+3	; 0x03
   17298:	fc 81       	ldd	r31, Y+4	; 0x04
   1729a:	01 90       	ld	r0, Z+
   1729c:	f0 81       	ld	r31, Z
   1729e:	e0 2d       	mov	r30, r0
   172a0:	88 85       	ldd	r24, Y+8	; 0x08
   172a2:	99 85       	ldd	r25, Y+9	; 0x09
   172a4:	92 a3       	std	Z+34, r25	; 0x22
   172a6:	81 a3       	std	Z+33, r24	; 0x21
   (*current_thread)->filedata.filestate.bytes = nBytes;
   172a8:	eb 81       	ldd	r30, Y+3	; 0x03
   172aa:	fc 81       	ldd	r31, Y+4	; 0x04
   172ac:	01 90       	ld	r0, Z+
   172ae:	f0 81       	ld	r31, Z
   172b0:	e0 2d       	mov	r30, r0
   172b2:	8a 85       	ldd	r24, Y+10	; 0x0a
   172b4:	9b 85       	ldd	r25, Y+11	; 0x0b
   172b6:	94 a3       	std	Z+36, r25	; 0x24
   172b8:	83 a3       	std	Z+35, r24	; 0x23

   writeFileSysCall();
   172ba:	0e 94 1c b8 	call	0x17038

   Barrier_block(7, 4);
   172be:	64 e0       	ldi	r22, 0x04	; 4
   172c0:	87 e0       	ldi	r24, 0x07	; 7
   172c2:	0e 94 7f bb 	call	0x176fe
   Mutex_unlock(mfile);
   172c6:	89 81       	ldd	r24, Y+1	; 0x01
   172c8:	9a 81       	ldd	r25, Y+2	; 0x02
   172ca:	0e 94 5b bb 	call	0x176b6
   172ce:	2b 96       	adiw	r28, 0x0b	; 11
   172d0:	0f b6       	in	r0, 0x3f	; 63
   172d2:	f8 94       	cli
   172d4:	de bf       	out	0x3e, r29	; 62
   172d6:	0f be       	out	0x3f, r0	; 63
   172d8:	cd bf       	out	0x3d, r28	; 61
   172da:	df 91       	pop	r29
   172dc:	cf 91       	pop	r28
   172de:	08 95       	ret

000172e0 <mfwrite_withoutlength>:

   return;
}


void mfwrite_withoutlength(MYFILE *fp, void *buffer)
{
   172e0:	cf 93       	push	r28
   172e2:	df 93       	push	r29
   172e4:	cd b7       	in	r28, 0x3d	; 61
   172e6:	de b7       	in	r29, 0x3e	; 62
   172e8:	25 97       	sbiw	r28, 0x05	; 5
   172ea:	0f b6       	in	r0, 0x3f	; 63
   172ec:	f8 94       	cli
   172ee:	de bf       	out	0x3e, r29	; 62
   172f0:	0f be       	out	0x3f, r0	; 63
   172f2:	cd bf       	out	0x3d, r28	; 61
   172f4:	9b 83       	std	Y+3, r25	; 0x03
   172f6:	8a 83       	std	Y+2, r24	; 0x02
   172f8:	7d 83       	std	Y+5, r23	; 0x05
   172fa:	6c 83       	std	Y+4, r22	; 0x04


   uint8_t length;

   length = (uint8_t)String_length((char*)buffer);
   172fc:	8c 81       	ldd	r24, Y+4	; 0x04
   172fe:	9d 81       	ldd	r25, Y+5	; 0x05
   17300:	0e 94 66 c0 	call	0x180cc
   17304:	89 83       	std	Y+1, r24	; 0x01

   mfwrite(fp, buffer, length);
   17306:	89 81       	ldd	r24, Y+1	; 0x01
   17308:	99 27       	eor	r25, r25
   1730a:	2c 81       	ldd	r18, Y+4	; 0x04
   1730c:	3d 81       	ldd	r19, Y+5	; 0x05
   1730e:	ea 81       	ldd	r30, Y+2	; 0x02
   17310:	fb 81       	ldd	r31, Y+3	; 0x03
   17312:	ac 01       	movw	r20, r24
   17314:	b9 01       	movw	r22, r18
   17316:	cf 01       	movw	r24, r30
   17318:	0e 94 23 b9 	call	0x17246
   1731c:	25 96       	adiw	r28, 0x05	; 5
   1731e:	0f b6       	in	r0, 0x3f	; 63
   17320:	f8 94       	cli
   17322:	de bf       	out	0x3e, r29	; 62
   17324:	0f be       	out	0x3f, r0	; 63
   17326:	cd bf       	out	0x3d, r28	; 61
   17328:	df 91       	pop	r29
   1732a:	cf 91       	pop	r28
   1732c:	08 95       	ret

0001732e <mfseek>:

   return;
}






void mfseek(MYFILE *fp, int offset, int position)
{
   1732e:	cf 93       	push	r28
   17330:	df 93       	push	r29
   17332:	cd b7       	in	r28, 0x3d	; 61
   17334:	de b7       	in	r29, 0x3e	; 62
   17336:	29 97       	sbiw	r28, 0x09	; 9
   17338:	0f b6       	in	r0, 0x3f	; 63
   1733a:	f8 94       	cli
   1733c:	de bf       	out	0x3e, r29	; 62
   1733e:	0f be       	out	0x3f, r0	; 63
   17340:	cd bf       	out	0x3d, r28	; 61
   17342:	9d 83       	std	Y+5, r25	; 0x05
   17344:	8c 83       	std	Y+4, r24	; 0x04
   17346:	7f 83       	std	Y+7, r23	; 0x07
   17348:	6e 83       	std	Y+6, r22	; 0x06
   1734a:	59 87       	std	Y+9, r21	; 0x09
   1734c:	48 87       	std	Y+8, r20	; 0x08
   uint8_t currentthreadindex;
   thread** current_thread;

   current_thread = getCurrentThread();
   1734e:	0e 94 af c2 	call	0x1855e
   17352:	9a 83       	std	Y+2, r25	; 0x02
   17354:	89 83       	std	Y+1, r24	; 0x01
   currentthreadindex = getCurrentThreadIndex();
   17356:	0e 94 f7 c2 	call	0x185ee
   1735a:	8b 83       	std	Y+3, r24	; 0x03

   (*current_thread)->filedata.fileseekstate.fileptr = (uint8_t*)fp;
   1735c:	e9 81       	ldd	r30, Y+1	; 0x01
   1735e:	fa 81       	ldd	r31, Y+2	; 0x02
   17360:	01 90       	ld	r0, Z+
   17362:	f0 81       	ld	r31, Z
   17364:	e0 2d       	mov	r30, r0
   17366:	8c 81       	ldd	r24, Y+4	; 0x04
   17368:	9d 81       	ldd	r25, Y+5	; 0x05
   1736a:	90 a3       	std	Z+32, r25	; 0x20
   1736c:	87 8f       	std	Z+31, r24	; 0x1f
   (*current_thread)->filedata.fileseekstate.offset = offset;
   1736e:	e9 81       	ldd	r30, Y+1	; 0x01
   17370:	fa 81       	ldd	r31, Y+2	; 0x02
   17372:	01 90       	ld	r0, Z+
   17374:	f0 81       	ld	r31, Z
   17376:	e0 2d       	mov	r30, r0
   17378:	8e 81       	ldd	r24, Y+6	; 0x06
   1737a:	9f 81       	ldd	r25, Y+7	; 0x07
   1737c:	92 a3       	std	Z+34, r25	; 0x22
   1737e:	81 a3       	std	Z+33, r24	; 0x21
   (*current_thread)->filedata.fileseekstate.position = position;
   17380:	e9 81       	ldd	r30, Y+1	; 0x01
   17382:	fa 81       	ldd	r31, Y+2	; 0x02
   17384:	01 90       	ld	r0, Z+
   17386:	f0 81       	ld	r31, Z
   17388:	e0 2d       	mov	r30, r0
   1738a:	88 85       	ldd	r24, Y+8	; 0x08
   1738c:	99 85       	ldd	r25, Y+9	; 0x09
   1738e:	94 a3       	std	Z+36, r25	; 0x24
   17390:	83 a3       	std	Z+35, r24	; 0x23

   seekFileSysCall();
   17392:	0e 94 36 b8 	call	0x1706c
   17396:	29 96       	adiw	r28, 0x09	; 9
   17398:	0f b6       	in	r0, 0x3f	; 63
   1739a:	f8 94       	cli
   1739c:	de bf       	out	0x3e, r29	; 62
   1739e:	0f be       	out	0x3f, r0	; 63
   173a0:	cd bf       	out	0x3d, r28	; 61
   173a2:	df 91       	pop	r29
   173a4:	cf 91       	pop	r28
   173a6:	08 95       	ret

000173a8 <greenToggle>:
#include "leds.h"
#include "liteoscommon.h"

void greenToggle()
{
   173a8:	cf 93       	push	r28
   173aa:	df 93       	push	r29
   173ac:	cd b7       	in	r28, 0x3d	; 61
   173ae:	de b7       	in	r29, 0x3e	; 62
   173b0:	22 97       	sbiw	r28, 0x02	; 2
   173b2:	0f b6       	in	r0, 0x3f	; 63
   173b4:	f8 94       	cli
   173b6:	de bf       	out	0x3e, r29	; 62
   173b8:	0f be       	out	0x3f, r0	; 63
   173ba:	cd bf       	out	0x3d, r28	; 61
 void (*greenfp)() = (void (*)(void))GREEN_LED_TOGGLE_FUNCTION; 
   173bc:	84 e0       	ldi	r24, 0x04	; 4
   173be:	9a ee       	ldi	r25, 0xEA	; 234
   173c0:	9a 83       	std	Y+2, r25	; 0x02
   173c2:	89 83       	std	Y+1, r24	; 0x01
 greenfp();                              
   173c4:	e9 81       	ldd	r30, Y+1	; 0x01
   173c6:	fa 81       	ldd	r31, Y+2	; 0x02
   173c8:	09 95       	icall
   173ca:	22 96       	adiw	r28, 0x02	; 2
   173cc:	0f b6       	in	r0, 0x3f	; 63
   173ce:	f8 94       	cli
   173d0:	de bf       	out	0x3e, r29	; 62
   173d2:	0f be       	out	0x3f, r0	; 63
   173d4:	cd bf       	out	0x3d, r28	; 61
   173d6:	df 91       	pop	r29
   173d8:	cf 91       	pop	r28
   173da:	08 95       	ret

000173dc <redToggle>:



}

void redToggle()
{
   173dc:	cf 93       	push	r28
   173de:	df 93       	push	r29
   173e0:	cd b7       	in	r28, 0x3d	; 61
   173e2:	de b7       	in	r29, 0x3e	; 62
   173e4:	22 97       	sbiw	r28, 0x02	; 2
   173e6:	0f b6       	in	r0, 0x3f	; 63
   173e8:	f8 94       	cli
   173ea:	de bf       	out	0x3e, r29	; 62
   173ec:	0f be       	out	0x3f, r0	; 63
   173ee:	cd bf       	out	0x3d, r28	; 61
                          
  void (*redfp)() = (void (*)(void))RED_LED_TOGGLE_FUNCTION; 
   173f0:	88 e0       	ldi	r24, 0x08	; 8
   173f2:	9a ee       	ldi	r25, 0xEA	; 234
   173f4:	9a 83       	std	Y+2, r25	; 0x02
   173f6:	89 83       	std	Y+1, r24	; 0x01
  redfp();    
   173f8:	e9 81       	ldd	r30, Y+1	; 0x01
   173fa:	fa 81       	ldd	r31, Y+2	; 0x02
   173fc:	09 95       	icall
   173fe:	22 96       	adiw	r28, 0x02	; 2
   17400:	0f b6       	in	r0, 0x3f	; 63
   17402:	f8 94       	cli
   17404:	de bf       	out	0x3e, r29	; 62
   17406:	0f be       	out	0x3f, r0	; 63
   17408:	cd bf       	out	0x3d, r28	; 61
   1740a:	df 91       	pop	r29
   1740c:	cf 91       	pop	r28
   1740e:	08 95       	ret

00017410 <yellowToggle>:
}


void yellowToggle()
{
   17410:	cf 93       	push	r28
   17412:	df 93       	push	r29
   17414:	cd b7       	in	r28, 0x3d	; 61
   17416:	de b7       	in	r29, 0x3e	; 62
   17418:	22 97       	sbiw	r28, 0x02	; 2
   1741a:	0f b6       	in	r0, 0x3f	; 63
   1741c:	f8 94       	cli
   1741e:	de bf       	out	0x3e, r29	; 62
   17420:	0f be       	out	0x3f, r0	; 63
   17422:	cd bf       	out	0x3d, r28	; 61
                          
  void (*yellowfp)() = (void (*)(void))YELLOW_TOGGLE_FUNCTION; 
   17424:	80 e7       	ldi	r24, 0x70	; 112
   17426:	9a ee       	ldi	r25, 0xEA	; 234
   17428:	9a 83       	std	Y+2, r25	; 0x02
   1742a:	89 83       	std	Y+1, r24	; 0x01
  yellowfp();    
   1742c:	e9 81       	ldd	r30, Y+1	; 0x01
   1742e:	fa 81       	ldd	r31, Y+2	; 0x02
   17430:	09 95       	icall
   17432:	22 96       	adiw	r28, 0x02	; 2
   17434:	0f b6       	in	r0, 0x3f	; 63
   17436:	f8 94       	cli
   17438:	de bf       	out	0x3e, r29	; 62
   1743a:	0f be       	out	0x3f, r0	; 63
   1743c:	cd bf       	out	0x3d, r28	; 61
   1743e:	df 91       	pop	r29
   17440:	cf 91       	pop	r28
   17442:	08 95       	ret

00017444 <redOn>:
}



void redOn()
{
   17444:	cf 93       	push	r28
   17446:	df 93       	push	r29
   17448:	cd b7       	in	r28, 0x3d	; 61
   1744a:	de b7       	in	r29, 0x3e	; 62
   1744c:	22 97       	sbiw	r28, 0x02	; 2
   1744e:	0f b6       	in	r0, 0x3f	; 63
   17450:	f8 94       	cli
   17452:	de bf       	out	0x3e, r29	; 62
   17454:	0f be       	out	0x3f, r0	; 63
   17456:	cd bf       	out	0x3d, r28	; 61
                          
  void (*redfp)() = (void (*)(void))RED_ON_FUNCTION; 
   17458:	84 e7       	ldi	r24, 0x74	; 116
   1745a:	9a ee       	ldi	r25, 0xEA	; 234
   1745c:	9a 83       	std	Y+2, r25	; 0x02
   1745e:	89 83       	std	Y+1, r24	; 0x01
  redfp();    
   17460:	e9 81       	ldd	r30, Y+1	; 0x01
   17462:	fa 81       	ldd	r31, Y+2	; 0x02
   17464:	09 95       	icall
   17466:	22 96       	adiw	r28, 0x02	; 2
   17468:	0f b6       	in	r0, 0x3f	; 63
   1746a:	f8 94       	cli
   1746c:	de bf       	out	0x3e, r29	; 62
   1746e:	0f be       	out	0x3f, r0	; 63
   17470:	cd bf       	out	0x3d, r28	; 61
   17472:	df 91       	pop	r29
   17474:	cf 91       	pop	r28
   17476:	08 95       	ret

00017478 <redOff>:
}



void redOff()
{
   17478:	cf 93       	push	r28
   1747a:	df 93       	push	r29
   1747c:	cd b7       	in	r28, 0x3d	; 61
   1747e:	de b7       	in	r29, 0x3e	; 62
   17480:	22 97       	sbiw	r28, 0x02	; 2
   17482:	0f b6       	in	r0, 0x3f	; 63
   17484:	f8 94       	cli
   17486:	de bf       	out	0x3e, r29	; 62
   17488:	0f be       	out	0x3f, r0	; 63
   1748a:	cd bf       	out	0x3d, r28	; 61
                          
  void (*redfp)() = (void (*)(void))RED_OFF_FUNCTION; 
   1748c:	88 e7       	ldi	r24, 0x78	; 120
   1748e:	9a ee       	ldi	r25, 0xEA	; 234
   17490:	9a 83       	std	Y+2, r25	; 0x02
   17492:	89 83       	std	Y+1, r24	; 0x01
  redfp();    
   17494:	e9 81       	ldd	r30, Y+1	; 0x01
   17496:	fa 81       	ldd	r31, Y+2	; 0x02
   17498:	09 95       	icall
   1749a:	22 96       	adiw	r28, 0x02	; 2
   1749c:	0f b6       	in	r0, 0x3f	; 63
   1749e:	f8 94       	cli
   174a0:	de bf       	out	0x3e, r29	; 62
   174a2:	0f be       	out	0x3f, r0	; 63
   174a4:	cd bf       	out	0x3d, r28	; 61
   174a6:	df 91       	pop	r29
   174a8:	cf 91       	pop	r28
   174aa:	08 95       	ret

000174ac <greenOn>:
}



void greenOn()
{
   174ac:	cf 93       	push	r28
   174ae:	df 93       	push	r29
   174b0:	cd b7       	in	r28, 0x3d	; 61
   174b2:	de b7       	in	r29, 0x3e	; 62
   174b4:	22 97       	sbiw	r28, 0x02	; 2
   174b6:	0f b6       	in	r0, 0x3f	; 63
   174b8:	f8 94       	cli
   174ba:	de bf       	out	0x3e, r29	; 62
   174bc:	0f be       	out	0x3f, r0	; 63
   174be:	cd bf       	out	0x3d, r28	; 61
                          
  void (*greenfp)() = (void (*)(void))GREEN_ON_FUNCTION; 
   174c0:	84 e8       	ldi	r24, 0x84	; 132
   174c2:	9a ee       	ldi	r25, 0xEA	; 234
   174c4:	9a 83       	std	Y+2, r25	; 0x02
   174c6:	89 83       	std	Y+1, r24	; 0x01
  greenfp();    
   174c8:	e9 81       	ldd	r30, Y+1	; 0x01
   174ca:	fa 81       	ldd	r31, Y+2	; 0x02
   174cc:	09 95       	icall
   174ce:	22 96       	adiw	r28, 0x02	; 2
   174d0:	0f b6       	in	r0, 0x3f	; 63
   174d2:	f8 94       	cli
   174d4:	de bf       	out	0x3e, r29	; 62
   174d6:	0f be       	out	0x3f, r0	; 63
   174d8:	cd bf       	out	0x3d, r28	; 61
   174da:	df 91       	pop	r29
   174dc:	cf 91       	pop	r28
   174de:	08 95       	ret

000174e0 <greenOff>:
}


void greenOff()
{
   174e0:	cf 93       	push	r28
   174e2:	df 93       	push	r29
   174e4:	cd b7       	in	r28, 0x3d	; 61
   174e6:	de b7       	in	r29, 0x3e	; 62
   174e8:	22 97       	sbiw	r28, 0x02	; 2
   174ea:	0f b6       	in	r0, 0x3f	; 63
   174ec:	f8 94       	cli
   174ee:	de bf       	out	0x3e, r29	; 62
   174f0:	0f be       	out	0x3f, r0	; 63
   174f2:	cd bf       	out	0x3d, r28	; 61
                          
  void (*greenfp)() = (void (*)(void))GREEN_OFF_FUNCTION; 
   174f4:	88 e8       	ldi	r24, 0x88	; 136
   174f6:	9a ee       	ldi	r25, 0xEA	; 234
   174f8:	9a 83       	std	Y+2, r25	; 0x02
   174fa:	89 83       	std	Y+1, r24	; 0x01
  greenfp();    
   174fc:	e9 81       	ldd	r30, Y+1	; 0x01
   174fe:	fa 81       	ldd	r31, Y+2	; 0x02
   17500:	09 95       	icall
   17502:	22 96       	adiw	r28, 0x02	; 2
   17504:	0f b6       	in	r0, 0x3f	; 63
   17506:	f8 94       	cli
   17508:	de bf       	out	0x3e, r29	; 62
   1750a:	0f be       	out	0x3f, r0	; 63
   1750c:	cd bf       	out	0x3d, r28	; 61
   1750e:	df 91       	pop	r29
   17510:	cf 91       	pop	r28
   17512:	08 95       	ret

00017514 <yellowOn>:
}

void yellowOn()
{
   17514:	cf 93       	push	r28
   17516:	df 93       	push	r29
   17518:	cd b7       	in	r28, 0x3d	; 61
   1751a:	de b7       	in	r29, 0x3e	; 62
   1751c:	22 97       	sbiw	r28, 0x02	; 2
   1751e:	0f b6       	in	r0, 0x3f	; 63
   17520:	f8 94       	cli
   17522:	de bf       	out	0x3e, r29	; 62
   17524:	0f be       	out	0x3f, r0	; 63
   17526:	cd bf       	out	0x3d, r28	; 61
                          
  void (*yellowfp)() = (void (*)(void))YELLOW_ON_FUNCTION; 
   17528:	8c e7       	ldi	r24, 0x7C	; 124
   1752a:	9a ee       	ldi	r25, 0xEA	; 234
   1752c:	9a 83       	std	Y+2, r25	; 0x02
   1752e:	89 83       	std	Y+1, r24	; 0x01
  yellowfp();    
   17530:	e9 81       	ldd	r30, Y+1	; 0x01
   17532:	fa 81       	ldd	r31, Y+2	; 0x02
   17534:	09 95       	icall
   17536:	22 96       	adiw	r28, 0x02	; 2
   17538:	0f b6       	in	r0, 0x3f	; 63
   1753a:	f8 94       	cli
   1753c:	de bf       	out	0x3e, r29	; 62
   1753e:	0f be       	out	0x3f, r0	; 63
   17540:	cd bf       	out	0x3d, r28	; 61
   17542:	df 91       	pop	r29
   17544:	cf 91       	pop	r28
   17546:	08 95       	ret

00017548 <yellowOff>:
}

void yellowOff()
{
   17548:	cf 93       	push	r28
   1754a:	df 93       	push	r29
   1754c:	cd b7       	in	r28, 0x3d	; 61
   1754e:	de b7       	in	r29, 0x3e	; 62
   17550:	22 97       	sbiw	r28, 0x02	; 2
   17552:	0f b6       	in	r0, 0x3f	; 63
   17554:	f8 94       	cli
   17556:	de bf       	out	0x3e, r29	; 62
   17558:	0f be       	out	0x3f, r0	; 63
   1755a:	cd bf       	out	0x3d, r28	; 61
                          
  void (*yellowfp)() = (void (*)(void))YELLOW_OFF_FUNCTION; 
   1755c:	80 e8       	ldi	r24, 0x80	; 128
   1755e:	9a ee       	ldi	r25, 0xEA	; 234
   17560:	9a 83       	std	Y+2, r25	; 0x02
   17562:	89 83       	std	Y+1, r24	; 0x01
  yellowfp();    
   17564:	e9 81       	ldd	r30, Y+1	; 0x01
   17566:	fa 81       	ldd	r31, Y+2	; 0x02
   17568:	09 95       	icall
   1756a:	22 96       	adiw	r28, 0x02	; 2
   1756c:	0f b6       	in	r0, 0x3f	; 63
   1756e:	f8 94       	cli
   17570:	de bf       	out	0x3e, r29	; 62
   17572:	0f be       	out	0x3f, r0	; 63
   17574:	cd bf       	out	0x3d, r28	; 61
   17576:	df 91       	pop	r29
   17578:	cf 91       	pop	r28
   1757a:	08 95       	ret

0001757c <malloc>:

#include "malloc.h"

void *malloc(uint16_t size)
{
   1757c:	cf 93       	push	r28
   1757e:	df 93       	push	r29
   17580:	cd b7       	in	r28, 0x3d	; 61
   17582:	de b7       	in	r29, 0x3e	; 62
   17584:	26 97       	sbiw	r28, 0x06	; 6
   17586:	0f b6       	in	r0, 0x3f	; 63
   17588:	f8 94       	cli
   1758a:	de bf       	out	0x3e, r29	; 62
   1758c:	0f be       	out	0x3f, r0	; 63
   1758e:	cd bf       	out	0x3d, r28	; 61
   17590:	9e 83       	std	Y+6, r25	; 0x06
   17592:	8d 83       	std	Y+5, r24	; 0x05
 
   void (*mallocfunc)(void) = (void (*)(void))MALLOC_MEMORY_FUNCTION;
   17594:	80 eb       	ldi	r24, 0xB0	; 176
   17596:	9a ee       	ldi	r25, 0xEA	; 234
   17598:	9c 83       	std	Y+4, r25	; 0x04
   1759a:	8b 83       	std	Y+3, r24	; 0x03
   void *resultaddr; 

   asm volatile("push r20" "\n\t"
   1759c:	4f 93       	push	r20
   1759e:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   asm volatile(" mov r20, %A0" "\n\t"
   175a0:	8d 81       	ldd	r24, Y+5	; 0x05
   175a2:	9e 81       	ldd	r25, Y+6	; 0x06
   175a4:	48 2f       	mov	r20, r24
   175a6:	59 2f       	mov	r21, r25
	              " mov r21, %B0" "\n\t"
				        :
				 	      :"r" (size)				 
               );
                            	
   mallocfunc();     
   175a8:	eb 81       	ldd	r30, Y+3	; 0x03
   175aa:	fc 81       	ldd	r31, Y+4	; 0x04
   175ac:	09 95       	icall
   
   asm volatile(" mov %A0, r20" "\n\t"
   175ae:	84 2f       	mov	r24, r20
   175b0:	95 2f       	mov	r25, r21
   175b2:	9a 83       	std	Y+2, r25	; 0x02
   175b4:	89 83       	std	Y+1, r24	; 0x01
	               "mov %B0, r21" "\n\t"
				        :"=r" (resultaddr)
				        :
                );
    asm volatile("pop r21" "\n\t"
   175b6:	5f 91       	pop	r21
   175b8:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return (void*)resultaddr; 
   175ba:	89 81       	ldd	r24, Y+1	; 0x01
   175bc:	9a 81       	ldd	r25, Y+2	; 0x02
   175be:	26 96       	adiw	r28, 0x06	; 6
   175c0:	0f b6       	in	r0, 0x3f	; 63
   175c2:	f8 94       	cli
   175c4:	de bf       	out	0x3e, r29	; 62
   175c6:	0f be       	out	0x3f, r0	; 63
   175c8:	cd bf       	out	0x3d, r28	; 61
   175ca:	df 91       	pop	r29
   175cc:	cf 91       	pop	r28
   175ce:	08 95       	ret

000175d0 <free>:
}
	
	

void free(void *ptr)
{
   175d0:	cf 93       	push	r28
   175d2:	df 93       	push	r29
   175d4:	cd b7       	in	r28, 0x3d	; 61
   175d6:	de b7       	in	r29, 0x3e	; 62
   175d8:	24 97       	sbiw	r28, 0x04	; 4
   175da:	0f b6       	in	r0, 0x3f	; 63
   175dc:	f8 94       	cli
   175de:	de bf       	out	0x3e, r29	; 62
   175e0:	0f be       	out	0x3f, r0	; 63
   175e2:	cd bf       	out	0x3d, r28	; 61
   175e4:	9c 83       	std	Y+4, r25	; 0x04
   175e6:	8b 83       	std	Y+3, r24	; 0x03
  	
	 void (*mallocfunc)(void) = (void (*)(void))FREE_MEMORY_FUNCTION;
   175e8:	84 eb       	ldi	r24, 0xB4	; 180
   175ea:	9a ee       	ldi	r25, 0xEA	; 234
   175ec:	9a 83       	std	Y+2, r25	; 0x02
   175ee:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   175f0:	4f 93       	push	r20
   175f2:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   asm volatile(" mov r20, %A0" "\n\t"
   175f4:	8b 81       	ldd	r24, Y+3	; 0x03
   175f6:	9c 81       	ldd	r25, Y+4	; 0x04
   175f8:	48 2f       	mov	r20, r24
   175fa:	59 2f       	mov	r21, r25
	              " mov r21, %B0" "\n\t"
				        :
				 	      :"r" (ptr)				 
               );
                            	
   mallocfunc();     
   175fc:	e9 81       	ldd	r30, Y+1	; 0x01
   175fe:	fa 81       	ldd	r31, Y+2	; 0x02
   17600:	09 95       	icall
   
   asm volatile("pop r21" "\n\t"
   17602:	5f 91       	pop	r21
   17604:	4f 91       	pop	r20
   17606:	24 96       	adiw	r28, 0x04	; 4
   17608:	0f b6       	in	r0, 0x3f	; 63
   1760a:	f8 94       	cli
   1760c:	de bf       	out	0x3e, r29	; 62
   1760e:	0f be       	out	0x3f, r0	; 63
   17610:	cd bf       	out	0x3d, r28	; 61
   17612:	df 91       	pop	r29
   17614:	cf 91       	pop	r28
   17616:	08 95       	ret

00017618 <Mutex_lock>:
#include "thread.h"
#include "liteoscommon.h"

void Mutex_lock(mutex *m)
{
   17618:	cf 93       	push	r28
   1761a:	df 93       	push	r29
   1761c:	cd b7       	in	r28, 0x3d	; 61
   1761e:	de b7       	in	r29, 0x3e	; 62
   17620:	26 97       	sbiw	r28, 0x06	; 6
   17622:	0f b6       	in	r0, 0x3f	; 63
   17624:	f8 94       	cli
   17626:	de bf       	out	0x3e, r29	; 62
   17628:	0f be       	out	0x3f, r0	; 63
   1762a:	cd bf       	out	0x3d, r28	; 61
   1762c:	9e 83       	std	Y+6, r25	; 0x06
   1762e:	8d 83       	std	Y+5, r24	; 0x05
  
    thread **current_thread; 
    uint8_t threadindex; 
    

	_atomic_t currentatomic;
    
	current_thread = getCurrentThread(); 
   17630:	0e 94 af c2 	call	0x1855e
   17634:	9c 83       	std	Y+4, r25	; 0x04
   17636:	8b 83       	std	Y+3, r24	; 0x03
	threadindex = getCurrentThreadIndex(); 
   17638:	0e 94 f7 c2 	call	0x185ee
   1763c:	8a 83       	std	Y+2, r24	; 0x02

	currentatomic = _atomic_start();
   1763e:	0e 94 11 c2 	call	0x18422
   17642:	89 83       	std	Y+1, r24	; 0x01
	
    if(m->lock){  
   17644:	ed 81       	ldd	r30, Y+5	; 0x05
   17646:	fe 81       	ldd	r31, Y+6	; 0x06
   17648:	80 81       	ld	r24, Z
   1764a:	88 23       	and	r24, r24
   1764c:	01 f1       	breq	.+64     	; 0x1768e
        (*current_thread)->state = STATE_BLOCKED;
   1764e:	eb 81       	ldd	r30, Y+3	; 0x03
   17650:	fc 81       	ldd	r31, Y+4	; 0x04
   17652:	01 90       	ld	r0, Z+
   17654:	f0 81       	ld	r31, Z
   17656:	e0 2d       	mov	r30, r0
   17658:	83 e0       	ldi	r24, 0x03	; 3
   1765a:	82 83       	std	Z+2, r24	; 0x02
        (*current_thread)->data.m = m;
   1765c:	eb 81       	ldd	r30, Y+3	; 0x03
   1765e:	fc 81       	ldd	r31, Y+4	; 0x04
   17660:	01 90       	ld	r0, Z+
   17662:	f0 81       	ld	r31, Z
   17664:	e0 2d       	mov	r30, r0
   17666:	8d 81       	ldd	r24, Y+5	; 0x05
   17668:	9e 81       	ldd	r25, Y+6	; 0x06
   1766a:	94 8f       	std	Z+28, r25	; 0x1c
   1766c:	83 8f       	std	Z+27, r24	; 0x1b
        
      
        m->waiting++;
   1766e:	ed 81       	ldd	r30, Y+5	; 0x05
   17670:	fe 81       	ldd	r31, Y+6	; 0x06
   17672:	81 81       	ldd	r24, Z+1	; 0x01
   17674:	8f 5f       	subi	r24, 0xFF	; 255
   17676:	ed 81       	ldd	r30, Y+5	; 0x05
   17678:	fe 81       	ldd	r31, Y+6	; 0x06
   1767a:	81 83       	std	Z+1, r24	; 0x01
       
        yield();
   1767c:	0e 94 66 c3 	call	0x186cc
     
        m->waiting--;
   17680:	ed 81       	ldd	r30, Y+5	; 0x05
   17682:	fe 81       	ldd	r31, Y+6	; 0x06
   17684:	81 81       	ldd	r24, Z+1	; 0x01
   17686:	81 50       	subi	r24, 0x01	; 1
   17688:	ed 81       	ldd	r30, Y+5	; 0x05
   1768a:	fe 81       	ldd	r31, Y+6	; 0x06
   1768c:	81 83       	std	Z+1, r24	; 0x01
      }
      m->lock = 1;
   1768e:	ed 81       	ldd	r30, Y+5	; 0x05
   17690:	fe 81       	ldd	r31, Y+6	; 0x06
   17692:	81 e0       	ldi	r24, 0x01	; 1
   17694:	80 83       	st	Z, r24
      m->lockingthreadid = threadindex; 
   17696:	ed 81       	ldd	r30, Y+5	; 0x05
   17698:	fe 81       	ldd	r31, Y+6	; 0x06
   1769a:	8a 81       	ldd	r24, Y+2	; 0x02
   1769c:	82 83       	std	Z+2, r24	; 0x02
      
    _atomic_end(currentatomic);  
   1769e:	89 81       	ldd	r24, Y+1	; 0x01
   176a0:	0e 94 2b c2 	call	0x18456
   176a4:	26 96       	adiw	r28, 0x06	; 6
   176a6:	0f b6       	in	r0, 0x3f	; 63
   176a8:	f8 94       	cli
   176aa:	de bf       	out	0x3e, r29	; 62
   176ac:	0f be       	out	0x3f, r0	; 63
   176ae:	cd bf       	out	0x3d, r28	; 61
   176b0:	df 91       	pop	r29
   176b2:	cf 91       	pop	r28
   176b4:	08 95       	ret

000176b6 <Mutex_unlock>:


}



void Mutex_unlock(mutex *m)
{
   176b6:	cf 93       	push	r28
   176b8:	df 93       	push	r29
   176ba:	cd b7       	in	r28, 0x3d	; 61
   176bc:	de b7       	in	r29, 0x3e	; 62
   176be:	24 97       	sbiw	r28, 0x04	; 4
   176c0:	0f b6       	in	r0, 0x3f	; 63
   176c2:	f8 94       	cli
   176c4:	de bf       	out	0x3e, r29	; 62
   176c6:	0f be       	out	0x3f, r0	; 63
   176c8:	cd bf       	out	0x3d, r28	; 61
   176ca:	9c 83       	std	Y+4, r25	; 0x04
   176cc:	8b 83       	std	Y+3, r24	; 0x03
     
   void (*getaddrfp)(void) = (void (*)(void))MUTEX_UNLOCK_FUNCTION; 
   176ce:	88 e1       	ldi	r24, 0x18	; 24
   176d0:	9a ee       	ldi	r25, 0xEA	; 234
   176d2:	9a 83       	std	Y+2, r25	; 0x02
   176d4:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   176d6:	4f 93       	push	r20
   176d8:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
      
   asm volatile(" mov r20, %A0" "\n\t"
   176da:	8b 81       	ldd	r24, Y+3	; 0x03
   176dc:	9c 81       	ldd	r25, Y+4	; 0x04
   176de:	48 2f       	mov	r20, r24
   176e0:	59 2f       	mov	r21, r25
	              " mov r21, %B0" "\n\t"
				 :
				 :"r" (m)
                );

   getaddrfp();
   176e2:	e9 81       	ldd	r30, Y+1	; 0x01
   176e4:	fa 81       	ldd	r31, Y+2	; 0x02
   176e6:	09 95       	icall
   asm volatile( "pop r21" "\n\t"
   176e8:	5f 91       	pop	r21
   176ea:	4f 91       	pop	r20
   176ec:	24 96       	adiw	r28, 0x04	; 4
   176ee:	0f b6       	in	r0, 0x3f	; 63
   176f0:	f8 94       	cli
   176f2:	de bf       	out	0x3e, r29	; 62
   176f4:	0f be       	out	0x3f, r0	; 63
   176f6:	cd bf       	out	0x3d, r28	; 61
   176f8:	df 91       	pop	r29
   176fa:	cf 91       	pop	r28
   176fc:	08 95       	ret

000176fe <Barrier_block>:
	             "pop r20" "\n\t"
	              ::);
   return;  
}



 


void Barrier_block(uint8_t type, uint8_t id){
   176fe:	cf 93       	push	r28
   17700:	df 93       	push	r29
   17702:	cd b7       	in	r28, 0x3d	; 61
   17704:	de b7       	in	r29, 0x3e	; 62
   17706:	25 97       	sbiw	r28, 0x05	; 5
   17708:	0f b6       	in	r0, 0x3f	; 63
   1770a:	f8 94       	cli
   1770c:	de bf       	out	0x3e, r29	; 62
   1770e:	0f be       	out	0x3f, r0	; 63
   17710:	cd bf       	out	0x3d, r28	; 61
   17712:	8c 83       	std	Y+4, r24	; 0x04
   17714:	6d 83       	std	Y+5, r22	; 0x05
   
    _atomic_t currentatomic;
	thread **current_thread; 

     
	current_thread = getCurrentThread(); 
   17716:	0e 94 af c2 	call	0x1855e
   1771a:	9a 83       	std	Y+2, r25	; 0x02
   1771c:	89 83       	std	Y+1, r24	; 0x01

    currentatomic = _atomic_start();
   1771e:	0e 94 11 c2 	call	0x18422
   17722:	8b 83       	std	Y+3, r24	; 0x03
    
      (*current_thread)->state = STATE_IO;
   17724:	e9 81       	ldd	r30, Y+1	; 0x01
   17726:	fa 81       	ldd	r31, Y+2	; 0x02
   17728:	01 90       	ld	r0, Z+
   1772a:	f0 81       	ld	r31, Z
   1772c:	e0 2d       	mov	r30, r0
   1772e:	86 e0       	ldi	r24, 0x06	; 6
   17730:	82 83       	std	Z+2, r24	; 0x02
      (*current_thread)->data.iostate.type = type;
   17732:	e9 81       	ldd	r30, Y+1	; 0x01
   17734:	fa 81       	ldd	r31, Y+2	; 0x02
   17736:	01 90       	ld	r0, Z+
   17738:	f0 81       	ld	r31, Z
   1773a:	e0 2d       	mov	r30, r0
   1773c:	8c 81       	ldd	r24, Y+4	; 0x04
   1773e:	83 8f       	std	Z+27, r24	; 0x1b
      (*current_thread)->data.iostate.id = id;
   17740:	e9 81       	ldd	r30, Y+1	; 0x01
   17742:	fa 81       	ldd	r31, Y+2	; 0x02
   17744:	01 90       	ld	r0, Z+
   17746:	f0 81       	ld	r31, Z
   17748:	e0 2d       	mov	r30, r0
   1774a:	8d 81       	ldd	r24, Y+5	; 0x05
   1774c:	84 8f       	std	Z+28, r24	; 0x1c
      yield();
   1774e:	0e 94 66 c3 	call	0x186cc
    
    _atomic_end(currentatomic);
   17752:	8b 81       	ldd	r24, Y+3	; 0x03
   17754:	0e 94 2b c2 	call	0x18456
   17758:	25 96       	adiw	r28, 0x05	; 5
   1775a:	0f b6       	in	r0, 0x3f	; 63
   1775c:	f8 94       	cli
   1775e:	de bf       	out	0x3e, r29	; 62
   17760:	0f be       	out	0x3f, r0	; 63
   17762:	cd bf       	out	0x3d, r28	; 61
   17764:	df 91       	pop	r29
   17766:	cf 91       	pop	r28
   17768:	08 95       	ret

0001776a <getRadioMutexAddress>:
}



mutex *getRadioMutexAddress()
{
   1776a:	cf 93       	push	r28
   1776c:	df 93       	push	r29
   1776e:	cd b7       	in	r28, 0x3d	; 61
   17770:	de b7       	in	r29, 0x3e	; 62
   17772:	24 97       	sbiw	r28, 0x04	; 4
   17774:	0f b6       	in	r0, 0x3f	; 63
   17776:	f8 94       	cli
   17778:	de bf       	out	0x3e, r29	; 62
   1777a:	0f be       	out	0x3f, r0	; 63
   1777c:	cd bf       	out	0x3d, r28	; 61
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GET_RADIO_MUTEX_ADDRESS_FUNCTION; 
   1777e:	80 e1       	ldi	r24, 0x10	; 16
   17780:	9a ee       	ldi	r25, 0xEA	; 234
   17782:	9a 83       	std	Y+2, r25	; 0x02
   17784:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   17786:	4f 93       	push	r20
   17788:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   1778a:	e9 81       	ldd	r30, Y+1	; 0x01
   1778c:	fa 81       	ldd	r31, Y+2	; 0x02
   1778e:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17790:	84 2f       	mov	r24, r20
   17792:	95 2f       	mov	r25, r21
   17794:	9c 83       	std	Y+4, r25	; 0x04
   17796:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17798:	5f 91       	pop	r21
   1779a:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return msend; 
   1779c:	8b 81       	ldd	r24, Y+3	; 0x03
   1779e:	9c 81       	ldd	r25, Y+4	; 0x04
   177a0:	24 96       	adiw	r28, 0x04	; 4
   177a2:	0f b6       	in	r0, 0x3f	; 63
   177a4:	f8 94       	cli
   177a6:	de bf       	out	0x3e, r29	; 62
   177a8:	0f be       	out	0x3f, r0	; 63
   177aa:	cd bf       	out	0x3d, r28	; 61
   177ac:	df 91       	pop	r29
   177ae:	cf 91       	pop	r28
   177b0:	08 95       	ret

000177b2 <getSerialMutexAddress>:
}
 


mutex *getSerialMutexAddress()
{
   177b2:	cf 93       	push	r28
   177b4:	df 93       	push	r29
   177b6:	cd b7       	in	r28, 0x3d	; 61
   177b8:	de b7       	in	r29, 0x3e	; 62
   177ba:	24 97       	sbiw	r28, 0x04	; 4
   177bc:	0f b6       	in	r0, 0x3f	; 63
   177be:	f8 94       	cli
   177c0:	de bf       	out	0x3e, r29	; 62
   177c2:	0f be       	out	0x3f, r0	; 63
   177c4:	cd bf       	out	0x3d, r28	; 61
   mutex *msend;   

   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_MUTEX_ADDRESS_FUNCTION;
   177c6:	80 e9       	ldi	r24, 0x90	; 144
   177c8:	9a ee       	ldi	r25, 0xEA	; 234
   177ca:	9a 83       	std	Y+2, r25	; 0x02
   177cc:	89 83       	std	Y+1, r24	; 0x01
   
   asm volatile("push r20" "\n\t"
   177ce:	4f 93       	push	r20
   177d0:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   177d2:	e9 81       	ldd	r30, Y+1	; 0x01
   177d4:	fa 81       	ldd	r31, Y+2	; 0x02
   177d6:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   177d8:	84 2f       	mov	r24, r20
   177da:	95 2f       	mov	r25, r21
   177dc:	9c 83       	std	Y+4, r25	; 0x04
   177de:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
   asm volatile("pop r21" "\n\t"
   177e0:	5f 91       	pop	r21
   177e2:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return msend; 
   177e4:	8b 81       	ldd	r24, Y+3	; 0x03
   177e6:	9c 81       	ldd	r25, Y+4	; 0x04
   177e8:	24 96       	adiw	r28, 0x04	; 4
   177ea:	0f b6       	in	r0, 0x3f	; 63
   177ec:	f8 94       	cli
   177ee:	de bf       	out	0x3e, r29	; 62
   177f0:	0f be       	out	0x3f, r0	; 63
   177f2:	cd bf       	out	0x3d, r28	; 61
   177f4:	df 91       	pop	r29
   177f6:	cf 91       	pop	r28
   177f8:	08 95       	ret

000177fa <getFileMutexAddress>:
}
 



mutex *getFileMutexAddress()
{
   177fa:	cf 93       	push	r28
   177fc:	df 93       	push	r29
   177fe:	cd b7       	in	r28, 0x3d	; 61
   17800:	de b7       	in	r29, 0x3e	; 62
   17802:	24 97       	sbiw	r28, 0x04	; 4
   17804:	0f b6       	in	r0, 0x3f	; 63
   17806:	f8 94       	cli
   17808:	de bf       	out	0x3e, r29	; 62
   1780a:	0f be       	out	0x3f, r0	; 63
   1780c:	cd bf       	out	0x3d, r28	; 61
   mutex *mfile;   
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_MUTEX_ADDRESS; 
   1780e:	88 e2       	ldi	r24, 0x28	; 40
   17810:	9a ee       	ldi	r25, 0xEA	; 234
   17812:	9a 83       	std	Y+2, r25	; 0x02
   17814:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   17816:	4f 93       	push	r20
   17818:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   1781a:	e9 81       	ldd	r30, Y+1	; 0x01
   1781c:	fa 81       	ldd	r31, Y+2	; 0x02
   1781e:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17820:	84 2f       	mov	r24, r20
   17822:	95 2f       	mov	r25, r21
   17824:	9c 83       	std	Y+4, r25	; 0x04
   17826:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (mfile)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17828:	5f 91       	pop	r21
   1782a:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
    return mfile; 
   1782c:	8b 81       	ldd	r24, Y+3	; 0x03
   1782e:	9c 81       	ldd	r25, Y+4	; 0x04
   17830:	24 96       	adiw	r28, 0x04	; 4
   17832:	0f b6       	in	r0, 0x3f	; 63
   17834:	f8 94       	cli
   17836:	de bf       	out	0x3e, r29	; 62
   17838:	0f be       	out	0x3f, r0	; 63
   1783a:	cd bf       	out	0x3d, r28	; 61
   1783c:	df 91       	pop	r29
   1783e:	cf 91       	pop	r28
   17840:	08 95       	ret

00017842 <sendRadioMsg>:

thread* mythread;

void sendRadioMsg()
{
   17842:	cf 93       	push	r28
   17844:	df 93       	push	r29
   17846:	cd b7       	in	r28, 0x3d	; 61
   17848:	de b7       	in	r29, 0x3e	; 62
   1784a:	22 97       	sbiw	r28, 0x02	; 2
   1784c:	0f b6       	in	r0, 0x3f	; 63
   1784e:	f8 94       	cli
   17850:	de bf       	out	0x3e, r29	; 62
   17852:	0f be       	out	0x3f, r0	; 63
   17854:	cd bf       	out	0x3d, r28	; 61
 void (*radiosendfp)() = (void (*)(void))SOCKET_RADIO_SEND_FUNCTION;
   17856:	84 e1       	ldi	r24, 0x14	; 20
   17858:	9a ee       	ldi	r25, 0xEA	; 234
   1785a:	9a 83       	std	Y+2, r25	; 0x02
   1785c:	89 83       	std	Y+1, r24	; 0x01
 radiosendfp();
   1785e:	e9 81       	ldd	r30, Y+1	; 0x01
   17860:	fa 81       	ldd	r31, Y+2	; 0x02
   17862:	09 95       	icall
   17864:	22 96       	adiw	r28, 0x02	; 2
   17866:	0f b6       	in	r0, 0x3f	; 63
   17868:	f8 94       	cli
   1786a:	de bf       	out	0x3e, r29	; 62
   1786c:	0f be       	out	0x3f, r0	; 63
   1786e:	cd bf       	out	0x3d, r28	; 61
   17870:	df 91       	pop	r29
   17872:	cf 91       	pop	r28
   17874:	08 95       	ret

00017876 <radioSend_string>:
}



//This function sends out a string

void radioSend_string(uint8_t *msg)
{
   17876:	cf 93       	push	r28
   17878:	df 93       	push	r29
   1787a:	cd b7       	in	r28, 0x3d	; 61
   1787c:	de b7       	in	r29, 0x3e	; 62
   1787e:	23 97       	sbiw	r28, 0x03	; 3
   17880:	0f b6       	in	r0, 0x3f	; 63
   17882:	f8 94       	cli
   17884:	de bf       	out	0x3e, r29	; 62
   17886:	0f be       	out	0x3f, r0	; 63
   17888:	cd bf       	out	0x3d, r28	; 61
   1788a:	9b 83       	std	Y+3, r25	; 0x03
   1788c:	8a 83       	std	Y+2, r24	; 0x02

    uint8_t temp = (uint8_t)String_length((char *)msg);
   1788e:	8a 81       	ldd	r24, Y+2	; 0x02
   17890:	9b 81       	ldd	r25, Y+3	; 0x03
   17892:	0e 94 66 c0 	call	0x180cc
   17896:	89 83       	std	Y+1, r24	; 0x01
	return radioSend(1, 0xffff, temp, msg);
   17898:	8a 81       	ldd	r24, Y+2	; 0x02
   1789a:	9b 81       	ldd	r25, Y+3	; 0x03
   1789c:	9c 01       	movw	r18, r24
   1789e:	49 81       	ldd	r20, Y+1	; 0x01
   178a0:	6f ef       	ldi	r22, 0xFF	; 255
   178a2:	7f ef       	ldi	r23, 0xFF	; 255
   178a4:	81 e0       	ldi	r24, 0x01	; 1
   178a6:	90 e0       	ldi	r25, 0x00	; 0
   178a8:	0e 94 66 bd 	call	0x17acc
   178ac:	23 96       	adiw	r28, 0x03	; 3
   178ae:	0f b6       	in	r0, 0x3f	; 63
   178b0:	f8 94       	cli
   178b2:	de bf       	out	0x3e, r29	; 62
   178b4:	0f be       	out	0x3f, r0	; 63
   178b6:	cd bf       	out	0x3d, r28	; 61
   178b8:	df 91       	pop	r29
   178ba:	cf 91       	pop	r28
   178bc:	08 95       	ret

000178be <radioSend_uint16>:


}





void radioSend_uint16(uint16_t value)
{
   178be:	cf 93       	push	r28
   178c0:	df 93       	push	r29
   178c2:	cd b7       	in	r28, 0x3d	; 61
   178c4:	de b7       	in	r29, 0x3e	; 62
   178c6:	24 97       	sbiw	r28, 0x04	; 4
   178c8:	0f b6       	in	r0, 0x3f	; 63
   178ca:	f8 94       	cli
   178cc:	de bf       	out	0x3e, r29	; 62
   178ce:	0f be       	out	0x3f, r0	; 63
   178d0:	cd bf       	out	0x3d, r28	; 61
   178d2:	9c 83       	std	Y+4, r25	; 0x04
   178d4:	8b 83       	std	Y+3, r24	; 0x03
  uint8_t temp1,temp2;
  temp1 = (uint8_t) (value >> 8);
   178d6:	8b 81       	ldd	r24, Y+3	; 0x03
   178d8:	9c 81       	ldd	r25, Y+4	; 0x04
   178da:	89 2f       	mov	r24, r25
   178dc:	99 27       	eor	r25, r25
   178de:	8a 83       	std	Y+2, r24	; 0x02
  temp2 = (uint8_t) (value & 0x00ff);
   178e0:	8b 81       	ldd	r24, Y+3	; 0x03
   178e2:	89 83       	std	Y+1, r24	; 0x01

  buffer[0] = temp1;
   178e4:	8a 81       	ldd	r24, Y+2	; 0x02
   178e6:	80 93 6a 0a 	sts	0x0A6A, r24
  buffer[1] = temp2;
   178ea:	89 81       	ldd	r24, Y+1	; 0x01
   178ec:	80 93 6b 0a 	sts	0x0A6B, r24
  buffer[2] = buffer[3] = 0xee;
   178f0:	8e ee       	ldi	r24, 0xEE	; 238
   178f2:	80 93 6d 0a 	sts	0x0A6D, r24
   178f6:	80 91 6d 0a 	lds	r24, 0x0A6D
   178fa:	80 93 6c 0a 	sts	0x0A6C, r24

  return radioSend(12, 0xffff, 16, buffer);
   178fe:	8a e6       	ldi	r24, 0x6A	; 106
   17900:	9a e0       	ldi	r25, 0x0A	; 10
   17902:	9c 01       	movw	r18, r24
   17904:	40 e1       	ldi	r20, 0x10	; 16
   17906:	6f ef       	ldi	r22, 0xFF	; 255
   17908:	7f ef       	ldi	r23, 0xFF	; 255
   1790a:	8c e0       	ldi	r24, 0x0C	; 12
   1790c:	90 e0       	ldi	r25, 0x00	; 0
   1790e:	0e 94 66 bd 	call	0x17acc
   17912:	24 96       	adiw	r28, 0x04	; 4
   17914:	0f b6       	in	r0, 0x3f	; 63
   17916:	f8 94       	cli
   17918:	de bf       	out	0x3e, r29	; 62
   1791a:	0f be       	out	0x3f, r0	; 63
   1791c:	cd bf       	out	0x3d, r28	; 61
   1791e:	df 91       	pop	r29
   17920:	cf 91       	pop	r28
   17922:	08 95       	ret

00017924 <getCurrentRadioHandleAddr>:

}




radiohandletype *getCurrentRadioHandleAddr()
{
   17924:	cf 93       	push	r28
   17926:	df 93       	push	r29
   17928:	cd b7       	in	r28, 0x3d	; 61
   1792a:	de b7       	in	r29, 0x3e	; 62
   1792c:	24 97       	sbiw	r28, 0x04	; 4
   1792e:	0f b6       	in	r0, 0x3f	; 63
   17930:	f8 94       	cli
   17932:	de bf       	out	0x3e, r29	; 62
   17934:	0f be       	out	0x3f, r0	; 63
   17936:	cd bf       	out	0x3d, r28	; 61
   radiohandletype *currentradioinfo;

   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_HANDLE_ADDR;
   17938:	80 e6       	ldi	r24, 0x60	; 96
   1793a:	9a ee       	ldi	r25, 0xEA	; 234
   1793c:	9a 83       	std	Y+2, r25	; 0x02
   1793e:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   17940:	4f 93       	push	r20
   17942:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   17944:	e9 81       	ldd	r30, Y+1	; 0x01
   17946:	fa 81       	ldd	r31, Y+2	; 0x02
   17948:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   1794a:	84 2f       	mov	r24, r20
   1794c:	95 2f       	mov	r25, r21
   1794e:	9c 83       	std	Y+4, r25	; 0x04
   17950:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17952:	5f 91       	pop	r21
   17954:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo;
   17956:	8b 81       	ldd	r24, Y+3	; 0x03
   17958:	9c 81       	ldd	r25, Y+4	; 0x04
   1795a:	24 96       	adiw	r28, 0x04	; 4
   1795c:	0f b6       	in	r0, 0x3f	; 63
   1795e:	f8 94       	cli
   17960:	de bf       	out	0x3e, r29	; 62
   17962:	0f be       	out	0x3f, r0	; 63
   17964:	cd bf       	out	0x3d, r28	; 61
   17966:	df 91       	pop	r29
   17968:	cf 91       	pop	r28
   1796a:	08 95       	ret

0001796c <setRadioFreq>:
}


void setRadioFreq(uint16_t freq)
{
   1796c:	cf 93       	push	r28
   1796e:	df 93       	push	r29
   17970:	cd b7       	in	r28, 0x3d	; 61
   17972:	de b7       	in	r29, 0x3e	; 62
   17974:	24 97       	sbiw	r28, 0x04	; 4
   17976:	0f b6       	in	r0, 0x3f	; 63
   17978:	f8 94       	cli
   1797a:	de bf       	out	0x3e, r29	; 62
   1797c:	0f be       	out	0x3f, r0	; 63
   1797e:	cd bf       	out	0x3d, r28	; 61
   17980:	9c 83       	std	Y+4, r25	; 0x04
   17982:	8b 83       	std	Y+3, r24	; 0x03

   void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_FREQ_FUNCTION;
   17984:	80 ec       	ldi	r24, 0xC0	; 192
   17986:	9a ee       	ldi	r25, 0xEA	; 234
   17988:	9a 83       	std	Y+2, r25	; 0x02
   1798a:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   1798c:	4f 93       	push	r20
   1798e:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);

   asm volatile(" mov r20, %A0" "\n\t"
   17990:	8b 81       	ldd	r24, Y+3	; 0x03
   17992:	9c 81       	ldd	r25, Y+4	; 0x04
   17994:	48 2f       	mov	r20, r24
   17996:	59 2f       	mov	r21, r25
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (freq)
                );
   getaddrfp();
   17998:	e9 81       	ldd	r30, Y+1	; 0x01
   1799a:	fa 81       	ldd	r31, Y+2	; 0x02
   1799c:	09 95       	icall
   asm volatile("pop r21" "\n\t"
   1799e:	5f 91       	pop	r21
   179a0:	4f 91       	pop	r20
   179a2:	24 96       	adiw	r28, 0x04	; 4
   179a4:	0f b6       	in	r0, 0x3f	; 63
   179a6:	f8 94       	cli
   179a8:	de bf       	out	0x3e, r29	; 62
   179aa:	0f be       	out	0x3f, r0	; 63
   179ac:	cd bf       	out	0x3d, r28	; 61
   179ae:	df 91       	pop	r29
   179b0:	cf 91       	pop	r28
   179b2:	08 95       	ret

000179b4 <setRadioChannel>:
	             "pop r20" "\n\t"
	              ::);
   return;
}

void setRadioChannel(uint8_t channel)
{
   179b4:	cf 93       	push	r28
   179b6:	df 93       	push	r29
   179b8:	cd b7       	in	r28, 0x3d	; 61
   179ba:	de b7       	in	r29, 0x3e	; 62
   179bc:	25 97       	sbiw	r28, 0x05	; 5
   179be:	0f b6       	in	r0, 0x3f	; 63
   179c0:	f8 94       	cli
   179c2:	de bf       	out	0x3e, r29	; 62
   179c4:	0f be       	out	0x3f, r0	; 63
   179c6:	cd bf       	out	0x3d, r28	; 61
   179c8:	8d 83       	std	Y+5, r24	; 0x05

  uint16_t maskchannel = channel;
   179ca:	8d 81       	ldd	r24, Y+5	; 0x05
   179cc:	99 27       	eor	r25, r25
   179ce:	9c 83       	std	Y+4, r25	; 0x04
   179d0:	8b 83       	std	Y+3, r24	; 0x03

  void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_CHANNEL_FUNCTION;
   179d2:	84 ec       	ldi	r24, 0xC4	; 196
   179d4:	9a ee       	ldi	r25, 0xEA	; 234
   179d6:	9a 83       	std	Y+2, r25	; 0x02
   179d8:	89 83       	std	Y+1, r24	; 0x01

  asm volatile("push r20" "\n\t"
   179da:	4f 93       	push	r20
   179dc:	5f 93       	push	r21
               "push r21" "\n\t"
               ::);

  asm volatile(" mov r20, %A0" "\n\t"
   179de:	8b 81       	ldd	r24, Y+3	; 0x03
   179e0:	9c 81       	ldd	r25, Y+4	; 0x04
   179e2:	48 2f       	mov	r20, r24
   179e4:	59 2f       	mov	r21, r25
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp();
   179e6:	e9 81       	ldd	r30, Y+1	; 0x01
   179e8:	fa 81       	ldd	r31, Y+2	; 0x02
   179ea:	09 95       	icall
   asm volatile("pop r21" "\n\t"
   179ec:	5f 91       	pop	r21
   179ee:	4f 91       	pop	r20
   179f0:	25 96       	adiw	r28, 0x05	; 5
   179f2:	0f b6       	in	r0, 0x3f	; 63
   179f4:	f8 94       	cli
   179f6:	de bf       	out	0x3e, r29	; 62
   179f8:	0f be       	out	0x3f, r0	; 63
   179fa:	cd bf       	out	0x3d, r28	; 61
   179fc:	df 91       	pop	r29
   179fe:	cf 91       	pop	r28
   17a00:	08 95       	ret

00017a02 <setRadioPower>:
	             "pop r20" "\n\t"
	              ::);
   return;
}

void setRadioPower(uint8_t power)
{
   17a02:	cf 93       	push	r28
   17a04:	df 93       	push	r29
   17a06:	cd b7       	in	r28, 0x3d	; 61
   17a08:	de b7       	in	r29, 0x3e	; 62
   17a0a:	25 97       	sbiw	r28, 0x05	; 5
   17a0c:	0f b6       	in	r0, 0x3f	; 63
   17a0e:	f8 94       	cli
   17a10:	de bf       	out	0x3e, r29	; 62
   17a12:	0f be       	out	0x3f, r0	; 63
   17a14:	cd bf       	out	0x3d, r28	; 61
   17a16:	8d 83       	std	Y+5, r24	; 0x05

  uint16_t maskchannel = power;
   17a18:	8d 81       	ldd	r24, Y+5	; 0x05
   17a1a:	99 27       	eor	r25, r25
   17a1c:	9c 83       	std	Y+4, r25	; 0x04
   17a1e:	8b 83       	std	Y+3, r24	; 0x03

  void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_POWER_FUNCTION;
   17a20:	88 ec       	ldi	r24, 0xC8	; 200
   17a22:	9a ee       	ldi	r25, 0xEA	; 234
   17a24:	9a 83       	std	Y+2, r25	; 0x02
   17a26:	89 83       	std	Y+1, r24	; 0x01

  asm volatile("push r20" "\n\t"
   17a28:	4f 93       	push	r20
   17a2a:	5f 93       	push	r21
               "push r21" "\n\t"
               ::);

  asm volatile(" mov r20, %A0" "\n\t"
   17a2c:	8b 81       	ldd	r24, Y+3	; 0x03
   17a2e:	9c 81       	ldd	r25, Y+4	; 0x04
   17a30:	48 2f       	mov	r20, r24
   17a32:	59 2f       	mov	r21, r25
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp();
   17a34:	e9 81       	ldd	r30, Y+1	; 0x01
   17a36:	fa 81       	ldd	r31, Y+2	; 0x02
   17a38:	09 95       	icall
   asm volatile("pop r21" "\n\t"
   17a3a:	5f 91       	pop	r21
   17a3c:	4f 91       	pop	r20
   17a3e:	25 96       	adiw	r28, 0x05	; 5
   17a40:	0f b6       	in	r0, 0x3f	; 63
   17a42:	f8 94       	cli
   17a44:	de bf       	out	0x3e, r29	; 62
   17a46:	0f be       	out	0x3f, r0	; 63
   17a48:	cd bf       	out	0x3d, r28	; 61
   17a4a:	df 91       	pop	r29
   17a4c:	cf 91       	pop	r28
   17a4e:	08 95       	ret

00017a50 <getCurrentRadioInfoAddr>:
	             "pop r20" "\n\t"
	              ::);
   return;
}



radioinfotype *getCurrentRadioInfoAddr()
{
   17a50:	cf 93       	push	r28
   17a52:	df 93       	push	r29
   17a54:	cd b7       	in	r28, 0x3d	; 61
   17a56:	de b7       	in	r29, 0x3e	; 62
   17a58:	24 97       	sbiw	r28, 0x04	; 4
   17a5a:	0f b6       	in	r0, 0x3f	; 63
   17a5c:	f8 94       	cli
   17a5e:	de bf       	out	0x3e, r29	; 62
   17a60:	0f be       	out	0x3f, r0	; 63
   17a62:	cd bf       	out	0x3d, r28	; 61
   radioinfotype *currentradioinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_INFO_ADDR;
   17a64:	8c e5       	ldi	r24, 0x5C	; 92
   17a66:	9a ee       	ldi	r25, 0xEA	; 234
   17a68:	9a 83       	std	Y+2, r25	; 0x02
   17a6a:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   17a6c:	4f 93       	push	r20
   17a6e:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   17a70:	e9 81       	ldd	r30, Y+1	; 0x01
   17a72:	fa 81       	ldd	r31, Y+2	; 0x02
   17a74:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17a76:	84 2f       	mov	r24, r20
   17a78:	95 2f       	mov	r25, r21
   17a7a:	9c 83       	std	Y+4, r25	; 0x04
   17a7c:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17a7e:	5f 91       	pop	r21
   17a80:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo;
   17a82:	8b 81       	ldd	r24, Y+3	; 0x03
   17a84:	9c 81       	ldd	r25, Y+4	; 0x04
   17a86:	24 96       	adiw	r28, 0x04	; 4
   17a88:	0f b6       	in	r0, 0x3f	; 63
   17a8a:	f8 94       	cli
   17a8c:	de bf       	out	0x3e, r29	; 62
   17a8e:	0f be       	out	0x3f, r0	; 63
   17a90:	cd bf       	out	0x3d, r28	; 61
   17a92:	df 91       	pop	r29
   17a94:	cf 91       	pop	r28
   17a96:	08 95       	ret

00017a98 <disableRadioState>:
}


void disableRadioState()
{
   17a98:	cf 93       	push	r28
   17a9a:	df 93       	push	r29
   17a9c:	cd b7       	in	r28, 0x3d	; 61
   17a9e:	de b7       	in	r29, 0x3e	; 62
   17aa0:	22 97       	sbiw	r28, 0x02	; 2
   17aa2:	0f b6       	in	r0, 0x3f	; 63
   17aa4:	f8 94       	cli
   17aa6:	de bf       	out	0x3e, r29	; 62
   17aa8:	0f be       	out	0x3f, r0	; 63
   17aaa:	cd bf       	out	0x3d, r28	; 61

   void (*disableradiofp)(void) = (void (*)(void))RESTORE_RADIO_STATE;
   17aac:	88 eb       	ldi	r24, 0xB8	; 184
   17aae:	9a ee       	ldi	r25, 0xEA	; 234
   17ab0:	9a 83       	std	Y+2, r25	; 0x02
   17ab2:	89 83       	std	Y+1, r24	; 0x01

   disableradiofp();
   17ab4:	e9 81       	ldd	r30, Y+1	; 0x01
   17ab6:	fa 81       	ldd	r31, Y+2	; 0x02
   17ab8:	09 95       	icall
   17aba:	22 96       	adiw	r28, 0x02	; 2
   17abc:	0f b6       	in	r0, 0x3f	; 63
   17abe:	f8 94       	cli
   17ac0:	de bf       	out	0x3e, r29	; 62
   17ac2:	0f be       	out	0x3f, r0	; 63
   17ac4:	cd bf       	out	0x3d, r28	; 61
   17ac6:	df 91       	pop	r29
   17ac8:	cf 91       	pop	r28
   17aca:	08 95       	ret

00017acc <radioSend>:

   return;
}


void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
   17acc:	cf 93       	push	r28
   17ace:	df 93       	push	r29
   17ad0:	cd b7       	in	r28, 0x3d	; 61
   17ad2:	de b7       	in	r29, 0x3e	; 62
   17ad4:	2d 97       	sbiw	r28, 0x0d	; 13
   17ad6:	0f b6       	in	r0, 0x3f	; 63
   17ad8:	f8 94       	cli
   17ada:	de bf       	out	0x3e, r29	; 62
   17adc:	0f be       	out	0x3f, r0	; 63
   17ade:	cd bf       	out	0x3d, r28	; 61
   17ae0:	98 87       	std	Y+8, r25	; 0x08
   17ae2:	8f 83       	std	Y+7, r24	; 0x07
   17ae4:	7a 87       	std	Y+10, r23	; 0x0a
   17ae6:	69 87       	std	Y+9, r22	; 0x09
   17ae8:	4b 87       	std	Y+11, r20	; 0x0b
   17aea:	3d 87       	std	Y+13, r19	; 0x0d
   17aec:	2c 87       	std	Y+12, r18	; 0x0c


   mutex* msend;
   thread** current_thread;
   radioinfotype *radioinfoaddr;



   msend = getRadioMutexAddress();
   17aee:	0e 94 b5 bb 	call	0x1776a
   17af2:	9e 83       	std	Y+6, r25	; 0x06
   17af4:	8d 83       	std	Y+5, r24	; 0x05
   current_thread = getCurrentThread();
   17af6:	0e 94 af c2 	call	0x1855e
   17afa:	9c 83       	std	Y+4, r25	; 0x04
   17afc:	8b 83       	std	Y+3, r24	; 0x03
   radioinfoaddr = getCurrentRadioInfoAddr();
   17afe:	0e 94 28 bd 	call	0x17a50
   17b02:	9a 83       	std	Y+2, r25	; 0x02
   17b04:	89 83       	std	Y+1, r24	; 0x01

   Mutex_lock(msend);
   17b06:	8d 81       	ldd	r24, Y+5	; 0x05
   17b08:	9e 81       	ldd	r25, Y+6	; 0x06
   17b0a:	0e 94 0c bb 	call	0x17618

   radioinfoaddr-> socket_port = port;
   17b0e:	e9 81       	ldd	r30, Y+1	; 0x01
   17b10:	fa 81       	ldd	r31, Y+2	; 0x02
   17b12:	8f 81       	ldd	r24, Y+7	; 0x07
   17b14:	98 85       	ldd	r25, Y+8	; 0x08
   17b16:	91 83       	std	Z+1, r25	; 0x01
   17b18:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address;
   17b1a:	e9 81       	ldd	r30, Y+1	; 0x01
   17b1c:	fa 81       	ldd	r31, Y+2	; 0x02
   17b1e:	89 85       	ldd	r24, Y+9	; 0x09
   17b20:	9a 85       	ldd	r25, Y+10	; 0x0a
   17b22:	93 83       	std	Z+3, r25	; 0x03
   17b24:	82 83       	std	Z+2, r24	; 0x02
   radioinfoaddr->socket_msg_len  = length;
   17b26:	e9 81       	ldd	r30, Y+1	; 0x01
   17b28:	fa 81       	ldd	r31, Y+2	; 0x02
   17b2a:	8b 85       	ldd	r24, Y+11	; 0x0b
   17b2c:	84 83       	std	Z+4, r24	; 0x04
   radioinfoaddr->socket_msg  = msg;
   17b2e:	e9 81       	ldd	r30, Y+1	; 0x01
   17b30:	fa 81       	ldd	r31, Y+2	; 0x02
   17b32:	8c 85       	ldd	r24, Y+12	; 0x0c
   17b34:	9d 85       	ldd	r25, Y+13	; 0x0d
   17b36:	96 83       	std	Z+6, r25	; 0x06
   17b38:	85 83       	std	Z+5, r24	; 0x05

   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg();
   17b3a:	0e 94 21 bc 	call	0x17842

   sleepThread(6);
   17b3e:	86 e0       	ldi	r24, 0x06	; 6
   17b40:	90 e0       	ldi	r25, 0x00	; 0
   17b42:	0e 94 1b c3 	call	0x18636

   disableRadioState();
   17b46:	0e 94 4c bd 	call	0x17a98


   Mutex_unlock(msend);
   17b4a:	8d 81       	ldd	r24, Y+5	; 0x05
   17b4c:	9e 81       	ldd	r25, Y+6	; 0x06
   17b4e:	0e 94 5b bb 	call	0x176b6
   17b52:	2d 96       	adiw	r28, 0x0d	; 13
   17b54:	0f b6       	in	r0, 0x3f	; 63
   17b56:	f8 94       	cli
   17b58:	de bf       	out	0x3e, r29	; 62
   17b5a:	0f be       	out	0x3f, r0	; 63
   17b5c:	cd bf       	out	0x3d, r28	; 61
   17b5e:	df 91       	pop	r29
   17b60:	cf 91       	pop	r28
   17b62:	08 95       	ret

00017b64 <radioSend_string_experimental>:

   return;
}


void radioSend_string_experimental(uint8_t *msg)
{
   17b64:	cf 93       	push	r28
   17b66:	df 93       	push	r29
   17b68:	cd b7       	in	r28, 0x3d	; 61
   17b6a:	de b7       	in	r29, 0x3e	; 62
   17b6c:	23 97       	sbiw	r28, 0x03	; 3
   17b6e:	0f b6       	in	r0, 0x3f	; 63
   17b70:	f8 94       	cli
   17b72:	de bf       	out	0x3e, r29	; 62
   17b74:	0f be       	out	0x3f, r0	; 63
   17b76:	cd bf       	out	0x3d, r28	; 61
   17b78:	9b 83       	std	Y+3, r25	; 0x03
   17b7a:	8a 83       	std	Y+2, r24	; 0x02

    uint8_t temp = (uint8_t)String_length((char *)msg);
   17b7c:	8a 81       	ldd	r24, Y+2	; 0x02
   17b7e:	9b 81       	ldd	r25, Y+3	; 0x03
   17b80:	0e 94 66 c0 	call	0x180cc
   17b84:	89 83       	std	Y+1, r24	; 0x01
	return radioSend_Experimental(1, 0xffff, temp, msg);
   17b86:	8a 81       	ldd	r24, Y+2	; 0x02
   17b88:	9b 81       	ldd	r25, Y+3	; 0x03
   17b8a:	9c 01       	movw	r18, r24
   17b8c:	49 81       	ldd	r20, Y+1	; 0x01
   17b8e:	6f ef       	ldi	r22, 0xFF	; 255
   17b90:	7f ef       	ldi	r23, 0xFF	; 255
   17b92:	81 e0       	ldi	r24, 0x01	; 1
   17b94:	90 e0       	ldi	r25, 0x00	; 0
   17b96:	0e 94 d6 bd 	call	0x17bac
   17b9a:	23 96       	adiw	r28, 0x03	; 3
   17b9c:	0f b6       	in	r0, 0x3f	; 63
   17b9e:	f8 94       	cli
   17ba0:	de bf       	out	0x3e, r29	; 62
   17ba2:	0f be       	out	0x3f, r0	; 63
   17ba4:	cd bf       	out	0x3d, r28	; 61
   17ba6:	df 91       	pop	r29
   17ba8:	cf 91       	pop	r28
   17baa:	08 95       	ret

00017bac <radioSend_Experimental>:


}




void radioSend_Experimental(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
   17bac:	cf 93       	push	r28
   17bae:	df 93       	push	r29
   17bb0:	cd b7       	in	r28, 0x3d	; 61
   17bb2:	de b7       	in	r29, 0x3e	; 62
   17bb4:	2b 97       	sbiw	r28, 0x0b	; 11
   17bb6:	0f b6       	in	r0, 0x3f	; 63
   17bb8:	f8 94       	cli
   17bba:	de bf       	out	0x3e, r29	; 62
   17bbc:	0f be       	out	0x3f, r0	; 63
   17bbe:	cd bf       	out	0x3d, r28	; 61
   17bc0:	9e 83       	std	Y+6, r25	; 0x06
   17bc2:	8d 83       	std	Y+5, r24	; 0x05
   17bc4:	78 87       	std	Y+8, r23	; 0x08
   17bc6:	6f 83       	std	Y+7, r22	; 0x07
   17bc8:	49 87       	std	Y+9, r20	; 0x09
   17bca:	3b 87       	std	Y+11, r19	; 0x0b
   17bcc:	2a 87       	std	Y+10, r18	; 0x0a


   mutex* msend;
   radioinfotype *radioinfoaddr;


   msend = getRadioMutexAddress();
   17bce:	0e 94 b5 bb 	call	0x1776a
   17bd2:	9c 83       	std	Y+4, r25	; 0x04
   17bd4:	8b 83       	std	Y+3, r24	; 0x03
   radioinfoaddr = getCurrentRadioInfoAddr();
   17bd6:	0e 94 28 bd 	call	0x17a50
   17bda:	9a 83       	std	Y+2, r25	; 0x02
   17bdc:	89 83       	std	Y+1, r24	; 0x01


   radioinfoaddr-> socket_port = port;
   17bde:	e9 81       	ldd	r30, Y+1	; 0x01
   17be0:	fa 81       	ldd	r31, Y+2	; 0x02
   17be2:	8d 81       	ldd	r24, Y+5	; 0x05
   17be4:	9e 81       	ldd	r25, Y+6	; 0x06
   17be6:	91 83       	std	Z+1, r25	; 0x01
   17be8:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address;
   17bea:	e9 81       	ldd	r30, Y+1	; 0x01
   17bec:	fa 81       	ldd	r31, Y+2	; 0x02
   17bee:	8f 81       	ldd	r24, Y+7	; 0x07
   17bf0:	98 85       	ldd	r25, Y+8	; 0x08
   17bf2:	93 83       	std	Z+3, r25	; 0x03
   17bf4:	82 83       	std	Z+2, r24	; 0x02
   radioinfoaddr->socket_msg_len  = length;
   17bf6:	e9 81       	ldd	r30, Y+1	; 0x01
   17bf8:	fa 81       	ldd	r31, Y+2	; 0x02
   17bfa:	89 85       	ldd	r24, Y+9	; 0x09
   17bfc:	84 83       	std	Z+4, r24	; 0x04
   radioinfoaddr->socket_msg  = msg;
   17bfe:	e9 81       	ldd	r30, Y+1	; 0x01
   17c00:	fa 81       	ldd	r31, Y+2	; 0x02
   17c02:	8a 85       	ldd	r24, Y+10	; 0x0a
   17c04:	9b 85       	ldd	r25, Y+11	; 0x0b
   17c06:	96 83       	std	Z+6, r25	; 0x06
   17c08:	85 83       	std	Z+5, r24	; 0x05

   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   
   disableRadioState();
   17c0a:	0e 94 4c bd 	call	0x17a98
   sendRadioMsg();
   17c0e:	0e 94 21 bc 	call	0x17842
   17c12:	2b 96       	adiw	r28, 0x0b	; 11
   17c14:	0f b6       	in	r0, 0x3f	; 63
   17c16:	f8 94       	cli
   17c18:	de bf       	out	0x3e, r29	; 62
   17c1a:	0f be       	out	0x3f, r0	; 63
   17c1c:	cd bf       	out	0x3d, r28	; 61
   17c1e:	df 91       	pop	r29
   17c20:	cf 91       	pop	r28
   17c22:	08 95       	ret

00017c24 <wakeupMe>:


   return;
}

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
   17c24:	cf 93       	push	r28
   17c26:	df 93       	push	r29
   17c28:	cd b7       	in	r28, 0x3d	; 61
   17c2a:	de b7       	in	r29, 0x3e	; 62
  mythread->state = STATE_ACTIVE;
   17c2c:	e0 91 67 0a 	lds	r30, 0x0A67
   17c30:	f0 91 68 0a 	lds	r31, 0x0A68
   17c34:	82 e0       	ldi	r24, 0x02	; 2
   17c36:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   17c38:	0e 94 80 c3 	call	0x18700
   17c3c:	df 91       	pop	r29
   17c3e:	cf 91       	pop	r28
   17c40:	08 95       	ret

00017c42 <radioReceive>:


}





int radioReceive(uint16_t port, uint8_t maxlength, uint8_t *msg)

{
   17c42:	cf 93       	push	r28
   17c44:	df 93       	push	r29
   17c46:	cd b7       	in	r28, 0x3d	; 61
   17c48:	de b7       	in	r29, 0x3e	; 62
   17c4a:	2c 97       	sbiw	r28, 0x0c	; 12
   17c4c:	0f b6       	in	r0, 0x3f	; 63
   17c4e:	f8 94       	cli
   17c50:	de bf       	out	0x3e, r29	; 62
   17c52:	0f be       	out	0x3f, r0	; 63
   17c54:	cd bf       	out	0x3d, r28	; 61
   17c56:	99 87       	std	Y+9, r25	; 0x09
   17c58:	88 87       	std	Y+8, r24	; 0x08
   17c5a:	6a 87       	std	Y+10, r22	; 0x0a
   17c5c:	5c 87       	std	Y+12, r21	; 0x0c
   17c5e:	4b 87       	std	Y+11, r20	; 0x0b


   thread** current_thread;

   _atomic_t currentatomic;


   radiohandletype *radiohandleaddr;


   void (*getaddrfp)(void) = (void (*)(void))REGISTER_RADIO_RECEIVE_EVENT;
   17c60:	84 e6       	ldi	r24, 0x64	; 100
   17c62:	9a ee       	ldi	r25, 0xEA	; 234
   17c64:	9a 83       	std	Y+2, r25	; 0x02
   17c66:	89 83       	std	Y+1, r24	; 0x01

   current_thread = getCurrentThread();
   17c68:	0e 94 af c2 	call	0x1855e
   17c6c:	9f 83       	std	Y+7, r25	; 0x07
   17c6e:	8e 83       	std	Y+6, r24	; 0x06

   radiohandleaddr = getCurrentRadioHandleAddr();
   17c70:	0e 94 92 bc 	call	0x17924
   17c74:	9c 83       	std	Y+4, r25	; 0x04
   17c76:	8b 83       	std	Y+3, r24	; 0x03

   //set up the radiohandleaddr data structures

   radiohandleaddr->port = port;
   17c78:	eb 81       	ldd	r30, Y+3	; 0x03
   17c7a:	fc 81       	ldd	r31, Y+4	; 0x04
   17c7c:	88 85       	ldd	r24, Y+8	; 0x08
   17c7e:	99 85       	ldd	r25, Y+9	; 0x09
   17c80:	91 83       	std	Z+1, r25	; 0x01
   17c82:	80 83       	st	Z, r24
   radiohandleaddr->maxLength = maxlength;
   17c84:	eb 81       	ldd	r30, Y+3	; 0x03
   17c86:	fc 81       	ldd	r31, Y+4	; 0x04
   17c88:	8a 85       	ldd	r24, Y+10	; 0x0a
   17c8a:	82 83       	std	Z+2, r24	; 0x02
   radiohandleaddr->dataReady = &radioReceiveDataReady;
   17c8c:	eb 81       	ldd	r30, Y+3	; 0x03
   17c8e:	fc 81       	ldd	r31, Y+4	; 0x04
   17c90:	89 e6       	ldi	r24, 0x69	; 105
   17c92:	9a e0       	ldi	r25, 0x0A	; 10
   17c94:	94 83       	std	Z+4, r25	; 0x04
   17c96:	83 83       	std	Z+3, r24	; 0x03
   radiohandleaddr->data = msg;
   17c98:	eb 81       	ldd	r30, Y+3	; 0x03
   17c9a:	fc 81       	ldd	r31, Y+4	; 0x04
   17c9c:	8b 85       	ldd	r24, Y+11	; 0x0b
   17c9e:	9c 85       	ldd	r25, Y+12	; 0x0c
   17ca0:	96 83       	std	Z+6, r25	; 0x06
   17ca2:	85 83       	std	Z+5, r24	; 0x05
   radiohandleaddr->packetinfo = radioReceivePacketInfo;
   17ca4:	eb 81       	ldd	r30, Y+3	; 0x03
   17ca6:	fc 81       	ldd	r31, Y+4	; 0x04
   17ca8:	8a e8       	ldi	r24, 0x8A	; 138
   17caa:	9a e0       	ldi	r25, 0x0A	; 10
   17cac:	90 87       	std	Z+8, r25	; 0x08
   17cae:	87 83       	std	Z+7, r24	; 0x07
   radiohandleaddr->handlefunc = wakeupMe;
   17cb0:	eb 81       	ldd	r30, Y+3	; 0x03
   17cb2:	fc 81       	ldd	r31, Y+4	; 0x04
   17cb4:	82 e1       	ldi	r24, 0x12	; 18
   17cb6:	9e eb       	ldi	r25, 0xBE	; 190
   17cb8:	93 87       	std	Z+11, r25	; 0x0b
   17cba:	82 87       	std	Z+10, r24	; 0x0a


   //close the interrupt
	currentatomic = _atomic_start();
   17cbc:	0e 94 11 c2 	call	0x18422
   17cc0:	8d 83       	std	Y+5, r24	; 0x05

   //call the radio handle set to store the data structure into the handle vectors
    getaddrfp();
   17cc2:	e9 81       	ldd	r30, Y+1	; 0x01
   17cc4:	fa 81       	ldd	r31, Y+2	; 0x02
   17cc6:	09 95       	icall


   //set up the current thread into sleep mode
   (*current_thread)->state = STATE_SLEEP;
   17cc8:	ee 81       	ldd	r30, Y+6	; 0x06
   17cca:	ff 81       	ldd	r31, Y+7	; 0x07
   17ccc:	01 90       	ld	r0, Z+
   17cce:	f0 81       	ld	r31, Z
   17cd0:	e0 2d       	mov	r30, r0
   17cd2:	85 e0       	ldi	r24, 0x05	; 5
   17cd4:	82 83       	std	Z+2, r24	; 0x02

   //set up mythread so that later can wake up this thread
   mythread = *current_thread;
   17cd6:	ee 81       	ldd	r30, Y+6	; 0x06
   17cd8:	ff 81       	ldd	r31, Y+7	; 0x07
   17cda:	80 81       	ld	r24, Z
   17cdc:	91 81       	ldd	r25, Z+1	; 0x01
   17cde:	90 93 68 0a 	sts	0x0A68, r25
   17ce2:	80 93 67 0a 	sts	0x0A67, r24


   //open the interrupt
   _atomic_end(currentatomic);
   17ce6:	8d 81       	ldd	r24, Y+5	; 0x05
   17ce8:	0e 94 2b c2 	call	0x18456

    yield();
   17cec:	0e 94 66 c3 	call	0x186cc


   return radioReceiveDataReady;
   17cf0:	80 91 69 0a 	lds	r24, 0x0A69
   17cf4:	99 27       	eor	r25, r25
   17cf6:	2c 96       	adiw	r28, 0x0c	; 12
   17cf8:	0f b6       	in	r0, 0x3f	; 63
   17cfa:	f8 94       	cli
   17cfc:	de bf       	out	0x3e, r29	; 62
   17cfe:	0f be       	out	0x3f, r0	; 63
   17d00:	cd bf       	out	0x3d, r28	; 61
   17d02:	df 91       	pop	r29
   17d04:	cf 91       	pop	r28
   17d06:	08 95       	ret

00017d08 <radioReceiveTimed>:

}

int radioReceiveTimed(uint16_t port, uint8_t maxlength, uint8_t *msg, uint16_t time)
{
   17d08:	cf 93       	push	r28
   17d0a:	df 93       	push	r29
   17d0c:	cd b7       	in	r28, 0x3d	; 61
   17d0e:	de b7       	in	r29, 0x3e	; 62
   17d10:	2e 97       	sbiw	r28, 0x0e	; 14
   17d12:	0f b6       	in	r0, 0x3f	; 63
   17d14:	f8 94       	cli
   17d16:	de bf       	out	0x3e, r29	; 62
   17d18:	0f be       	out	0x3f, r0	; 63
   17d1a:	cd bf       	out	0x3d, r28	; 61
   17d1c:	99 87       	std	Y+9, r25	; 0x09
   17d1e:	88 87       	std	Y+8, r24	; 0x08
   17d20:	6a 87       	std	Y+10, r22	; 0x0a
   17d22:	5c 87       	std	Y+12, r21	; 0x0c
   17d24:	4b 87       	std	Y+11, r20	; 0x0b
   17d26:	3e 87       	std	Y+14, r19	; 0x0e
   17d28:	2d 87       	std	Y+13, r18	; 0x0d
   thread** current_thread;

   _atomic_t currentatomic;


   radiohandletype *radiohandleaddr;
	

   void (*getaddrfp)(void) = (void (*)(void))REGISTER_RADIO_RECEIVE_EVENT;
   17d2a:	84 e6       	ldi	r24, 0x64	; 100
   17d2c:	9a ee       	ldi	r25, 0xEA	; 234
   17d2e:	9a 83       	std	Y+2, r25	; 0x02
   17d30:	89 83       	std	Y+1, r24	; 0x01

   current_thread = getCurrentThread();
   17d32:	0e 94 af c2 	call	0x1855e
   17d36:	9f 83       	std	Y+7, r25	; 0x07
   17d38:	8e 83       	std	Y+6, r24	; 0x06

   radiohandleaddr = getCurrentRadioHandleAddr();
   17d3a:	0e 94 92 bc 	call	0x17924
   17d3e:	9c 83       	std	Y+4, r25	; 0x04
   17d40:	8b 83       	std	Y+3, r24	; 0x03

   //set up the radiohandleaddr data structures

   radiohandleaddr->port = port;
   17d42:	eb 81       	ldd	r30, Y+3	; 0x03
   17d44:	fc 81       	ldd	r31, Y+4	; 0x04
   17d46:	88 85       	ldd	r24, Y+8	; 0x08
   17d48:	99 85       	ldd	r25, Y+9	; 0x09
   17d4a:	91 83       	std	Z+1, r25	; 0x01
   17d4c:	80 83       	st	Z, r24
   radiohandleaddr->maxLength = maxlength;
   17d4e:	eb 81       	ldd	r30, Y+3	; 0x03
   17d50:	fc 81       	ldd	r31, Y+4	; 0x04
   17d52:	8a 85       	ldd	r24, Y+10	; 0x0a
   17d54:	82 83       	std	Z+2, r24	; 0x02
   radiohandleaddr->dataReady = &radioReceiveDataReady;
   17d56:	eb 81       	ldd	r30, Y+3	; 0x03
   17d58:	fc 81       	ldd	r31, Y+4	; 0x04
   17d5a:	89 e6       	ldi	r24, 0x69	; 105
   17d5c:	9a e0       	ldi	r25, 0x0A	; 10
   17d5e:	94 83       	std	Z+4, r25	; 0x04
   17d60:	83 83       	std	Z+3, r24	; 0x03
   radiohandleaddr->data = msg;
   17d62:	eb 81       	ldd	r30, Y+3	; 0x03
   17d64:	fc 81       	ldd	r31, Y+4	; 0x04
   17d66:	8b 85       	ldd	r24, Y+11	; 0x0b
   17d68:	9c 85       	ldd	r25, Y+12	; 0x0c
   17d6a:	96 83       	std	Z+6, r25	; 0x06
   17d6c:	85 83       	std	Z+5, r24	; 0x05
   radiohandleaddr->packetinfo = radioReceivePacketInfo;
   17d6e:	eb 81       	ldd	r30, Y+3	; 0x03
   17d70:	fc 81       	ldd	r31, Y+4	; 0x04
   17d72:	8a e8       	ldi	r24, 0x8A	; 138
   17d74:	9a e0       	ldi	r25, 0x0A	; 10
   17d76:	90 87       	std	Z+8, r25	; 0x08
   17d78:	87 83       	std	Z+7, r24	; 0x07
   radiohandleaddr->handlefunc = wakeupMe;
   17d7a:	eb 81       	ldd	r30, Y+3	; 0x03
   17d7c:	fc 81       	ldd	r31, Y+4	; 0x04
   17d7e:	82 e1       	ldi	r24, 0x12	; 18
   17d80:	9e eb       	ldi	r25, 0xBE	; 190
   17d82:	93 87       	std	Z+11, r25	; 0x0b
   17d84:	82 87       	std	Z+10, r24	; 0x0a


   //close the interrupt
	currentatomic = _atomic_start();
   17d86:	0e 94 11 c2 	call	0x18422
   17d8a:	8d 83       	std	Y+5, r24	; 0x05

   //call the radio handle set to store the data structure into the handle vectors
    getaddrfp();
   17d8c:	e9 81       	ldd	r30, Y+1	; 0x01
   17d8e:	fa 81       	ldd	r31, Y+2	; 0x02
   17d90:	09 95       	icall


   //set up the current thread into sleep mode
   (*current_thread)->state = STATE_SLEEP;
   17d92:	ee 81       	ldd	r30, Y+6	; 0x06
   17d94:	ff 81       	ldd	r31, Y+7	; 0x07
   17d96:	01 90       	ld	r0, Z+
   17d98:	f0 81       	ld	r31, Z
   17d9a:	e0 2d       	mov	r30, r0
   17d9c:	85 e0       	ldi	r24, 0x05	; 5
   17d9e:	82 83       	std	Z+2, r24	; 0x02

   //set up mythread so that later can wake up this thread
   mythread = *current_thread;
   17da0:	ee 81       	ldd	r30, Y+6	; 0x06
   17da2:	ff 81       	ldd	r31, Y+7	; 0x07
   17da4:	80 81       	ld	r24, Z
   17da6:	91 81       	ldd	r25, Z+1	; 0x01
   17da8:	90 93 68 0a 	sts	0x0A68, r25
   17dac:	80 93 67 0a 	sts	0x0A67, r24


   //open the interrupt
   _atomic_end(currentatomic);
   17db0:	8d 81       	ldd	r24, Y+5	; 0x05
   17db2:	0e 94 2b c2 	call	0x18456

   sleepThread(time);
   17db6:	8d 85       	ldd	r24, Y+13	; 0x0d
   17db8:	9e 85       	ldd	r25, Y+14	; 0x0e
   17dba:	0e 94 1b c3 	call	0x18636

   return radioReceiveDataReady;
   17dbe:	80 91 69 0a 	lds	r24, 0x0A69
   17dc2:	99 27       	eor	r25, r25
   17dc4:	2e 96       	adiw	r28, 0x0e	; 14
   17dc6:	0f b6       	in	r0, 0x3f	; 63
   17dc8:	f8 94       	cli
   17dca:	de bf       	out	0x3e, r29	; 62
   17dcc:	0f be       	out	0x3f, r0	; 63
   17dce:	cd bf       	out	0x3d, r28	; 61
   17dd0:	df 91       	pop	r29
   17dd2:	cf 91       	pop	r28
   17dd4:	08 95       	ret

00017dd6 <sendSerialMsg>:

thread* mythreadserial;

void sendSerialMsg()
{
   17dd6:	cf 93       	push	r28
   17dd8:	df 93       	push	r29
   17dda:	cd b7       	in	r28, 0x3d	; 61
   17ddc:	de b7       	in	r29, 0x3e	; 62
   17dde:	22 97       	sbiw	r28, 0x02	; 2
   17de0:	0f b6       	in	r0, 0x3f	; 63
   17de2:	f8 94       	cli
   17de4:	de bf       	out	0x3e, r29	; 62
   17de6:	0f be       	out	0x3f, r0	; 63
   17de8:	cd bf       	out	0x3d, r28	; 61
 void (*serialsendfp)() = (void (*)(void))SERIAL_SEND_FUNCTION;
   17dea:	88 e9       	ldi	r24, 0x98	; 152
   17dec:	9a ee       	ldi	r25, 0xEA	; 234
   17dee:	9a 83       	std	Y+2, r25	; 0x02
   17df0:	89 83       	std	Y+1, r24	; 0x01
 serialsendfp();
   17df2:	e9 81       	ldd	r30, Y+1	; 0x01
   17df4:	fa 81       	ldd	r31, Y+2	; 0x02
   17df6:	09 95       	icall
   17df8:	22 96       	adiw	r28, 0x02	; 2
   17dfa:	0f b6       	in	r0, 0x3f	; 63
   17dfc:	f8 94       	cli
   17dfe:	de bf       	out	0x3e, r29	; 62
   17e00:	0f be       	out	0x3f, r0	; 63
   17e02:	cd bf       	out	0x3d, r28	; 61
   17e04:	df 91       	pop	r29
   17e06:	cf 91       	pop	r28
   17e08:	08 95       	ret

00017e0a <serialSend_string>:
}



//This function sends out a string

void serialSend_string(uint8_t *msg)
{
   17e0a:	cf 93       	push	r28
   17e0c:	df 93       	push	r29
   17e0e:	cd b7       	in	r28, 0x3d	; 61
   17e10:	de b7       	in	r29, 0x3e	; 62
   17e12:	23 97       	sbiw	r28, 0x03	; 3
   17e14:	0f b6       	in	r0, 0x3f	; 63
   17e16:	f8 94       	cli
   17e18:	de bf       	out	0x3e, r29	; 62
   17e1a:	0f be       	out	0x3f, r0	; 63
   17e1c:	cd bf       	out	0x3d, r28	; 61
   17e1e:	9b 83       	std	Y+3, r25	; 0x03
   17e20:	8a 83       	std	Y+2, r24	; 0x02

    uint8_t temp = (uint8_t)String_length((char *)msg);
   17e22:	8a 81       	ldd	r24, Y+2	; 0x02
   17e24:	9b 81       	ldd	r25, Y+3	; 0x03
   17e26:	0e 94 66 c0 	call	0x180cc
   17e2a:	89 83       	std	Y+1, r24	; 0x01
	return serialSend(temp, msg);
   17e2c:	8a 81       	ldd	r24, Y+2	; 0x02
   17e2e:	9b 81       	ldd	r25, Y+3	; 0x03
   17e30:	bc 01       	movw	r22, r24
   17e32:	89 81       	ldd	r24, Y+1	; 0x01
   17e34:	0e 94 9c bf 	call	0x17f38
   17e38:	23 96       	adiw	r28, 0x03	; 3
   17e3a:	0f b6       	in	r0, 0x3f	; 63
   17e3c:	f8 94       	cli
   17e3e:	de bf       	out	0x3e, r29	; 62
   17e40:	0f be       	out	0x3f, r0	; 63
   17e42:	cd bf       	out	0x3d, r28	; 61
   17e44:	df 91       	pop	r29
   17e46:	cf 91       	pop	r28
   17e48:	08 95       	ret

00017e4a <serialSend_uint16>:

}


void serialSend_uint16(uint16_t value)
{
   17e4a:	cf 93       	push	r28
   17e4c:	df 93       	push	r29
   17e4e:	cd b7       	in	r28, 0x3d	; 61
   17e50:	de b7       	in	r29, 0x3e	; 62
   17e52:	24 97       	sbiw	r28, 0x04	; 4
   17e54:	0f b6       	in	r0, 0x3f	; 63
   17e56:	f8 94       	cli
   17e58:	de bf       	out	0x3e, r29	; 62
   17e5a:	0f be       	out	0x3f, r0	; 63
   17e5c:	cd bf       	out	0x3d, r28	; 61
   17e5e:	9c 83       	std	Y+4, r25	; 0x04
   17e60:	8b 83       	std	Y+3, r24	; 0x03
  uint8_t temp1,temp2;
  temp1 = (uint8_t) (value >> 8);
   17e62:	8b 81       	ldd	r24, Y+3	; 0x03
   17e64:	9c 81       	ldd	r25, Y+4	; 0x04
   17e66:	89 2f       	mov	r24, r25
   17e68:	99 27       	eor	r25, r25
   17e6a:	8a 83       	std	Y+2, r24	; 0x02
  temp2 = (uint8_t) (value & 0x00ff);
   17e6c:	8b 81       	ldd	r24, Y+3	; 0x03
   17e6e:	89 83       	std	Y+1, r24	; 0x01

  serial_buffer[0] = temp1;
   17e70:	8a 81       	ldd	r24, Y+2	; 0x02
   17e72:	80 93 90 0a 	sts	0x0A90, r24
  serial_buffer[1] = temp2;
   17e76:	89 81       	ldd	r24, Y+1	; 0x01
   17e78:	80 93 91 0a 	sts	0x0A91, r24
  serial_buffer[2] = serial_buffer[3] = 0xee;
   17e7c:	8e ee       	ldi	r24, 0xEE	; 238
   17e7e:	80 93 93 0a 	sts	0x0A93, r24
   17e82:	80 91 93 0a 	lds	r24, 0x0A93
   17e86:	80 93 92 0a 	sts	0x0A92, r24

  return serialSend(16, serial_buffer);
   17e8a:	80 e9       	ldi	r24, 0x90	; 144
   17e8c:	9a e0       	ldi	r25, 0x0A	; 10
   17e8e:	bc 01       	movw	r22, r24
   17e90:	80 e1       	ldi	r24, 0x10	; 16
   17e92:	0e 94 9c bf 	call	0x17f38
   17e96:	24 96       	adiw	r28, 0x04	; 4
   17e98:	0f b6       	in	r0, 0x3f	; 63
   17e9a:	f8 94       	cli
   17e9c:	de bf       	out	0x3e, r29	; 62
   17e9e:	0f be       	out	0x3f, r0	; 63
   17ea0:	cd bf       	out	0x3d, r28	; 61
   17ea2:	df 91       	pop	r29
   17ea4:	cf 91       	pop	r28
   17ea6:	08 95       	ret

00017ea8 <getCurrentSerialHandleAddr>:

}




serialhandletype *getCurrentSerialHandleAddr()
{
   17ea8:	cf 93       	push	r28
   17eaa:	df 93       	push	r29
   17eac:	cd b7       	in	r28, 0x3d	; 61
   17eae:	de b7       	in	r29, 0x3e	; 62
   17eb0:	24 97       	sbiw	r28, 0x04	; 4
   17eb2:	0f b6       	in	r0, 0x3f	; 63
   17eb4:	f8 94       	cli
   17eb6:	de bf       	out	0x3e, r29	; 62
   17eb8:	0f be       	out	0x3f, r0	; 63
   17eba:	cd bf       	out	0x3d, r28	; 61
   serialhandletype *currentserialhandle;

   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_RECEIVE_HANDLE;
   17ebc:	8c e9       	ldi	r24, 0x9C	; 156
   17ebe:	9a ee       	ldi	r25, 0xEA	; 234
   17ec0:	9a 83       	std	Y+2, r25	; 0x02
   17ec2:	89 83       	std	Y+1, r24	; 0x01

   asm volatile("push r20" "\n\t"
   17ec4:	4f 93       	push	r20
   17ec6:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   17ec8:	e9 81       	ldd	r30, Y+1	; 0x01
   17eca:	fa 81       	ldd	r31, Y+2	; 0x02
   17ecc:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17ece:	84 2f       	mov	r24, r20
   17ed0:	95 2f       	mov	r25, r21
   17ed2:	9c 83       	std	Y+4, r25	; 0x04
   17ed4:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentserialhandle)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17ed6:	5f 91       	pop	r21
   17ed8:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currentserialhandle;
   17eda:	8b 81       	ldd	r24, Y+3	; 0x03
   17edc:	9c 81       	ldd	r25, Y+4	; 0x04
   17ede:	24 96       	adiw	r28, 0x04	; 4
   17ee0:	0f b6       	in	r0, 0x3f	; 63
   17ee2:	f8 94       	cli
   17ee4:	de bf       	out	0x3e, r29	; 62
   17ee6:	0f be       	out	0x3f, r0	; 63
   17ee8:	cd bf       	out	0x3d, r28	; 61
   17eea:	df 91       	pop	r29
   17eec:	cf 91       	pop	r28
   17eee:	08 95       	ret

00017ef0 <getCurrentSerialInfo>:
}






serialinfotype* getCurrentSerialInfo()
{
   17ef0:	cf 93       	push	r28
   17ef2:	df 93       	push	r29
   17ef4:	cd b7       	in	r28, 0x3d	; 61
   17ef6:	de b7       	in	r29, 0x3e	; 62
   17ef8:	24 97       	sbiw	r28, 0x04	; 4
   17efa:	0f b6       	in	r0, 0x3f	; 63
   17efc:	f8 94       	cli
   17efe:	de bf       	out	0x3e, r29	; 62
   17f00:	0f be       	out	0x3f, r0	; 63
   17f02:	cd bf       	out	0x3d, r28	; 61
   serialinfotype *currentserialinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_SEND_STRUCTURE_ADDRESS;
   17f04:	84 e9       	ldi	r24, 0x94	; 148
   17f06:	9a ee       	ldi	r25, 0xEA	; 234
   17f08:	9a 83       	std	Y+2, r25	; 0x02
   17f0a:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   17f0c:	4f 93       	push	r20
   17f0e:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
   17f10:	e9 81       	ldd	r30, Y+1	; 0x01
   17f12:	fa 81       	ldd	r31, Y+2	; 0x02
   17f14:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17f16:	84 2f       	mov	r24, r20
   17f18:	95 2f       	mov	r25, r21
   17f1a:	9c 83       	std	Y+4, r25	; 0x04
   17f1c:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentserialinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17f1e:	5f 91       	pop	r21
   17f20:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currentserialinfo;
   17f22:	8b 81       	ldd	r24, Y+3	; 0x03
   17f24:	9c 81       	ldd	r25, Y+4	; 0x04
   17f26:	24 96       	adiw	r28, 0x04	; 4
   17f28:	0f b6       	in	r0, 0x3f	; 63
   17f2a:	f8 94       	cli
   17f2c:	de bf       	out	0x3e, r29	; 62
   17f2e:	0f be       	out	0x3f, r0	; 63
   17f30:	cd bf       	out	0x3d, r28	; 61
   17f32:	df 91       	pop	r29
   17f34:	cf 91       	pop	r28
   17f36:	08 95       	ret

00017f38 <serialSend>:
}




void serialSend(uint8_t length, uint8_t *msg)
{
   17f38:	cf 93       	push	r28
   17f3a:	df 93       	push	r29
   17f3c:	cd b7       	in	r28, 0x3d	; 61
   17f3e:	de b7       	in	r29, 0x3e	; 62
   17f40:	29 97       	sbiw	r28, 0x09	; 9
   17f42:	0f b6       	in	r0, 0x3f	; 63
   17f44:	f8 94       	cli
   17f46:	de bf       	out	0x3e, r29	; 62
   17f48:	0f be       	out	0x3f, r0	; 63
   17f4a:	cd bf       	out	0x3d, r28	; 61
   17f4c:	8f 83       	std	Y+7, r24	; 0x07
   17f4e:	79 87       	std	Y+9, r23	; 0x09
   17f50:	68 87       	std	Y+8, r22	; 0x08


   mutex* mserialsend;
   thread** current_thread;
   serialinfotype *serialinfoaddr;



   mserialsend = getSerialMutexAddress();
   17f52:	0e 94 d9 bb 	call	0x177b2
   17f56:	9e 83       	std	Y+6, r25	; 0x06
   17f58:	8d 83       	std	Y+5, r24	; 0x05
   current_thread = getCurrentThread();
   17f5a:	0e 94 af c2 	call	0x1855e
   17f5e:	9c 83       	std	Y+4, r25	; 0x04
   17f60:	8b 83       	std	Y+3, r24	; 0x03
   serialinfoaddr = getCurrentSerialInfo();
   17f62:	0e 94 78 bf 	call	0x17ef0
   17f66:	9a 83       	std	Y+2, r25	; 0x02
   17f68:	89 83       	std	Y+1, r24	; 0x01

   Mutex_lock(mserialsend);
   17f6a:	8d 81       	ldd	r24, Y+5	; 0x05
   17f6c:	9e 81       	ldd	r25, Y+6	; 0x06
   17f6e:	0e 94 0c bb 	call	0x17618

   serialinfoaddr->socket_msg_len = length;
   17f72:	e9 81       	ldd	r30, Y+1	; 0x01
   17f74:	fa 81       	ldd	r31, Y+2	; 0x02
   17f76:	8f 81       	ldd	r24, Y+7	; 0x07
   17f78:	80 83       	st	Z, r24
   serialinfoaddr->socket_msg = msg;
   17f7a:	e9 81       	ldd	r30, Y+1	; 0x01
   17f7c:	fa 81       	ldd	r31, Y+2	; 0x02
   17f7e:	88 85       	ldd	r24, Y+8	; 0x08
   17f80:	99 85       	ldd	r25, Y+9	; 0x09
   17f82:	92 83       	std	Z+2, r25	; 0x02
   17f84:	81 83       	std	Z+1, r24	; 0x01


   sendSerialMsg();
   17f86:	0e 94 eb be 	call	0x17dd6

   sleepThread(30);
   17f8a:	8e e1       	ldi	r24, 0x1E	; 30
   17f8c:	90 e0       	ldi	r25, 0x00	; 0
   17f8e:	0e 94 1b c3 	call	0x18636


   Mutex_unlock(mserialsend);
   17f92:	8d 81       	ldd	r24, Y+5	; 0x05
   17f94:	9e 81       	ldd	r25, Y+6	; 0x06
   17f96:	0e 94 5b bb 	call	0x176b6
   17f9a:	29 96       	adiw	r28, 0x09	; 9
   17f9c:	0f b6       	in	r0, 0x3f	; 63
   17f9e:	f8 94       	cli
   17fa0:	de bf       	out	0x3e, r29	; 62
   17fa2:	0f be       	out	0x3f, r0	; 63
   17fa4:	cd bf       	out	0x3d, r28	; 61
   17fa6:	df 91       	pop	r29
   17fa8:	cf 91       	pop	r28
   17faa:	08 95       	ret

00017fac <wakeupMeSerial>:

   return;
}



//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
   17fac:	cf 93       	push	r28
   17fae:	df 93       	push	r29
   17fb0:	cd b7       	in	r28, 0x3d	; 61
   17fb2:	de b7       	in	r29, 0x3e	; 62
  mythreadserial->state = STATE_ACTIVE;
   17fb4:	e0 91 8e 0a 	lds	r30, 0x0A8E
   17fb8:	f0 91 8f 0a 	lds	r31, 0x0A8F
   17fbc:	82 e0       	ldi	r24, 0x02	; 2
   17fbe:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   17fc0:	0e 94 80 c3 	call	0x18700
   17fc4:	df 91       	pop	r29
   17fc6:	cf 91       	pop	r28
   17fc8:	08 95       	ret

00017fca <serialReceive>:


}



//In serial receive, the port is above 0, which means that such messages are delivered for the user applications.


void serialReceive(uint16_t port, uint8_t maxlength, uint8_t *msg)

{
   17fca:	cf 93       	push	r28
   17fcc:	df 93       	push	r29
   17fce:	cd b7       	in	r28, 0x3d	; 61
   17fd0:	de b7       	in	r29, 0x3e	; 62
   17fd2:	2c 97       	sbiw	r28, 0x0c	; 12
   17fd4:	0f b6       	in	r0, 0x3f	; 63
   17fd6:	f8 94       	cli
   17fd8:	de bf       	out	0x3e, r29	; 62
   17fda:	0f be       	out	0x3f, r0	; 63
   17fdc:	cd bf       	out	0x3d, r28	; 61
   17fde:	99 87       	std	Y+9, r25	; 0x09
   17fe0:	88 87       	std	Y+8, r24	; 0x08
   17fe2:	6a 87       	std	Y+10, r22	; 0x0a
   17fe4:	5c 87       	std	Y+12, r21	; 0x0c
   17fe6:	4b 87       	std	Y+11, r20	; 0x0b


   thread** current_thread;

   _atomic_t currentatomic;

   serialhandletype *serialhandleaddr;

   void (*getaddrfp)(void) = (void (*)(void))REGISTER_SERIAL_RECEIVE_EVENT;
   17fe8:	80 ea       	ldi	r24, 0xA0	; 160
   17fea:	9a ee       	ldi	r25, 0xEA	; 234
   17fec:	9a 83       	std	Y+2, r25	; 0x02
   17fee:	89 83       	std	Y+1, r24	; 0x01

   current_thread = getCurrentThread();
   17ff0:	0e 94 af c2 	call	0x1855e
   17ff4:	9f 83       	std	Y+7, r25	; 0x07
   17ff6:	8e 83       	std	Y+6, r24	; 0x06

   serialhandleaddr = getCurrentSerialHandleAddr();
   17ff8:	0e 94 54 bf 	call	0x17ea8
   17ffc:	9c 83       	std	Y+4, r25	; 0x04
   17ffe:	8b 83       	std	Y+3, r24	; 0x03

   //set up the radiohandleaddr data structures

   serialhandleaddr->port = port;
   18000:	eb 81       	ldd	r30, Y+3	; 0x03
   18002:	fc 81       	ldd	r31, Y+4	; 0x04
   18004:	88 85       	ldd	r24, Y+8	; 0x08
   18006:	99 85       	ldd	r25, Y+9	; 0x09
   18008:	91 83       	std	Z+1, r25	; 0x01
   1800a:	80 83       	st	Z, r24
   serialhandleaddr->maxLength = maxlength;
   1800c:	eb 81       	ldd	r30, Y+3	; 0x03
   1800e:	fc 81       	ldd	r31, Y+4	; 0x04
   18010:	8a 85       	ldd	r24, Y+10	; 0x0a
   18012:	82 83       	std	Z+2, r24	; 0x02
   serialhandleaddr->data = msg;
   18014:	eb 81       	ldd	r30, Y+3	; 0x03
   18016:	fc 81       	ldd	r31, Y+4	; 0x04
   18018:	8b 85       	ldd	r24, Y+11	; 0x0b
   1801a:	9c 85       	ldd	r25, Y+12	; 0x0c
   1801c:	94 83       	std	Z+4, r25	; 0x04
   1801e:	83 83       	std	Z+3, r24	; 0x03
   serialhandleaddr->handlefunc = wakeupMeSerial;
   18020:	eb 81       	ldd	r30, Y+3	; 0x03
   18022:	fc 81       	ldd	r31, Y+4	; 0x04
   18024:	86 ed       	ldi	r24, 0xD6	; 214
   18026:	9f eb       	ldi	r25, 0xBF	; 191
   18028:	97 83       	std	Z+7, r25	; 0x07
   1802a:	86 83       	std	Z+6, r24	; 0x06


   //close the interrupt
	currentatomic = _atomic_start();
   1802c:	0e 94 11 c2 	call	0x18422
   18030:	8d 83       	std	Y+5, r24	; 0x05

   //call the radio handle set to store the data structure into the handle vectors
    getaddrfp();
   18032:	e9 81       	ldd	r30, Y+1	; 0x01
   18034:	fa 81       	ldd	r31, Y+2	; 0x02
   18036:	09 95       	icall


   //set up the current thread into sleep mode
   (*current_thread)->state = STATE_SLEEP;
   18038:	ee 81       	ldd	r30, Y+6	; 0x06
   1803a:	ff 81       	ldd	r31, Y+7	; 0x07
   1803c:	01 90       	ld	r0, Z+
   1803e:	f0 81       	ld	r31, Z
   18040:	e0 2d       	mov	r30, r0
   18042:	85 e0       	ldi	r24, 0x05	; 5
   18044:	82 83       	std	Z+2, r24	; 0x02

   //set up mythread so that later can wake up this thread
   mythreadserial = *current_thread;
   18046:	ee 81       	ldd	r30, Y+6	; 0x06
   18048:	ff 81       	ldd	r31, Y+7	; 0x07
   1804a:	80 81       	ld	r24, Z
   1804c:	91 81       	ldd	r25, Z+1	; 0x01
   1804e:	90 93 8f 0a 	sts	0x0A8F, r25
   18052:	80 93 8e 0a 	sts	0x0A8E, r24


   //open the interrupt
   _atomic_end(currentatomic);
   18056:	8d 81       	ldd	r24, Y+5	; 0x05
   18058:	0e 94 2b c2 	call	0x18456

    yield();
   1805c:	0e 94 66 c3 	call	0x186cc
   18060:	2c 96       	adiw	r28, 0x0c	; 12
   18062:	0f b6       	in	r0, 0x3f	; 63
   18064:	f8 94       	cli
   18066:	de bf       	out	0x3e, r29	; 62
   18068:	0f be       	out	0x3f, r0	; 63
   1806a:	cd bf       	out	0x3d, r28	; 61
   1806c:	df 91       	pop	r29
   1806e:	cf 91       	pop	r28
   18070:	08 95       	ret

00018072 <hex2value>:



uint16_t hex2value(uint8_t hex)
{
   18072:	cf 93       	push	r28
   18074:	df 93       	push	r29
   18076:	cd b7       	in	r28, 0x3d	; 61
   18078:	de b7       	in	r29, 0x3e	; 62
   1807a:	24 97       	sbiw	r28, 0x04	; 4
   1807c:	0f b6       	in	r0, 0x3f	; 63
   1807e:	f8 94       	cli
   18080:	de bf       	out	0x3e, r29	; 62
   18082:	0f be       	out	0x3f, r0	; 63
   18084:	cd bf       	out	0x3d, r28	; 61
   18086:	8c 83       	std	Y+4, r24	; 0x04
  char a = (char)hex;
   18088:	8c 81       	ldd	r24, Y+4	; 0x04
   1808a:	8b 83       	std	Y+3, r24	; 0x03
  uint16_t high;

  if ((a>='0')&&(a<='9'))
   1808c:	8b 81       	ldd	r24, Y+3	; 0x03
   1808e:	80 33       	cpi	r24, 0x30	; 48
   18090:	5c f0       	brlt	.+22     	; 0x180a8
   18092:	8b 81       	ldd	r24, Y+3	; 0x03
   18094:	8a 33       	cpi	r24, 0x3A	; 58
   18096:	44 f4       	brge	.+16     	; 0x180a8
	     high = a-'0';
   18098:	8b 81       	ldd	r24, Y+3	; 0x03
   1809a:	99 27       	eor	r25, r25
   1809c:	87 fd       	sbrc	r24, 7
   1809e:	90 95       	com	r25
   180a0:	c0 97       	sbiw	r24, 0x30	; 48
   180a2:	9a 83       	std	Y+2, r25	; 0x02
   180a4:	89 83       	std	Y+1, r24	; 0x01
   180a6:	07 c0       	rjmp	.+14     	; 0x180b6
  else
		 high = a-'A'+ 10;
   180a8:	8b 81       	ldd	r24, Y+3	; 0x03
   180aa:	99 27       	eor	r25, r25
   180ac:	87 fd       	sbrc	r24, 7
   180ae:	90 95       	com	r25
   180b0:	c7 97       	sbiw	r24, 0x37	; 55
   180b2:	9a 83       	std	Y+2, r25	; 0x02
   180b4:	89 83       	std	Y+1, r24	; 0x01
  return high;
   180b6:	89 81       	ldd	r24, Y+1	; 0x01
   180b8:	9a 81       	ldd	r25, Y+2	; 0x02
   180ba:	24 96       	adiw	r28, 0x04	; 4
   180bc:	0f b6       	in	r0, 0x3f	; 63
   180be:	f8 94       	cli
   180c0:	de bf       	out	0x3e, r29	; 62
   180c2:	0f be       	out	0x3f, r0	; 63
   180c4:	cd bf       	out	0x3d, r28	; 61
   180c6:	df 91       	pop	r29
   180c8:	cf 91       	pop	r28
   180ca:	08 95       	ret

000180cc <String_length>:

}


int String_length(char* s) {
   180cc:	cf 93       	push	r28
   180ce:	df 93       	push	r29
   180d0:	cd b7       	in	r28, 0x3d	; 61
   180d2:	de b7       	in	r29, 0x3e	; 62
   180d4:	24 97       	sbiw	r28, 0x04	; 4
   180d6:	0f b6       	in	r0, 0x3f	; 63
   180d8:	f8 94       	cli
   180da:	de bf       	out	0x3e, r29	; 62
   180dc:	0f be       	out	0x3f, r0	; 63
   180de:	cd bf       	out	0x3d, r28	; 61
   180e0:	9c 83       	std	Y+4, r25	; 0x04
   180e2:	8b 83       	std	Y+3, r24	; 0x03
	int count=0;
   180e4:	1a 82       	std	Y+2, r1	; 0x02
   180e6:	19 82       	std	Y+1, r1	; 0x01
	while(s[count] != '\0')
   180e8:	05 c0       	rjmp	.+10     	; 0x180f4
		count++;
   180ea:	89 81       	ldd	r24, Y+1	; 0x01
   180ec:	9a 81       	ldd	r25, Y+2	; 0x02
   180ee:	01 96       	adiw	r24, 0x01	; 1
   180f0:	9a 83       	std	Y+2, r25	; 0x02
   180f2:	89 83       	std	Y+1, r24	; 0x01
   180f4:	89 81       	ldd	r24, Y+1	; 0x01
   180f6:	9a 81       	ldd	r25, Y+2	; 0x02
   180f8:	9c 01       	movw	r18, r24
   180fa:	8b 81       	ldd	r24, Y+3	; 0x03
   180fc:	9c 81       	ldd	r25, Y+4	; 0x04
   180fe:	f9 01       	movw	r30, r18
   18100:	e8 0f       	add	r30, r24
   18102:	f9 1f       	adc	r31, r25
   18104:	80 81       	ld	r24, Z
   18106:	88 23       	and	r24, r24
   18108:	81 f7       	brne	.-32     	; 0x180ea
	return count;
   1810a:	89 81       	ldd	r24, Y+1	; 0x01
   1810c:	9a 81       	ldd	r25, Y+2	; 0x02
   1810e:	24 96       	adiw	r28, 0x04	; 4
   18110:	0f b6       	in	r0, 0x3f	; 63
   18112:	f8 94       	cli
   18114:	de bf       	out	0x3e, r29	; 62
   18116:	0f be       	out	0x3f, r0	; 63
   18118:	cd bf       	out	0x3d, r28	; 61
   1811a:	df 91       	pop	r29
   1811c:	cf 91       	pop	r28
   1811e:	08 95       	ret

00018120 <mystrncpy>:
}




void mystrncpy(char *dest, const char *src, uint16_t n)
{
   18120:	cf 93       	push	r28
   18122:	df 93       	push	r29
   18124:	cd b7       	in	r28, 0x3d	; 61
   18126:	de b7       	in	r29, 0x3e	; 62
   18128:	28 97       	sbiw	r28, 0x08	; 8
   1812a:	0f b6       	in	r0, 0x3f	; 63
   1812c:	f8 94       	cli
   1812e:	de bf       	out	0x3e, r29	; 62
   18130:	0f be       	out	0x3f, r0	; 63
   18132:	cd bf       	out	0x3d, r28	; 61
   18134:	9c 83       	std	Y+4, r25	; 0x04
   18136:	8b 83       	std	Y+3, r24	; 0x03
   18138:	7e 83       	std	Y+6, r23	; 0x06
   1813a:	6d 83       	std	Y+5, r22	; 0x05
   1813c:	58 87       	std	Y+8, r21	; 0x08
   1813e:	4f 83       	std	Y+7, r20	; 0x07
	uint16_t i;
	for (i=0;i<n;i++)
   18140:	1a 82       	std	Y+2, r1	; 0x02
   18142:	19 82       	std	Y+1, r1	; 0x01
   18144:	15 c0       	rjmp	.+42     	; 0x18170
		dest[i] = src[i];
   18146:	29 81       	ldd	r18, Y+1	; 0x01
   18148:	3a 81       	ldd	r19, Y+2	; 0x02
   1814a:	8b 81       	ldd	r24, Y+3	; 0x03
   1814c:	9c 81       	ldd	r25, Y+4	; 0x04
   1814e:	d9 01       	movw	r26, r18
   18150:	a8 0f       	add	r26, r24
   18152:	b9 1f       	adc	r27, r25
   18154:	29 81       	ldd	r18, Y+1	; 0x01
   18156:	3a 81       	ldd	r19, Y+2	; 0x02
   18158:	8d 81       	ldd	r24, Y+5	; 0x05
   1815a:	9e 81       	ldd	r25, Y+6	; 0x06
   1815c:	f9 01       	movw	r30, r18
   1815e:	e8 0f       	add	r30, r24
   18160:	f9 1f       	adc	r31, r25
   18162:	80 81       	ld	r24, Z
   18164:	8c 93       	st	X, r24
   18166:	89 81       	ldd	r24, Y+1	; 0x01
   18168:	9a 81       	ldd	r25, Y+2	; 0x02
   1816a:	01 96       	adiw	r24, 0x01	; 1
   1816c:	9a 83       	std	Y+2, r25	; 0x02
   1816e:	89 83       	std	Y+1, r24	; 0x01
   18170:	29 81       	ldd	r18, Y+1	; 0x01
   18172:	3a 81       	ldd	r19, Y+2	; 0x02
   18174:	8f 81       	ldd	r24, Y+7	; 0x07
   18176:	98 85       	ldd	r25, Y+8	; 0x08
   18178:	28 17       	cp	r18, r24
   1817a:	39 07       	cpc	r19, r25
   1817c:	20 f3       	brcs	.-56     	; 0x18146
   1817e:	28 96       	adiw	r28, 0x08	; 8
   18180:	0f b6       	in	r0, 0x3f	; 63
   18182:	f8 94       	cli
   18184:	de bf       	out	0x3e, r29	; 62
   18186:	0f be       	out	0x3f, r0	; 63
   18188:	cd bf       	out	0x3d, r28	; 61
   1818a:	df 91       	pop	r29
   1818c:	cf 91       	pop	r28
   1818e:	08 95       	ret

00018190 <mystrcpy>:
}


void mystrcpy(char *dest, const char *src)
{
   18190:	cf 93       	push	r28
   18192:	df 93       	push	r29
   18194:	cd b7       	in	r28, 0x3d	; 61
   18196:	de b7       	in	r29, 0x3e	; 62
   18198:	26 97       	sbiw	r28, 0x06	; 6
   1819a:	0f b6       	in	r0, 0x3f	; 63
   1819c:	f8 94       	cli
   1819e:	de bf       	out	0x3e, r29	; 62
   181a0:	0f be       	out	0x3f, r0	; 63
   181a2:	cd bf       	out	0x3d, r28	; 61
   181a4:	9c 83       	std	Y+4, r25	; 0x04
   181a6:	8b 83       	std	Y+3, r24	; 0x03
   181a8:	7e 83       	std	Y+6, r23	; 0x06
   181aa:	6d 83       	std	Y+5, r22	; 0x05
	int i;
	i = 0;
   181ac:	1a 82       	std	Y+2, r1	; 0x02
   181ae:	19 82       	std	Y+1, r1	; 0x01
	while (src[i]!='\0')
   181b0:	17 c0       	rjmp	.+46     	; 0x181e0
	{ dest[i] = src[i];
   181b2:	89 81       	ldd	r24, Y+1	; 0x01
   181b4:	9a 81       	ldd	r25, Y+2	; 0x02
   181b6:	9c 01       	movw	r18, r24
   181b8:	8b 81       	ldd	r24, Y+3	; 0x03
   181ba:	9c 81       	ldd	r25, Y+4	; 0x04
   181bc:	d9 01       	movw	r26, r18
   181be:	a8 0f       	add	r26, r24
   181c0:	b9 1f       	adc	r27, r25
   181c2:	89 81       	ldd	r24, Y+1	; 0x01
   181c4:	9a 81       	ldd	r25, Y+2	; 0x02
   181c6:	9c 01       	movw	r18, r24
   181c8:	8d 81       	ldd	r24, Y+5	; 0x05
   181ca:	9e 81       	ldd	r25, Y+6	; 0x06
   181cc:	f9 01       	movw	r30, r18
   181ce:	e8 0f       	add	r30, r24
   181d0:	f9 1f       	adc	r31, r25
   181d2:	80 81       	ld	r24, Z
   181d4:	8c 93       	st	X, r24
	i++;
   181d6:	89 81       	ldd	r24, Y+1	; 0x01
   181d8:	9a 81       	ldd	r25, Y+2	; 0x02
   181da:	01 96       	adiw	r24, 0x01	; 1
   181dc:	9a 83       	std	Y+2, r25	; 0x02
   181de:	89 83       	std	Y+1, r24	; 0x01
   181e0:	89 81       	ldd	r24, Y+1	; 0x01
   181e2:	9a 81       	ldd	r25, Y+2	; 0x02
   181e4:	9c 01       	movw	r18, r24
   181e6:	8d 81       	ldd	r24, Y+5	; 0x05
   181e8:	9e 81       	ldd	r25, Y+6	; 0x06
   181ea:	f9 01       	movw	r30, r18
   181ec:	e8 0f       	add	r30, r24
   181ee:	f9 1f       	adc	r31, r25
   181f0:	80 81       	ld	r24, Z
   181f2:	88 23       	and	r24, r24
   181f4:	f1 f6       	brne	.-68     	; 0x181b2
	}
	dest[i] = '\0';
   181f6:	89 81       	ldd	r24, Y+1	; 0x01
   181f8:	9a 81       	ldd	r25, Y+2	; 0x02
   181fa:	9c 01       	movw	r18, r24
   181fc:	8b 81       	ldd	r24, Y+3	; 0x03
   181fe:	9c 81       	ldd	r25, Y+4	; 0x04
   18200:	f9 01       	movw	r30, r18
   18202:	e8 0f       	add	r30, r24
   18204:	f9 1f       	adc	r31, r25
   18206:	10 82       	st	Z, r1
   18208:	26 96       	adiw	r28, 0x06	; 6
   1820a:	0f b6       	in	r0, 0x3f	; 63
   1820c:	f8 94       	cli
   1820e:	de bf       	out	0x3e, r29	; 62
   18210:	0f be       	out	0x3f, r0	; 63
   18212:	cd bf       	out	0x3d, r28	; 61
   18214:	df 91       	pop	r29
   18216:	cf 91       	pop	r28
   18218:	08 95       	ret

0001821a <dec2char>:
}


char dec2char(uint8_t value) {
   1821a:	cf 93       	push	r28
   1821c:	df 93       	push	r29
   1821e:	cd b7       	in	r28, 0x3d	; 61
   18220:	de b7       	in	r29, 0x3e	; 62
   18222:	23 97       	sbiw	r28, 0x03	; 3
   18224:	0f b6       	in	r0, 0x3f	; 63
   18226:	f8 94       	cli
   18228:	de bf       	out	0x3e, r29	; 62
   1822a:	0f be       	out	0x3f, r0	; 63
   1822c:	cd bf       	out	0x3d, r28	; 61
   1822e:	89 83       	std	Y+1, r24	; 0x01

	if (/*value >= 0) &&*/(value <=9))
   18230:	89 81       	ldd	r24, Y+1	; 0x01
   18232:	8a 30       	cpi	r24, 0x0A	; 10
   18234:	48 f4       	brcc	.+18     	; 0x18248
		return (char) (value + 0x30);
   18236:	89 81       	ldd	r24, Y+1	; 0x01
   18238:	80 5d       	subi	r24, 0xD0	; 208
   1823a:	28 2f       	mov	r18, r24
   1823c:	33 27       	eor	r19, r19
   1823e:	27 fd       	sbrc	r18, 7
   18240:	30 95       	com	r19
   18242:	3b 83       	std	Y+3, r19	; 0x03
   18244:	2a 83       	std	Y+2, r18	; 0x02
   18246:	02 c0       	rjmp	.+4      	; 0x1824c
	else
		return 0;
   18248:	1b 82       	std	Y+3, r1	; 0x03
   1824a:	1a 82       	std	Y+2, r1	; 0x02
   1824c:	8a 81       	ldd	r24, Y+2	; 0x02
   1824e:	9b 81       	ldd	r25, Y+3	; 0x03
   18250:	23 96       	adiw	r28, 0x03	; 3
   18252:	0f b6       	in	r0, 0x3f	; 63
   18254:	f8 94       	cli
   18256:	de bf       	out	0x3e, r29	; 62
   18258:	0f be       	out	0x3f, r0	; 63
   1825a:	cd bf       	out	0x3d, r28	; 61
   1825c:	df 91       	pop	r29
   1825e:	cf 91       	pop	r28
   18260:	08 95       	ret

00018262 <String_intToString>:
}


char *String_intToString(int num)
{
   18262:	0f 93       	push	r16
   18264:	1f 93       	push	r17
   18266:	cf 93       	push	r28
   18268:	df 93       	push	r29
   1826a:	cd b7       	in	r28, 0x3d	; 61
   1826c:	de b7       	in	r29, 0x3e	; 62
   1826e:	2a 97       	sbiw	r28, 0x0a	; 10
   18270:	0f b6       	in	r0, 0x3f	; 63
   18272:	f8 94       	cli
   18274:	de bf       	out	0x3e, r29	; 62
   18276:	0f be       	out	0x3f, r0	; 63
   18278:	cd bf       	out	0x3d, r28	; 61
   1827a:	98 87       	std	Y+8, r25	; 0x08
   1827c:	8f 83       	std	Y+7, r24	; 0x07
	static char temp[7];
	int internal;
	uint8_t length;
	uint8_t i;
	uint8_t offset = 5;
   1827e:	85 e0       	ldi	r24, 0x05	; 5
   18280:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t remainder;

	if (num <0)
   18282:	8f 81       	ldd	r24, Y+7	; 0x07
   18284:	98 85       	ldd	r25, Y+8	; 0x08
   18286:	99 23       	and	r25, r25
   18288:	44 f4       	brge	.+16     	; 0x1829a
		internal = -num;
   1828a:	8f 81       	ldd	r24, Y+7	; 0x07
   1828c:	98 85       	ldd	r25, Y+8	; 0x08
   1828e:	90 95       	com	r25
   18290:	81 95       	neg	r24
   18292:	9f 4f       	sbci	r25, 0xFF	; 255
   18294:	9e 83       	std	Y+6, r25	; 0x06
   18296:	8d 83       	std	Y+5, r24	; 0x05
   18298:	04 c0       	rjmp	.+8      	; 0x182a2
	else
		internal = num;
   1829a:	8f 81       	ldd	r24, Y+7	; 0x07
   1829c:	98 85       	ldd	r25, Y+8	; 0x08
   1829e:	9e 83       	std	Y+6, r25	; 0x06
   182a0:	8d 83       	std	Y+5, r24	; 0x05

	temp[6] = '\0';
   182a2:	10 92 60 0a 	sts	0x0A60, r1

	do
	{
		remainder = internal%10;
   182a6:	8d 81       	ldd	r24, Y+5	; 0x05
   182a8:	9e 81       	ldd	r25, Y+6	; 0x06
   182aa:	2a e0       	ldi	r18, 0x0A	; 10
   182ac:	30 e0       	ldi	r19, 0x00	; 0
   182ae:	b9 01       	movw	r22, r18
   182b0:	0e 94 46 c5 	call	0x18a8c
   182b4:	89 83       	std	Y+1, r24	; 0x01
		temp[offset]= dec2char(remainder);
   182b6:	8a 81       	ldd	r24, Y+2	; 0x02
   182b8:	08 2f       	mov	r16, r24
   182ba:	11 27       	eor	r17, r17
   182bc:	89 81       	ldd	r24, Y+1	; 0x01
   182be:	0e 94 0d c1 	call	0x1821a
   182c2:	f8 01       	movw	r30, r16
   182c4:	e6 5a       	subi	r30, 0xA6	; 166
   182c6:	f5 4f       	sbci	r31, 0xF5	; 245
   182c8:	80 83       	st	Z, r24
		internal = internal/10;
   182ca:	8d 81       	ldd	r24, Y+5	; 0x05
   182cc:	9e 81       	ldd	r25, Y+6	; 0x06
   182ce:	2a e0       	ldi	r18, 0x0A	; 10
   182d0:	30 e0       	ldi	r19, 0x00	; 0
   182d2:	b9 01       	movw	r22, r18
   182d4:	0e 94 46 c5 	call	0x18a8c
   182d8:	cb 01       	movw	r24, r22
   182da:	9e 83       	std	Y+6, r25	; 0x06
   182dc:	8d 83       	std	Y+5, r24	; 0x05
		offset--;
   182de:	8a 81       	ldd	r24, Y+2	; 0x02
   182e0:	81 50       	subi	r24, 0x01	; 1
   182e2:	8a 83       	std	Y+2, r24	; 0x02
	}
	while (internal!=0);
   182e4:	8d 81       	ldd	r24, Y+5	; 0x05
   182e6:	9e 81       	ldd	r25, Y+6	; 0x06
   182e8:	00 97       	sbiw	r24, 0x00	; 0
   182ea:	e9 f6       	brne	.-70     	; 0x182a6

	if (num<0)
   182ec:	8f 81       	ldd	r24, Y+7	; 0x07
   182ee:	98 85       	ldd	r25, Y+8	; 0x08
   182f0:	99 23       	and	r25, r25
   182f2:	94 f4       	brge	.+36     	; 0x18318
	{temp[offset] = '-';
   182f4:	8a 81       	ldd	r24, Y+2	; 0x02
   182f6:	99 27       	eor	r25, r25
   182f8:	fc 01       	movw	r30, r24
   182fa:	e6 5a       	subi	r30, 0xA6	; 166
   182fc:	f5 4f       	sbci	r31, 0xF5	; 245
   182fe:	8d e2       	ldi	r24, 0x2D	; 45
   18300:	80 83       	st	Z, r24
	 if (offset ==0)
   18302:	8a 81       	ldd	r24, Y+2	; 0x02
   18304:	88 23       	and	r24, r24
   18306:	29 f4       	brne	.+10     	; 0x18312
		 return temp;
   18308:	8a e5       	ldi	r24, 0x5A	; 90
   1830a:	9a e0       	ldi	r25, 0x0A	; 10
   1830c:	9a 87       	std	Y+10, r25	; 0x0a
   1830e:	89 87       	std	Y+9, r24	; 0x09
   18310:	27 c0       	rjmp	.+78     	; 0x18360
	 else
		 offset--;
   18312:	8a 81       	ldd	r24, Y+2	; 0x02
   18314:	81 50       	subi	r24, 0x01	; 1
   18316:	8a 83       	std	Y+2, r24	; 0x02

	}




	{
		length = 7-offset-1;
   18318:	86 e0       	ldi	r24, 0x06	; 6
   1831a:	9a 81       	ldd	r25, Y+2	; 0x02
   1831c:	89 1b       	sub	r24, r25
   1831e:	8c 83       	std	Y+4, r24	; 0x04
		for (i=0;i<length;i++)
   18320:	1b 82       	std	Y+3, r1	; 0x03
   18322:	16 c0       	rjmp	.+44     	; 0x18350
			temp[i] = temp[i+offset+1];
   18324:	8b 81       	ldd	r24, Y+3	; 0x03
   18326:	48 2f       	mov	r20, r24
   18328:	55 27       	eor	r21, r21
   1832a:	8b 81       	ldd	r24, Y+3	; 0x03
   1832c:	28 2f       	mov	r18, r24
   1832e:	33 27       	eor	r19, r19
   18330:	8a 81       	ldd	r24, Y+2	; 0x02
   18332:	99 27       	eor	r25, r25
   18334:	82 0f       	add	r24, r18
   18336:	93 1f       	adc	r25, r19
   18338:	01 96       	adiw	r24, 0x01	; 1
   1833a:	fc 01       	movw	r30, r24
   1833c:	e6 5a       	subi	r30, 0xA6	; 166
   1833e:	f5 4f       	sbci	r31, 0xF5	; 245
   18340:	80 81       	ld	r24, Z
   18342:	fa 01       	movw	r30, r20
   18344:	e6 5a       	subi	r30, 0xA6	; 166
   18346:	f5 4f       	sbci	r31, 0xF5	; 245
   18348:	80 83       	st	Z, r24
   1834a:	8b 81       	ldd	r24, Y+3	; 0x03
   1834c:	8f 5f       	subi	r24, 0xFF	; 255
   1834e:	8b 83       	std	Y+3, r24	; 0x03
   18350:	9b 81       	ldd	r25, Y+3	; 0x03
   18352:	8c 81       	ldd	r24, Y+4	; 0x04
   18354:	98 17       	cp	r25, r24
   18356:	30 f3       	brcs	.-52     	; 0x18324
	}
	return temp;
   18358:	8a e5       	ldi	r24, 0x5A	; 90
   1835a:	9a e0       	ldi	r25, 0x0A	; 10
   1835c:	9a 87       	std	Y+10, r25	; 0x0a
   1835e:	89 87       	std	Y+9, r24	; 0x09
   18360:	89 85       	ldd	r24, Y+9	; 0x09
   18362:	9a 85       	ldd	r25, Y+10	; 0x0a
   18364:	2a 96       	adiw	r28, 0x0a	; 10
   18366:	0f b6       	in	r0, 0x3f	; 63
   18368:	f8 94       	cli
   1836a:	de bf       	out	0x3e, r29	; 62
   1836c:	0f be       	out	0x3f, r0	; 63
   1836e:	cd bf       	out	0x3d, r28	; 61
   18370:	df 91       	pop	r29
   18372:	cf 91       	pop	r28
   18374:	1f 91       	pop	r17
   18376:	0f 91       	pop	r16
   18378:	08 95       	ret

0001837a <String_append>:
}



void String_append(char *base, char *string)
{
   1837a:	cf 93       	push	r28
   1837c:	df 93       	push	r29
   1837e:	cd b7       	in	r28, 0x3d	; 61
   18380:	de b7       	in	r29, 0x3e	; 62
   18382:	29 97       	sbiw	r28, 0x09	; 9
   18384:	0f b6       	in	r0, 0x3f	; 63
   18386:	f8 94       	cli
   18388:	de bf       	out	0x3e, r29	; 62
   1838a:	0f be       	out	0x3f, r0	; 63
   1838c:	cd bf       	out	0x3d, r28	; 61
   1838e:	9f 83       	std	Y+7, r25	; 0x07
   18390:	8e 83       	std	Y+6, r24	; 0x06
   18392:	79 87       	std	Y+9, r23	; 0x09
   18394:	68 87       	std	Y+8, r22	; 0x08

	int length1, length2;
	uint8_t i;
	length1 = String_length(base);
   18396:	8e 81       	ldd	r24, Y+6	; 0x06
   18398:	9f 81       	ldd	r25, Y+7	; 0x07
   1839a:	0e 94 66 c0 	call	0x180cc
   1839e:	9d 83       	std	Y+5, r25	; 0x05
   183a0:	8c 83       	std	Y+4, r24	; 0x04
	length2 = String_length(string);
   183a2:	88 85       	ldd	r24, Y+8	; 0x08
   183a4:	99 85       	ldd	r25, Y+9	; 0x09
   183a6:	0e 94 66 c0 	call	0x180cc
   183aa:	9b 83       	std	Y+3, r25	; 0x03
   183ac:	8a 83       	std	Y+2, r24	; 0x02
	for (i=0;i<length2;i++)
   183ae:	19 82       	std	Y+1, r1	; 0x01
   183b0:	1a c0       	rjmp	.+52     	; 0x183e6
	{
		base[i+length1] = string[i];
   183b2:	89 81       	ldd	r24, Y+1	; 0x01
   183b4:	28 2f       	mov	r18, r24
   183b6:	33 27       	eor	r19, r19
   183b8:	8c 81       	ldd	r24, Y+4	; 0x04
   183ba:	9d 81       	ldd	r25, Y+5	; 0x05
   183bc:	82 0f       	add	r24, r18
   183be:	93 1f       	adc	r25, r19
   183c0:	9c 01       	movw	r18, r24
   183c2:	8e 81       	ldd	r24, Y+6	; 0x06
   183c4:	9f 81       	ldd	r25, Y+7	; 0x07
   183c6:	d9 01       	movw	r26, r18
   183c8:	a8 0f       	add	r26, r24
   183ca:	b9 1f       	adc	r27, r25
   183cc:	89 81       	ldd	r24, Y+1	; 0x01
   183ce:	99 27       	eor	r25, r25
   183d0:	9c 01       	movw	r18, r24
   183d2:	88 85       	ldd	r24, Y+8	; 0x08
   183d4:	99 85       	ldd	r25, Y+9	; 0x09
   183d6:	f9 01       	movw	r30, r18
   183d8:	e8 0f       	add	r30, r24
   183da:	f9 1f       	adc	r31, r25
   183dc:	80 81       	ld	r24, Z
   183de:	8c 93       	st	X, r24
   183e0:	89 81       	ldd	r24, Y+1	; 0x01
   183e2:	8f 5f       	subi	r24, 0xFF	; 255
   183e4:	89 83       	std	Y+1, r24	; 0x01
   183e6:	89 81       	ldd	r24, Y+1	; 0x01
   183e8:	28 2f       	mov	r18, r24
   183ea:	33 27       	eor	r19, r19
   183ec:	8a 81       	ldd	r24, Y+2	; 0x02
   183ee:	9b 81       	ldd	r25, Y+3	; 0x03
   183f0:	28 17       	cp	r18, r24
   183f2:	39 07       	cpc	r19, r25
   183f4:	f4 f2       	brlt	.-68     	; 0x183b2

	}
	base[length1+length2] = '\0';
   183f6:	2c 81       	ldd	r18, Y+4	; 0x04
   183f8:	3d 81       	ldd	r19, Y+5	; 0x05
   183fa:	8a 81       	ldd	r24, Y+2	; 0x02
   183fc:	9b 81       	ldd	r25, Y+3	; 0x03
   183fe:	82 0f       	add	r24, r18
   18400:	93 1f       	adc	r25, r19
   18402:	9c 01       	movw	r18, r24
   18404:	8e 81       	ldd	r24, Y+6	; 0x06
   18406:	9f 81       	ldd	r25, Y+7	; 0x07
   18408:	f9 01       	movw	r30, r18
   1840a:	e8 0f       	add	r30, r24
   1840c:	f9 1f       	adc	r31, r25
   1840e:	10 82       	st	Z, r1
   18410:	29 96       	adiw	r28, 0x09	; 9
   18412:	0f b6       	in	r0, 0x3f	; 63
   18414:	f8 94       	cli
   18416:	de bf       	out	0x3e, r29	; 62
   18418:	0f be       	out	0x3f, r0	; 63
   1841a:	cd bf       	out	0x3d, r28	; 61
   1841c:	df 91       	pop	r29
   1841e:	cf 91       	pop	r28
   18420:	08 95       	ret

00018422 <_atomic_start>:
volatile uint16_t * old_stack_ptr ;


_atomic_t _atomic_start(void)
{
   18422:	cf 93       	push	r28
   18424:	df 93       	push	r29
   18426:	cd b7       	in	r28, 0x3d	; 61
   18428:	de b7       	in	r29, 0x3e	; 62
   1842a:	21 97       	sbiw	r28, 0x01	; 1
   1842c:	0f b6       	in	r0, 0x3f	; 63
   1842e:	f8 94       	cli
   18430:	de bf       	out	0x3e, r29	; 62
   18432:	0f be       	out	0x3f, r0	; 63
   18434:	cd bf       	out	0x3d, r28	; 61
  _atomic_t result = SREG;
   18436:	ef e5       	ldi	r30, 0x5F	; 95
   18438:	f0 e0       	ldi	r31, 0x00	; 0
   1843a:	80 81       	ld	r24, Z
   1843c:	89 83       	std	Y+1, r24	; 0x01
  asm volatile("cli" "\n\t"::);
   1843e:	f8 94       	cli
  return result;
   18440:	89 81       	ldd	r24, Y+1	; 0x01
   18442:	99 27       	eor	r25, r25
   18444:	21 96       	adiw	r28, 0x01	; 1
   18446:	0f b6       	in	r0, 0x3f	; 63
   18448:	f8 94       	cli
   1844a:	de bf       	out	0x3e, r29	; 62
   1844c:	0f be       	out	0x3f, r0	; 63
   1844e:	cd bf       	out	0x3d, r28	; 61
   18450:	df 91       	pop	r29
   18452:	cf 91       	pop	r28
   18454:	08 95       	ret

00018456 <_atomic_end>:
}



void _atomic_end(_atomic_t oldSreg)
{
   18456:	cf 93       	push	r28
   18458:	df 93       	push	r29
   1845a:	cd b7       	in	r28, 0x3d	; 61
   1845c:	de b7       	in	r29, 0x3e	; 62
   1845e:	21 97       	sbiw	r28, 0x01	; 1
   18460:	0f b6       	in	r0, 0x3f	; 63
   18462:	f8 94       	cli
   18464:	de bf       	out	0x3e, r29	; 62
   18466:	0f be       	out	0x3f, r0	; 63
   18468:	cd bf       	out	0x3d, r28	; 61
   1846a:	89 83       	std	Y+1, r24	; 0x01
  SREG = oldSreg;
   1846c:	ef e5       	ldi	r30, 0x5F	; 95
   1846e:	f0 e0       	ldi	r31, 0x00	; 0
   18470:	89 81       	ldd	r24, Y+1	; 0x01
   18472:	80 83       	st	Z, r24
   18474:	21 96       	adiw	r28, 0x01	; 1
   18476:	0f b6       	in	r0, 0x3f	; 63
   18478:	f8 94       	cli
   1847a:	de bf       	out	0x3e, r29	; 62
   1847c:	0f be       	out	0x3f, r0	; 63
   1847e:	cd bf       	out	0x3d, r28	; 61
   18480:	df 91       	pop	r29
   18482:	cf 91       	pop	r28
   18484:	08 95       	ret

00018486 <rnd>:
}



int rnd()
{
   18486:	cf 93       	push	r28
   18488:	df 93       	push	r29
   1848a:	cd b7       	in	r28, 0x3d	; 61
   1848c:	de b7       	in	r29, 0x3e	; 62
   1848e:	24 97       	sbiw	r28, 0x04	; 4
   18490:	0f b6       	in	r0, 0x3f	; 63
   18492:	f8 94       	cli
   18494:	de bf       	out	0x3e, r29	; 62
   18496:	0f be       	out	0x3f, r0	; 63
   18498:	cd bf       	out	0x3d, r28	; 61

	 int ret;
   void (*getrandomfp)(void) = (void (*)(void))GET_RANDOM_NUMBER_FUNCTION;
   1849a:	8c eb       	ldi	r24, 0xBC	; 188
   1849c:	9a ee       	ldi	r25, 0xEA	; 234
   1849e:	9a 83       	std	Y+2, r25	; 0x02
   184a0:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   184a2:	4f 93       	push	r20
   184a4:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getrandomfp();
   184a6:	e9 81       	ldd	r30, Y+1	; 0x01
   184a8:	fa 81       	ldd	r31, Y+2	; 0x02
   184aa:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   184ac:	84 2f       	mov	r24, r20
   184ae:	95 2f       	mov	r25, r21
   184b0:	9c 83       	std	Y+4, r25	; 0x04
   184b2:	8b 83       	std	Y+3, r24	; 0x03
	              "mov %B0, r21" "\n\t"
				 :"=r" (ret)
				 :
                );
   asm volatile("pop r21" "\n\t"
   184b4:	5f 91       	pop	r21
   184b6:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return ret;
   184b8:	8b 81       	ldd	r24, Y+3	; 0x03
   184ba:	9c 81       	ldd	r25, Y+4	; 0x04
   184bc:	24 96       	adiw	r28, 0x04	; 4
   184be:	0f b6       	in	r0, 0x3f	; 63
   184c0:	f8 94       	cli
   184c2:	de bf       	out	0x3e, r29	; 62
   184c4:	0f be       	out	0x3f, r0	; 63
   184c6:	cd bf       	out	0x3d, r28	; 61
   184c8:	df 91       	pop	r29
   184ca:	cf 91       	pop	r28
   184cc:	08 95       	ret

000184ce <getnodeID>:

}



uint16_t getnodeID()
	{
   184ce:	cf 93       	push	r28
   184d0:	df 93       	push	r29
   184d2:	cd b7       	in	r28, 0x3d	; 61
   184d4:	de b7       	in	r29, 0x3e	; 62
   184d6:	24 97       	sbiw	r28, 0x04	; 4
   184d8:	0f b6       	in	r0, 0x3f	; 63
   184da:	f8 94       	cli
   184dc:	de bf       	out	0x3e, r29	; 62
   184de:	0f be       	out	0x3f, r0	; 63
   184e0:	cd bf       	out	0x3d, r28	; 61

	   int ret;
	   void (*fp)(void) = (void (*)(void))GET_NODE_ID_FUNCTION;
   184e2:	8c ec       	ldi	r24, 0xCC	; 204
   184e4:	9a ee       	ldi	r25, 0xEA	; 234
   184e6:	9a 83       	std	Y+2, r25	; 0x02
   184e8:	89 83       	std	Y+1, r24	; 0x01
	   asm volatile("push r20" "\n\t"
   184ea:	4f 93       	push	r20
   184ec:	5f 93       	push	r21
					"push r21" "\n\t"
					::);
	   fp();
   184ee:	e9 81       	ldd	r30, Y+1	; 0x01
   184f0:	fa 81       	ldd	r31, Y+2	; 0x02
   184f2:	09 95       	icall
	   asm volatile(" mov %A0, r20" "\n\t"
   184f4:	84 2f       	mov	r24, r20
   184f6:	95 2f       	mov	r25, r21
   184f8:	9c 83       	std	Y+4, r25	; 0x04
   184fa:	8b 83       	std	Y+3, r24	; 0x03
					  "mov %B0, r21" "\n\t"
					 :"=r" (ret)
					 :
					);
	   asm volatile("pop r21" "\n\t"
   184fc:	5f 91       	pop	r21
   184fe:	4f 91       	pop	r20
					 "pop r20" "\n\t"
					  ::);
	   return ret;
   18500:	8b 81       	ldd	r24, Y+3	; 0x03
   18502:	9c 81       	ldd	r25, Y+4	; 0x04
   18504:	24 96       	adiw	r28, 0x04	; 4
   18506:	0f b6       	in	r0, 0x3f	; 63
   18508:	f8 94       	cli
   1850a:	de bf       	out	0x3e, r29	; 62
   1850c:	0f be       	out	0x3f, r0	; 63
   1850e:	cd bf       	out	0x3d, r28	; 61
   18510:	df 91       	pop	r29
   18512:	cf 91       	pop	r28
   18514:	08 95       	ret

00018516 <setnodeID>:

	}


void setnodeID(uint16_t nodeid)
	{
   18516:	cf 93       	push	r28
   18518:	df 93       	push	r29
   1851a:	cd b7       	in	r28, 0x3d	; 61
   1851c:	de b7       	in	r29, 0x3e	; 62
   1851e:	24 97       	sbiw	r28, 0x04	; 4
   18520:	0f b6       	in	r0, 0x3f	; 63
   18522:	f8 94       	cli
   18524:	de bf       	out	0x3e, r29	; 62
   18526:	0f be       	out	0x3f, r0	; 63
   18528:	cd bf       	out	0x3d, r28	; 61
   1852a:	9c 83       	std	Y+4, r25	; 0x04
   1852c:	8b 83       	std	Y+3, r24	; 0x03



	   void (*fp)(void) = (void (*)(void))SET_NODE_ID_FUNCTION;
   1852e:	80 ed       	ldi	r24, 0xD0	; 208
   18530:	9a ee       	ldi	r25, 0xEA	; 234
   18532:	9a 83       	std	Y+2, r25	; 0x02
   18534:	89 83       	std	Y+1, r24	; 0x01
	   asm volatile("push r20" "\n\t"
   18536:	4f 93       	push	r20
   18538:	5f 93       	push	r21
					"push r21" "\n\t"
					::);

	   asm volatile(" mov r20, %A0" "\n\t"
   1853a:	8b 81       	ldd	r24, Y+3	; 0x03
   1853c:	9c 81       	ldd	r25, Y+4	; 0x04
   1853e:	48 2f       	mov	r20, r24
   18540:	59 2f       	mov	r21, r25
					  "mov r21, %B0" "\n\t"
					 :
					 :"r" (nodeid)
					);
	   fp();
   18542:	e9 81       	ldd	r30, Y+1	; 0x01
   18544:	fa 81       	ldd	r31, Y+2	; 0x02
   18546:	09 95       	icall
	   asm volatile("pop r21" "\n\t"
   18548:	5f 91       	pop	r21
   1854a:	4f 91       	pop	r20
   1854c:	24 96       	adiw	r28, 0x04	; 4
   1854e:	0f b6       	in	r0, 0x3f	; 63
   18550:	f8 94       	cli
   18552:	de bf       	out	0x3e, r29	; 62
   18554:	0f be       	out	0x3f, r0	; 63
   18556:	cd bf       	out	0x3d, r28	; 61
   18558:	df 91       	pop	r29
   1855a:	cf 91       	pop	r28
   1855c:	08 95       	ret

0001855e <getCurrentThread>:

//Warning: this returns the address of the currentthread pointer. 

thread **getCurrentThread()
{
   1855e:	cf 93       	push	r28
   18560:	df 93       	push	r29
   18562:	cd b7       	in	r28, 0x3d	; 61
   18564:	de b7       	in	r29, 0x3e	; 62
   18566:	24 97       	sbiw	r28, 0x04	; 4
   18568:	0f b6       	in	r0, 0x3f	; 63
   1856a:	f8 94       	cli
   1856c:	de bf       	out	0x3e, r29	; 62
   1856e:	0f be       	out	0x3f, r0	; 63
   18570:	cd bf       	out	0x3d, r28	; 61
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   18572:	8c e0       	ldi	r24, 0x0C	; 12
   18574:	9a ee       	ldi	r25, 0xEA	; 234
   18576:	9a 83       	std	Y+2, r25	; 0x02
   18578:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   1857a:	4f 93       	push	r20
   1857c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   1857e:	e9 81       	ldd	r30, Y+1	; 0x01
   18580:	fa 81       	ldd	r31, Y+2	; 0x02
   18582:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18584:	84 2f       	mov	r24, r20
   18586:	95 2f       	mov	r25, r21
   18588:	9c 83       	std	Y+4, r25	; 0x04
   1858a:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   1858c:	5f 91       	pop	r21
   1858e:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
   18590:	8b 81       	ldd	r24, Y+3	; 0x03
   18592:	9c 81       	ldd	r25, Y+4	; 0x04
   18594:	24 96       	adiw	r28, 0x04	; 4
   18596:	0f b6       	in	r0, 0x3f	; 63
   18598:	f8 94       	cli
   1859a:	de bf       	out	0x3e, r29	; 62
   1859c:	0f be       	out	0x3f, r0	; 63
   1859e:	cd bf       	out	0x3d, r28	; 61
   185a0:	df 91       	pop	r29
   185a2:	cf 91       	pop	r28
   185a4:	08 95       	ret

000185a6 <getKernelStackPtr>:
}


void **getKernelStackPtr()
	{
   185a6:	cf 93       	push	r28
   185a8:	df 93       	push	r29
   185aa:	cd b7       	in	r28, 0x3d	; 61
   185ac:	de b7       	in	r29, 0x3e	; 62
   185ae:	24 97       	sbiw	r28, 0x04	; 4
   185b0:	0f b6       	in	r0, 0x3f	; 63
   185b2:	f8 94       	cli
   185b4:	de bf       	out	0x3e, r29	; 62
   185b6:	0f be       	out	0x3f, r0	; 63
   185b8:	cd bf       	out	0x3d, r28	; 61
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   185ba:	88 e0       	ldi	r24, 0x08	; 8
   185bc:	9b ee       	ldi	r25, 0xEB	; 235
   185be:	9a 83       	std	Y+2, r25	; 0x02
   185c0:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   185c2:	4f 93       	push	r20
   185c4:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   185c6:	e9 81       	ldd	r30, Y+1	; 0x01
   185c8:	fa 81       	ldd	r31, Y+2	; 0x02
   185ca:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   185cc:	84 2f       	mov	r24, r20
   185ce:	95 2f       	mov	r25, r21
   185d0:	9c 83       	std	Y+4, r25	; 0x04
   185d2:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
   185d4:	5f 91       	pop	r21
   185d6:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
   185d8:	8b 81       	ldd	r24, Y+3	; 0x03
   185da:	9c 81       	ldd	r25, Y+4	; 0x04
   185dc:	24 96       	adiw	r28, 0x04	; 4
   185de:	0f b6       	in	r0, 0x3f	; 63
   185e0:	f8 94       	cli
   185e2:	de bf       	out	0x3e, r29	; 62
   185e4:	0f be       	out	0x3f, r0	; 63
   185e6:	cd bf       	out	0x3d, r28	; 61
   185e8:	df 91       	pop	r29
   185ea:	cf 91       	pop	r28
   185ec:	08 95       	ret

000185ee <getCurrentThreadIndex>:
}







uint8_t getCurrentThreadIndex()
{
   185ee:	cf 93       	push	r28
   185f0:	df 93       	push	r29
   185f2:	cd b7       	in	r28, 0x3d	; 61
   185f4:	de b7       	in	r29, 0x3e	; 62
   185f6:	24 97       	sbiw	r28, 0x04	; 4
   185f8:	0f b6       	in	r0, 0x3f	; 63
   185fa:	f8 94       	cli
   185fc:	de bf       	out	0x3e, r29	; 62
   185fe:	0f be       	out	0x3f, r0	; 63
   18600:	cd bf       	out	0x3d, r28	; 61
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   18602:	8c e1       	ldi	r24, 0x1C	; 28
   18604:	9a ee       	ldi	r25, 0xEA	; 234
   18606:	9a 83       	std	Y+2, r25	; 0x02
   18608:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   1860a:	4f 93       	push	r20
   1860c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   1860e:	e9 81       	ldd	r30, Y+1	; 0x01
   18610:	fa 81       	ldd	r31, Y+2	; 0x02
   18612:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   18614:	84 2f       	mov	r24, r20
   18616:	95 2f       	mov	r25, r21
   18618:	9c 83       	std	Y+4, r25	; 0x04
   1861a:	8b 83       	std	Y+3, r24	; 0x03
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
   1861c:	5f 91       	pop	r21
   1861e:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
   18620:	8b 81       	ldd	r24, Y+3	; 0x03
   18622:	99 27       	eor	r25, r25
   18624:	24 96       	adiw	r28, 0x04	; 4
   18626:	0f b6       	in	r0, 0x3f	; 63
   18628:	f8 94       	cli
   1862a:	de bf       	out	0x3e, r29	; 62
   1862c:	0f be       	out	0x3f, r0	; 63
   1862e:	cd bf       	out	0x3d, r28	; 61
   18630:	df 91       	pop	r29
   18632:	cf 91       	pop	r28
   18634:	08 95       	ret

00018636 <sleepThread>:
}


void sleepThread(int milliseconds)
{
   18636:	cf 93       	push	r28
   18638:	df 93       	push	r29
   1863a:	cd b7       	in	r28, 0x3d	; 61
   1863c:	de b7       	in	r29, 0x3e	; 62
   1863e:	24 97       	sbiw	r28, 0x04	; 4
   18640:	0f b6       	in	r0, 0x3f	; 63
   18642:	f8 94       	cli
   18644:	de bf       	out	0x3e, r29	; 62
   18646:	0f be       	out	0x3f, r0	; 63
   18648:	cd bf       	out	0x3d, r28	; 61
   1864a:	9c 83       	std	Y+4, r25	; 0x04
   1864c:	8b 83       	std	Y+3, r24	; 0x03
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
   1864e:	0e 94 af c2 	call	0x1855e
   18652:	9a 83       	std	Y+2, r25	; 0x02
   18654:	89 83       	std	Y+1, r24	; 0x01
     
   (*current_thread)->state = 4;
   18656:	e9 81       	ldd	r30, Y+1	; 0x01
   18658:	fa 81       	ldd	r31, Y+2	; 0x02
   1865a:	01 90       	ld	r0, Z+
   1865c:	f0 81       	ld	r31, Z
   1865e:	e0 2d       	mov	r30, r0
   18660:	84 e0       	ldi	r24, 0x04	; 4
   18662:	82 83       	std	Z+2, r24	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   18664:	e9 81       	ldd	r30, Y+1	; 0x01
   18666:	fa 81       	ldd	r31, Y+2	; 0x02
   18668:	01 90       	ld	r0, Z+
   1866a:	f0 81       	ld	r31, Z
   1866c:	e0 2d       	mov	r30, r0
   1866e:	8b 81       	ldd	r24, Y+3	; 0x03
   18670:	9c 81       	ldd	r25, Y+4	; 0x04
   18672:	94 8f       	std	Z+28, r25	; 0x1c
   18674:	83 8f       	std	Z+27, r24	; 0x1b
   
   yield(); 
   18676:	0e 94 66 c3 	call	0x186cc
   1867a:	24 96       	adiw	r28, 0x04	; 4
   1867c:	0f b6       	in	r0, 0x3f	; 63
   1867e:	f8 94       	cli
   18680:	de bf       	out	0x3e, r29	; 62
   18682:	0f be       	out	0x3f, r0	; 63
   18684:	cd bf       	out	0x3d, r28	; 61
   18686:	df 91       	pop	r29
   18688:	cf 91       	pop	r28
   1868a:	08 95       	ret

0001868c <hibernateThread>:
}


void hibernateThread()
{
   1868c:	cf 93       	push	r28
   1868e:	df 93       	push	r29
   18690:	cd b7       	in	r28, 0x3d	; 61
   18692:	de b7       	in	r29, 0x3e	; 62
   18694:	22 97       	sbiw	r28, 0x02	; 2
   18696:	0f b6       	in	r0, 0x3f	; 63
   18698:	f8 94       	cli
   1869a:	de bf       	out	0x3e, r29	; 62
   1869c:	0f be       	out	0x3f, r0	; 63
   1869e:	cd bf       	out	0x3d, r28	; 61
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
   186a0:	0e 94 af c2 	call	0x1855e
   186a4:	9a 83       	std	Y+2, r25	; 0x02
   186a6:	89 83       	std	Y+1, r24	; 0x01
     
   (*current_thread)->state = 5; 
   186a8:	e9 81       	ldd	r30, Y+1	; 0x01
   186aa:	fa 81       	ldd	r31, Y+2	; 0x02
   186ac:	01 90       	ld	r0, Z+
   186ae:	f0 81       	ld	r31, Z
   186b0:	e0 2d       	mov	r30, r0
   186b2:	85 e0       	ldi	r24, 0x05	; 5
   186b4:	82 83       	std	Z+2, r24	; 0x02
   yield(); 
   186b6:	0e 94 66 c3 	call	0x186cc
   186ba:	22 96       	adiw	r28, 0x02	; 2
   186bc:	0f b6       	in	r0, 0x3f	; 63
   186be:	f8 94       	cli
   186c0:	de bf       	out	0x3e, r29	; 62
   186c2:	0f be       	out	0x3f, r0	; 63
   186c4:	cd bf       	out	0x3d, r28	; 61
   186c6:	df 91       	pop	r29
   186c8:	cf 91       	pop	r28
   186ca:	08 95       	ret

000186cc <yield>:
}


void yield()
{
   186cc:	cf 93       	push	r28
   186ce:	df 93       	push	r29
   186d0:	cd b7       	in	r28, 0x3d	; 61
   186d2:	de b7       	in	r29, 0x3e	; 62
   186d4:	22 97       	sbiw	r28, 0x02	; 2
   186d6:	0f b6       	in	r0, 0x3f	; 63
   186d8:	f8 94       	cli
   186da:	de bf       	out	0x3e, r29	; 62
   186dc:	0f be       	out	0x3f, r0	; 63
   186de:	cd bf       	out	0x3d, r28	; 61
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
   186e0:	80 e0       	ldi	r24, 0x00	; 0
   186e2:	9a ee       	ldi	r25, 0xEA	; 234
   186e4:	9a 83       	std	Y+2, r25	; 0x02
   186e6:	89 83       	std	Y+1, r24	; 0x01
 yieldfp();                              
   186e8:	e9 81       	ldd	r30, Y+1	; 0x01
   186ea:	fa 81       	ldd	r31, Y+2	; 0x02
   186ec:	09 95       	icall
   186ee:	22 96       	adiw	r28, 0x02	; 2
   186f0:	0f b6       	in	r0, 0x3f	; 63
   186f2:	f8 94       	cli
   186f4:	de bf       	out	0x3e, r29	; 62
   186f6:	0f be       	out	0x3f, r0	; 63
   186f8:	cd bf       	out	0x3d, r28	; 61
   186fa:	df 91       	pop	r29
   186fc:	cf 91       	pop	r28
   186fe:	08 95       	ret

00018700 <syscall_postThreadTask>:
}



void syscall_postThreadTask()
{
   18700:	cf 93       	push	r28
   18702:	df 93       	push	r29
   18704:	cd b7       	in	r28, 0x3d	; 61
   18706:	de b7       	in	r29, 0x3e	; 62
   18708:	22 97       	sbiw	r28, 0x02	; 2
   1870a:	0f b6       	in	r0, 0x3f	; 63
   1870c:	f8 94       	cli
   1870e:	de bf       	out	0x3e, r29	; 62
   18710:	0f be       	out	0x3f, r0	; 63
   18712:	cd bf       	out	0x3d, r28	; 61
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
   18714:	88 e6       	ldi	r24, 0x68	; 104
   18716:	9a ee       	ldi	r25, 0xEA	; 234
   18718:	9a 83       	std	Y+2, r25	; 0x02
   1871a:	89 83       	std	Y+1, r24	; 0x01
 postthreadfp();                              
   1871c:	e9 81       	ldd	r30, Y+1	; 0x01
   1871e:	fa 81       	ldd	r31, Y+2	; 0x02
   18720:	09 95       	icall
   18722:	22 96       	adiw	r28, 0x02	; 2
   18724:	0f b6       	in	r0, 0x3f	; 63
   18726:	f8 94       	cli
   18728:	de bf       	out	0x3e, r29	; 62
   1872a:	0f be       	out	0x3f, r0	; 63
   1872c:	cd bf       	out	0x3d, r28	; 61
   1872e:	df 91       	pop	r29
   18730:	cf 91       	pop	r28
   18732:	08 95       	ret

00018734 <syscall_postThreadTask_nologging>:
}

void syscall_postThreadTask_nologging()
{
   18734:	cf 93       	push	r28
   18736:	df 93       	push	r29
   18738:	cd b7       	in	r28, 0x3d	; 61
   1873a:	de b7       	in	r29, 0x3e	; 62
   1873c:	22 97       	sbiw	r28, 0x02	; 2
   1873e:	0f b6       	in	r0, 0x3f	; 63
   18740:	f8 94       	cli
   18742:	de bf       	out	0x3e, r29	; 62
   18744:	0f be       	out	0x3f, r0	; 63
   18746:	cd bf       	out	0x3d, r28	; 61
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK_NOLOG; 
   18748:	80 ef       	ldi	r24, 0xF0	; 240
   1874a:	9a ee       	ldi	r25, 0xEA	; 234
   1874c:	9a 83       	std	Y+2, r25	; 0x02
   1874e:	89 83       	std	Y+1, r24	; 0x01
 postthreadfp();                              
   18750:	e9 81       	ldd	r30, Y+1	; 0x01
   18752:	fa 81       	ldd	r31, Y+2	; 0x02
   18754:	09 95       	icall
   18756:	22 96       	adiw	r28, 0x02	; 2
   18758:	0f b6       	in	r0, 0x3f	; 63
   1875a:	f8 94       	cli
   1875c:	de bf       	out	0x3e, r29	; 62
   1875e:	0f be       	out	0x3f, r0	; 63
   18760:	cd bf       	out	0x3d, r28	; 61
   18762:	df 91       	pop	r29
   18764:	cf 91       	pop	r28
   18766:	08 95       	ret

00018768 <debugValue>:
}


void debugValue(uint16_t v1, uint16_t v2, uint16_t v3)
{
   18768:	cf 93       	push	r28
   1876a:	df 93       	push	r29
   1876c:	cd b7       	in	r28, 0x3d	; 61
   1876e:	de b7       	in	r29, 0x3e	; 62
   18770:	28 97       	sbiw	r28, 0x08	; 8
   18772:	0f b6       	in	r0, 0x3f	; 63
   18774:	f8 94       	cli
   18776:	de bf       	out	0x3e, r29	; 62
   18778:	0f be       	out	0x3f, r0	; 63
   1877a:	cd bf       	out	0x3d, r28	; 61
   1877c:	9c 83       	std	Y+4, r25	; 0x04
   1877e:	8b 83       	std	Y+3, r24	; 0x03
   18780:	7e 83       	std	Y+6, r23	; 0x06
   18782:	6d 83       	std	Y+5, r22	; 0x05
   18784:	58 87       	std	Y+8, r21	; 0x08
   18786:	4f 83       	std	Y+7, r20	; 0x07

  void (*fp)(void) = (void (*)(void))DEBUG_VALUE_SYSCALL; 
   18788:	8c e6       	ldi	r24, 0x6C	; 108
   1878a:	9a ee       	ldi	r25, 0xEA	; 234
   1878c:	9a 83       	std	Y+2, r25	; 0x02
   1878e:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r8" "\n\t"
   18790:	8f 92       	push	r8
   18792:	9f 92       	push	r9
   18794:	af 92       	push	r10
   18796:	bf 92       	push	r11
   18798:	cf 92       	push	r12
   1879a:	df 92       	push	r13
                "push r9" "\n\t"
                "push r10" "\n\t"
                "push r11" "\n\t"
				"push r12" "\n\t"
				"push r13" "\n\t"
                ::);
   
   asm volatile(" mov r8, %A0" "\n\t"
   1879c:	8b 81       	ldd	r24, Y+3	; 0x03
   1879e:	9c 81       	ldd	r25, Y+4	; 0x04
   187a0:	88 2e       	mov	r8, r24
   187a2:	99 2e       	mov	r9, r25
	             "mov r9, %B0" "\n\t"
				 :
				 :"r" (v1)
                );


   asm volatile(" mov r10, %A0" "\n\t"
   187a4:	8d 81       	ldd	r24, Y+5	; 0x05
   187a6:	9e 81       	ldd	r25, Y+6	; 0x06
   187a8:	a8 2e       	mov	r10, r24
   187aa:	b9 2e       	mov	r11, r25
	             "mov r11, %B0" "\n\t"
				 :
				 :"r" (v2)
                );
 
   asm volatile(" mov r12, %A0" "\n\t"
   187ac:	8f 81       	ldd	r24, Y+7	; 0x07
   187ae:	98 85       	ldd	r25, Y+8	; 0x08
   187b0:	c8 2e       	mov	r12, r24
   187b2:	d9 2e       	mov	r13, r25
	             "mov r13, %B0" "\n\t"
				 :
				 :"r" (v3)
                );


  fp(); 
   187b4:	e9 81       	ldd	r30, Y+1	; 0x01
   187b6:	fa 81       	ldd	r31, Y+2	; 0x02
   187b8:	09 95       	icall

  asm volatile("pop r13" "\n\t"
   187ba:	df 90       	pop	r13
   187bc:	cf 90       	pop	r12
	           "pop r12" "\n\t"
	              ::);

  asm volatile("pop r11" "\n\t"
   187be:	bf 90       	pop	r11
   187c0:	af 90       	pop	r10
	           "pop r10" "\n\t"
	              ::);

  asm volatile("pop r9" "\n\t"
   187c2:	9f 90       	pop	r9
   187c4:	8f 90       	pop	r8
   187c6:	28 96       	adiw	r28, 0x08	; 8
   187c8:	0f b6       	in	r0, 0x3f	; 63
   187ca:	f8 94       	cli
   187cc:	de bf       	out	0x3e, r29	; 62
   187ce:	0f be       	out	0x3f, r0	; 63
   187d0:	cd bf       	out	0x3d, r28	; 61
   187d2:	df 91       	pop	r29
   187d4:	cf 91       	pop	r28
   187d6:	08 95       	ret

000187d8 <postTask>:
	           "pop r8" "\n\t"
	              ::);
  return; 


}


void postTask(void (*tp) (void), uint16_t priority)
{
   187d8:	cf 93       	push	r28
   187da:	df 93       	push	r29
   187dc:	cd b7       	in	r28, 0x3d	; 61
   187de:	de b7       	in	r29, 0x3e	; 62
   187e0:	26 97       	sbiw	r28, 0x06	; 6
   187e2:	0f b6       	in	r0, 0x3f	; 63
   187e4:	f8 94       	cli
   187e6:	de bf       	out	0x3e, r29	; 62
   187e8:	0f be       	out	0x3f, r0	; 63
   187ea:	cd bf       	out	0x3d, r28	; 61
   187ec:	9c 83       	std	Y+4, r25	; 0x04
   187ee:	8b 83       	std	Y+3, r24	; 0x03
   187f0:	7e 83       	std	Y+6, r23	; 0x06
   187f2:	6d 83       	std	Y+5, r22	; 0x05
   void (*fp)(void) = (void (*)(void))POST_TASK_SYSCALL; 
   187f4:	88 e5       	ldi	r24, 0x58	; 88
   187f6:	9a ee       	ldi	r25, 0xEA	; 234
   187f8:	9a 83       	std	Y+2, r25	; 0x02
   187fa:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   187fc:	4f 93       	push	r20
   187fe:	5f 93       	push	r21
   18800:	6f 93       	push	r22
   18802:	7f 93       	push	r23
                "push r21" "\n\t"
				"push r22" "\n\t"
				"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   18804:	8b 81       	ldd	r24, Y+3	; 0x03
   18806:	9c 81       	ldd	r25, Y+4	; 0x04
   18808:	48 2f       	mov	r20, r24
   1880a:	59 2f       	mov	r21, r25
	             "mov r21, %B0" "\n\t"
				 :
				 :"r" (tp)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   1880c:	8d 81       	ldd	r24, Y+5	; 0x05
   1880e:	9e 81       	ldd	r25, Y+6	; 0x06
   18810:	68 2f       	mov	r22, r24
   18812:	79 2f       	mov	r23, r25
	             "mov r23, %B0" "\n\t"
				 :
				 :"r" (priority)
                );

  fp(); 
   18814:	e9 81       	ldd	r30, Y+1	; 0x01
   18816:	fa 81       	ldd	r31, Y+2	; 0x02
   18818:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   1881a:	7f 91       	pop	r23
   1881c:	6f 91       	pop	r22
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   1881e:	5f 91       	pop	r21
   18820:	4f 91       	pop	r20
   18822:	26 96       	adiw	r28, 0x06	; 6
   18824:	0f b6       	in	r0, 0x3f	; 63
   18826:	f8 94       	cli
   18828:	de bf       	out	0x3e, r29	; 62
   1882a:	0f be       	out	0x3f, r0	; 63
   1882c:	cd bf       	out	0x3d, r28	; 61
   1882e:	df 91       	pop	r29
   18830:	cf 91       	pop	r28
   18832:	08 95       	ret

00018834 <postTaskWithoutLogging>:
	           "pop r20" "\n\t"
	              ::);
  return; 


}




void postTaskWithoutLogging(void (*tp) (void), uint16_t priority)
{
   18834:	cf 93       	push	r28
   18836:	df 93       	push	r29
   18838:	cd b7       	in	r28, 0x3d	; 61
   1883a:	de b7       	in	r29, 0x3e	; 62
   1883c:	26 97       	sbiw	r28, 0x06	; 6
   1883e:	0f b6       	in	r0, 0x3f	; 63
   18840:	f8 94       	cli
   18842:	de bf       	out	0x3e, r29	; 62
   18844:	0f be       	out	0x3f, r0	; 63
   18846:	cd bf       	out	0x3d, r28	; 61
   18848:	9c 83       	std	Y+4, r25	; 0x04
   1884a:	8b 83       	std	Y+3, r24	; 0x03
   1884c:	7e 83       	std	Y+6, r23	; 0x06
   1884e:	6d 83       	std	Y+5, r22	; 0x05
   void (*fp)(void) = (void (*)(void))POST_TASK_SYSCALL; 
   18850:	88 e5       	ldi	r24, 0x58	; 88
   18852:	9a ee       	ldi	r25, 0xEA	; 234
   18854:	9a 83       	std	Y+2, r25	; 0x02
   18856:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   18858:	4f 93       	push	r20
   1885a:	5f 93       	push	r21
   1885c:	6f 93       	push	r22
   1885e:	7f 93       	push	r23
                "push r21" "\n\t"
				"push r22" "\n\t"
				"push r23" "\n\t"
                ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   18860:	8b 81       	ldd	r24, Y+3	; 0x03
   18862:	9c 81       	ldd	r25, Y+4	; 0x04
   18864:	48 2f       	mov	r20, r24
   18866:	59 2f       	mov	r21, r25
	             "mov r21, %B0" "\n\t"
				 :
				 :"r" (tp)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   18868:	8d 81       	ldd	r24, Y+5	; 0x05
   1886a:	9e 81       	ldd	r25, Y+6	; 0x06
   1886c:	68 2f       	mov	r22, r24
   1886e:	79 2f       	mov	r23, r25
	             "mov r23, %B0" "\n\t"
				 :
				 :"r" (priority)
                );

  fp(); 
   18870:	e9 81       	ldd	r30, Y+1	; 0x01
   18872:	fa 81       	ldd	r31, Y+2	; 0x02
   18874:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   18876:	7f 91       	pop	r23
   18878:	6f 91       	pop	r22
	           "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   1887a:	5f 91       	pop	r21
   1887c:	4f 91       	pop	r20
   1887e:	26 96       	adiw	r28, 0x06	; 6
   18880:	0f b6       	in	r0, 0x3f	; 63
   18882:	f8 94       	cli
   18884:	de bf       	out	0x3e, r29	; 62
   18886:	0f be       	out	0x3f, r0	; 63
   18888:	cd bf       	out	0x3d, r28	; 61
   1888a:	df 91       	pop	r29
   1888c:	cf 91       	pop	r28
   1888e:	08 95       	ret

00018890 <getCurrentThreadControlBlockAddr>:
	           "pop r20" "\n\t"
	              ::);
  return; 


}


thread_create_block_type *getCurrentThreadControlBlockAddr()
{
   18890:	cf 93       	push	r28
   18892:	df 93       	push	r29
   18894:	cd b7       	in	r28, 0x3d	; 61
   18896:	de b7       	in	r29, 0x3e	; 62
   18898:	24 97       	sbiw	r28, 0x04	; 4
   1889a:	0f b6       	in	r0, 0x3f	; 63
   1889c:	f8 94       	cli
   1889e:	de bf       	out	0x3e, r29	; 62
   188a0:	0f be       	out	0x3f, r0	; 63
   188a2:	cd bf       	out	0x3d, r28	; 61
   thread_create_block_type *blockinfo; 
   void (*getaddrfp)(void) = (void (*)(void))GET_THREAD_CONTROL_BLOCK; 
   188a4:	84 ed       	ldi	r24, 0xD4	; 212
   188a6:	9a ee       	ldi	r25, 0xEA	; 234
   188a8:	9a 83       	std	Y+2, r25	; 0x02
   188aa:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   188ac:	4f 93       	push	r20
   188ae:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   188b0:	e9 81       	ldd	r30, Y+1	; 0x01
   188b2:	fa 81       	ldd	r31, Y+2	; 0x02
   188b4:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   188b6:	84 2f       	mov	r24, r20
   188b8:	95 2f       	mov	r25, r21
   188ba:	9c 83       	std	Y+4, r25	; 0x04
   188bc:	8b 83       	std	Y+3, r24	; 0x03
	              " mov %B0, r21" "\n\t"
				 :"=r" (blockinfo)
				 :
               );
    asm volatile("pop r21" "\n\t"
   188be:	5f 91       	pop	r21
   188c0:	4f 91       	pop	r20
	               "pop r20" "\n\t"
	               ::);
   return blockinfo; 
   188c2:	8b 81       	ldd	r24, Y+3	; 0x03
   188c4:	9c 81       	ldd	r25, Y+4	; 0x04
   188c6:	24 96       	adiw	r28, 0x04	; 4
   188c8:	0f b6       	in	r0, 0x3f	; 63
   188ca:	f8 94       	cli
   188cc:	de bf       	out	0x3e, r29	; 62
   188ce:	0f be       	out	0x3f, r0	; 63
   188d0:	cd bf       	out	0x3d, r28	; 61
   188d2:	df 91       	pop	r29
   188d4:	cf 91       	pop	r28
   188d6:	08 95       	ret

000188d8 <getCurrentThreadControlMutexAddr>:
}


void *getCurrentThreadControlMutexAddr()
{
   188d8:	cf 93       	push	r28
   188da:	df 93       	push	r29
   188dc:	cd b7       	in	r28, 0x3d	; 61
   188de:	de b7       	in	r29, 0x3e	; 62
   188e0:	24 97       	sbiw	r28, 0x04	; 4
   188e2:	0f b6       	in	r0, 0x3f	; 63
   188e4:	f8 94       	cli
   188e6:	de bf       	out	0x3e, r29	; 62
   188e8:	0f be       	out	0x3f, r0	; 63
   188ea:	cd bf       	out	0x3d, r28	; 61
   void *blockinfo; 
   void (*getaddrfp)(void) = (void (*)(void))GET_THREAD_CONTROL_MUTEX; 
   188ec:	88 ed       	ldi	r24, 0xD8	; 216
   188ee:	9a ee       	ldi	r25, 0xEA	; 234
   188f0:	9a 83       	std	Y+2, r25	; 0x02
   188f2:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   188f4:	4f 93       	push	r20
   188f6:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   188f8:	e9 81       	ldd	r30, Y+1	; 0x01
   188fa:	fa 81       	ldd	r31, Y+2	; 0x02
   188fc:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   188fe:	84 2f       	mov	r24, r20
   18900:	95 2f       	mov	r25, r21
   18902:	9c 83       	std	Y+4, r25	; 0x04
   18904:	8b 83       	std	Y+3, r24	; 0x03
	              " mov %B0, r21" "\n\t"
				 :"=r" (blockinfo)
				 :
               );
    asm volatile("pop r21" "\n\t"
   18906:	5f 91       	pop	r21
   18908:	4f 91       	pop	r20
	               "pop r20" "\n\t"
	               ::);
   return blockinfo; 
   1890a:	8b 81       	ldd	r24, Y+3	; 0x03
   1890c:	9c 81       	ldd	r25, Y+4	; 0x04
   1890e:	24 96       	adiw	r28, 0x04	; 4
   18910:	0f b6       	in	r0, 0x3f	; 63
   18912:	f8 94       	cli
   18914:	de bf       	out	0x3e, r29	; 62
   18916:	0f be       	out	0x3f, r0	; 63
   18918:	cd bf       	out	0x3d, r28	; 61
   1891a:	df 91       	pop	r29
   1891c:	cf 91       	pop	r28
   1891e:	08 95       	ret

00018920 <createThread>:
}





void createThread(void (*fp)(), uint8_t* ram_start, uint8_t *stack_ptr, uint8_t priority, char *threadname)
{
   18920:	0f 93       	push	r16
   18922:	1f 93       	push	r17
   18924:	cf 93       	push	r28
   18926:	df 93       	push	r29
   18928:	cd b7       	in	r28, 0x3d	; 61
   1892a:	de b7       	in	r29, 0x3e	; 62
   1892c:	2f 97       	sbiw	r28, 0x0f	; 15
   1892e:	0f b6       	in	r0, 0x3f	; 63
   18930:	f8 94       	cli
   18932:	de bf       	out	0x3e, r29	; 62
   18934:	0f be       	out	0x3f, r0	; 63
   18936:	cd bf       	out	0x3d, r28	; 61
   18938:	98 87       	std	Y+8, r25	; 0x08
   1893a:	8f 83       	std	Y+7, r24	; 0x07
   1893c:	7a 87       	std	Y+10, r23	; 0x0a
   1893e:	69 87       	std	Y+9, r22	; 0x09
   18940:	5c 87       	std	Y+12, r21	; 0x0c
   18942:	4b 87       	std	Y+11, r20	; 0x0b
   18944:	2d 87       	std	Y+13, r18	; 0x0d
   18946:	1f 87       	std	Y+15, r17	; 0x0f
   18948:	0e 87       	std	Y+14, r16	; 0x0e
 
 
   mutex* createthreadmutex; 
   thread_create_block_type *threadblock;
   void (*getaddrfp)(void) = (void (*)(void))CREATE_THERAD_SYSCALL;
   1894a:	8c ed       	ldi	r24, 0xDC	; 220
   1894c:	9a ee       	ldi	r25, 0xEA	; 234
   1894e:	9a 83       	std	Y+2, r25	; 0x02
   18950:	89 83       	std	Y+1, r24	; 0x01

  
   threadblock = getCurrentThreadControlBlockAddr(); 
   18952:	0e 94 48 c4 	call	0x18890
   18956:	9c 83       	std	Y+4, r25	; 0x04
   18958:	8b 83       	std	Y+3, r24	; 0x03
   createthreadmutex = (mutex *)getCurrentThreadControlMutexAddr(); 
   1895a:	0e 94 6c c4 	call	0x188d8
   1895e:	9e 83       	std	Y+6, r25	; 0x06
   18960:	8d 83       	std	Y+5, r24	; 0x05
   
   Mutex_lock(createthreadmutex);
   18962:	8d 81       	ldd	r24, Y+5	; 0x05
   18964:	9e 81       	ldd	r25, Y+6	; 0x06
   18966:	0e 94 0c bb 	call	0x17618
     
   threadblock-> fp = fp; 
   1896a:	eb 81       	ldd	r30, Y+3	; 0x03
   1896c:	fc 81       	ldd	r31, Y+4	; 0x04
   1896e:	8f 81       	ldd	r24, Y+7	; 0x07
   18970:	98 85       	ldd	r25, Y+8	; 0x08
   18972:	91 83       	std	Z+1, r25	; 0x01
   18974:	80 83       	st	Z, r24
   threadblock->ram_start = ram_start; 
   18976:	eb 81       	ldd	r30, Y+3	; 0x03
   18978:	fc 81       	ldd	r31, Y+4	; 0x04
   1897a:	89 85       	ldd	r24, Y+9	; 0x09
   1897c:	9a 85       	ldd	r25, Y+10	; 0x0a
   1897e:	93 83       	std	Z+3, r25	; 0x03
   18980:	82 83       	std	Z+2, r24	; 0x02
   threadblock->stack_ptr = stack_ptr; 
   18982:	eb 81       	ldd	r30, Y+3	; 0x03
   18984:	fc 81       	ldd	r31, Y+4	; 0x04
   18986:	8b 85       	ldd	r24, Y+11	; 0x0b
   18988:	9c 85       	ldd	r25, Y+12	; 0x0c
   1898a:	95 83       	std	Z+5, r25	; 0x05
   1898c:	84 83       	std	Z+4, r24	; 0x04
   threadblock->priority = priority;
   1898e:	eb 81       	ldd	r30, Y+3	; 0x03
   18990:	fc 81       	ldd	r31, Y+4	; 0x04
   18992:	8d 85       	ldd	r24, Y+13	; 0x0d
   18994:	86 83       	std	Z+6, r24	; 0x06
   threadblock->threadname = threadname; 
   18996:	eb 81       	ldd	r30, Y+3	; 0x03
   18998:	fc 81       	ldd	r31, Y+4	; 0x04
   1899a:	8e 85       	ldd	r24, Y+14	; 0x0e
   1899c:	9f 85       	ldd	r25, Y+15	; 0x0f
   1899e:	90 87       	std	Z+8, r25	; 0x08
   189a0:	87 83       	std	Z+7, r24	; 0x07

   getaddrfp(); 
   189a2:	e9 81       	ldd	r30, Y+1	; 0x01
   189a4:	fa 81       	ldd	r31, Y+2	; 0x02
   189a6:	09 95       	icall
   
   sleepThread(20); 
   189a8:	84 e1       	ldi	r24, 0x14	; 20
   189aa:	90 e0       	ldi	r25, 0x00	; 0
   189ac:	0e 94 1b c3 	call	0x18636
   
  
   Mutex_unlock(createthreadmutex); 
   189b0:	8d 81       	ldd	r24, Y+5	; 0x05
   189b2:	9e 81       	ldd	r25, Y+6	; 0x06
   189b4:	0e 94 5b bb 	call	0x176b6
   189b8:	2f 96       	adiw	r28, 0x0f	; 15
   189ba:	0f b6       	in	r0, 0x3f	; 63
   189bc:	f8 94       	cli
   189be:	de bf       	out	0x3e, r29	; 62
   189c0:	0f be       	out	0x3f, r0	; 63
   189c2:	cd bf       	out	0x3d, r28	; 61
   189c4:	df 91       	pop	r29
   189c6:	cf 91       	pop	r28
   189c8:	1f 91       	pop	r17
   189ca:	0f 91       	pop	r16
   189cc:	08 95       	ret

000189ce <setThreadTerminateHandler>:

   return; 
}




void setThreadTerminateHandler(void (*tp) (void))
{
   189ce:	cf 93       	push	r28
   189d0:	df 93       	push	r29
   189d2:	cd b7       	in	r28, 0x3d	; 61
   189d4:	de b7       	in	r29, 0x3e	; 62
   189d6:	24 97       	sbiw	r28, 0x04	; 4
   189d8:	0f b6       	in	r0, 0x3f	; 63
   189da:	f8 94       	cli
   189dc:	de bf       	out	0x3e, r29	; 62
   189de:	0f be       	out	0x3f, r0	; 63
   189e0:	cd bf       	out	0x3d, r28	; 61
   189e2:	9c 83       	std	Y+4, r25	; 0x04
   189e4:	8b 83       	std	Y+3, r24	; 0x03
   void (*fp)(void) = (void (*)(void))SYSCALL_USER_THREAD_TERMINATE_TASK; 
   189e6:	80 e0       	ldi	r24, 0x00	; 0
   189e8:	9b ee       	ldi	r25, 0xEB	; 235
   189ea:	9a 83       	std	Y+2, r25	; 0x02
   189ec:	89 83       	std	Y+1, r24	; 0x01
   asm volatile("push r20" "\n\t"
   189ee:	4f 93       	push	r20
   189f0:	5f 93       	push	r21
                "push r21" "\n\t"
				        ::);
   
   asm volatile(" mov r20, %A0" "\n\t"
   189f2:	8b 81       	ldd	r24, Y+3	; 0x03
   189f4:	9c 81       	ldd	r25, Y+4	; 0x04
   189f6:	48 2f       	mov	r20, r24
   189f8:	59 2f       	mov	r21, r25
	             "mov r21, %B0" "\n\t"
				 :
				 :"r" (tp)
                );


  fp(); 
   189fa:	e9 81       	ldd	r30, Y+1	; 0x01
   189fc:	fa 81       	ldd	r31, Y+2	; 0x02
   189fe:	09 95       	icall

  asm volatile("pop r21" "\n\t"
   18a00:	5f 91       	pop	r21
   18a02:	4f 91       	pop	r20
   18a04:	24 96       	adiw	r28, 0x04	; 4
   18a06:	0f b6       	in	r0, 0x3f	; 63
   18a08:	f8 94       	cli
   18a0a:	de bf       	out	0x3e, r29	; 62
   18a0c:	0f be       	out	0x3f, r0	; 63
   18a0e:	cd bf       	out	0x3d, r28	; 61
   18a10:	df 91       	pop	r29
   18a12:	cf 91       	pop	r28
   18a14:	08 95       	ret

00018a16 <setTimerFunction>:
	             "pop r20" "\n\t"
	             ::);

  return; 


}


void setTimerFunction(uint16_t period, uint8_t type, void (*callback)(void))
{
   18a16:	cf 93       	push	r28
   18a18:	df 93       	push	r29
   18a1a:	cd b7       	in	r28, 0x3d	; 61
   18a1c:	de b7       	in	r29, 0x3e	; 62
   18a1e:	29 97       	sbiw	r28, 0x09	; 9
   18a20:	0f b6       	in	r0, 0x3f	; 63
   18a22:	f8 94       	cli
   18a24:	de bf       	out	0x3e, r29	; 62
   18a26:	0f be       	out	0x3f, r0	; 63
   18a28:	cd bf       	out	0x3d, r28	; 61
   18a2a:	9e 83       	std	Y+6, r25	; 0x06
   18a2c:	8d 83       	std	Y+5, r24	; 0x05
   18a2e:	6f 83       	std	Y+7, r22	; 0x07
   18a30:	59 87       	std	Y+9, r21	; 0x09
   18a32:	48 87       	std	Y+8, r20	; 0x08
	
	 void (*fp)(void) = (void (*)(void))SYSCALL_TIMER_FIRE_TASK; 
   18a34:	84 e0       	ldi	r24, 0x04	; 4
   18a36:	9b ee       	ldi	r25, 0xEB	; 235
   18a38:	9c 83       	std	Y+4, r25	; 0x04
   18a3a:	8b 83       	std	Y+3, r24	; 0x03
 	 uint16_t type16; 

   type16 = type; 
   18a3c:	8f 81       	ldd	r24, Y+7	; 0x07
   18a3e:	99 27       	eor	r25, r25
   18a40:	9a 83       	std	Y+2, r25	; 0x02
   18a42:	89 83       	std	Y+1, r24	; 0x01
   
   asm volatile("push r18" "\n\t"
   18a44:	2f 93       	push	r18
   18a46:	3f 93       	push	r19
   18a48:	4f 93       	push	r20
   18a4a:	5f 93       	push	r21
   18a4c:	6f 93       	push	r22
   18a4e:	7f 93       	push	r23
                "push r19" "\n\t"
								"push r20" "\n\t"
								"push r21" "\n\t"
								"push r22" "\n\t"
								"push r23" "\n\t"								
                ::);
   
   asm volatile(" mov r18, %A0" "\n\t"
   18a50:	8d 81       	ldd	r24, Y+5	; 0x05
   18a52:	9e 81       	ldd	r25, Y+6	; 0x06
   18a54:	28 2f       	mov	r18, r24
   18a56:	39 2f       	mov	r19, r25
	               "mov r19, %B0" "\n\t"
				 :
				 :"r" (period)
                );



   asm volatile(" mov r20, %A0" "\n\t"
   18a58:	89 81       	ldd	r24, Y+1	; 0x01
   18a5a:	9a 81       	ldd	r25, Y+2	; 0x02
   18a5c:	48 2f       	mov	r20, r24
   18a5e:	59 2f       	mov	r21, r25
	               "mov r21, %B0" "\n\t"
				 :
				 :"r" (type16)
                );


   asm volatile(" mov r22, %A0" "\n\t"
   18a60:	88 85       	ldd	r24, Y+8	; 0x08
   18a62:	99 85       	ldd	r25, Y+9	; 0x09
   18a64:	68 2f       	mov	r22, r24
   18a66:	79 2f       	mov	r23, r25
	              " mov r23, %B0" "\n\t"
				 :
				 :"r" (callback)
                );

  fp(); 
   18a68:	eb 81       	ldd	r30, Y+3	; 0x03
   18a6a:	fc 81       	ldd	r31, Y+4	; 0x04
   18a6c:	09 95       	icall

  asm volatile("pop r23" "\n\t"
   18a6e:	7f 91       	pop	r23
   18a70:	6f 91       	pop	r22
	             "pop r22" "\n\t"
	              ::);

  asm volatile("pop r21" "\n\t"
   18a72:	5f 91       	pop	r21
   18a74:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
	              	
	asm volatile("pop r19" "\n\t"
   18a76:	3f 91       	pop	r19
   18a78:	2f 91       	pop	r18
   18a7a:	29 96       	adiw	r28, 0x09	; 9
   18a7c:	0f b6       	in	r0, 0x3f	; 63
   18a7e:	f8 94       	cli
   18a80:	de bf       	out	0x3e, r29	; 62
   18a82:	0f be       	out	0x3f, r0	; 63
   18a84:	cd bf       	out	0x3d, r28	; 61
   18a86:	df 91       	pop	r29
   18a88:	cf 91       	pop	r28
   18a8a:	08 95       	ret

00018a8c <__divmodhi4>:
   18a8c:	97 fb       	bst	r25, 7
   18a8e:	09 2e       	mov	r0, r25
   18a90:	07 26       	eor	r0, r23
   18a92:	0a d0       	rcall	.+20     	; 0x18aa8
   18a94:	77 fd       	sbrc	r23, 7
   18a96:	04 d0       	rcall	.+8      	; 0x18aa0
   18a98:	0c d0       	rcall	.+24     	; 0x18ab2
   18a9a:	06 d0       	rcall	.+12     	; 0x18aa8
   18a9c:	00 20       	and	r0, r0
   18a9e:	1a f4       	brpl	.+6      	; 0x18aa6

00018aa0 <__divmodhi4_neg2>:
   18aa0:	70 95       	com	r23
   18aa2:	61 95       	neg	r22
   18aa4:	7f 4f       	sbci	r23, 0xFF	; 255

00018aa6 <__divmodhi4_exit>:
   18aa6:	08 95       	ret

00018aa8 <__divmodhi4_neg1>:
   18aa8:	f6 f7       	brtc	.-4      	; 0x18aa6
   18aaa:	90 95       	com	r25
   18aac:	81 95       	neg	r24
   18aae:	9f 4f       	sbci	r25, 0xFF	; 255
   18ab0:	08 95       	ret

00018ab2 <__udivmodhi4>:
   18ab2:	aa 1b       	sub	r26, r26
   18ab4:	bb 1b       	sub	r27, r27
   18ab6:	51 e1       	ldi	r21, 0x11	; 17
   18ab8:	07 c0       	rjmp	.+14     	; 0x18ac8

00018aba <__udivmodhi4_loop>:
   18aba:	aa 1f       	adc	r26, r26
   18abc:	bb 1f       	adc	r27, r27
   18abe:	a6 17       	cp	r26, r22
   18ac0:	b7 07       	cpc	r27, r23
   18ac2:	10 f0       	brcs	.+4      	; 0x18ac8
   18ac4:	a6 1b       	sub	r26, r22
   18ac6:	b7 0b       	sbc	r27, r23

00018ac8 <__udivmodhi4_ep>:
   18ac8:	88 1f       	adc	r24, r24
   18aca:	99 1f       	adc	r25, r25
   18acc:	5a 95       	dec	r21
   18ace:	a9 f7       	brne	.-22     	; 0x18aba
   18ad0:	80 95       	com	r24
   18ad2:	90 95       	com	r25
   18ad4:	bc 01       	movw	r22, r24
   18ad6:	cd 01       	movw	r24, r26
   18ad8:	08 95       	ret
