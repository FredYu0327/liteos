
TestBlink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000238  00014000  00014000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000006  00800af0  00800af0  000002ac  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  000002ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  000006b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  00000738  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  00000758  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001514  00000000  00000000  00000773  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000277  00000000  00000000  00001c87  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000345  00000000  00000000  00001efe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000080  00000000  00000000  00002243  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003c4  00000000  00000000  000022c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000098  00000000  00000000  00002687  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  0000271f  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00014000 <__vectors>:
   14000:	0c 94 46 a0 	jmp	0x1408c
   14004:	0c 94 63 a0 	jmp	0x140c6
   14008:	0c 94 63 a0 	jmp	0x140c6
   1400c:	0c 94 63 a0 	jmp	0x140c6
   14010:	0c 94 63 a0 	jmp	0x140c6
   14014:	0c 94 63 a0 	jmp	0x140c6
   14018:	0c 94 63 a0 	jmp	0x140c6
   1401c:	0c 94 63 a0 	jmp	0x140c6
   14020:	0c 94 63 a0 	jmp	0x140c6
   14024:	0c 94 63 a0 	jmp	0x140c6
   14028:	0c 94 63 a0 	jmp	0x140c6
   1402c:	0c 94 63 a0 	jmp	0x140c6
   14030:	0c 94 63 a0 	jmp	0x140c6
   14034:	0c 94 63 a0 	jmp	0x140c6
   14038:	0c 94 63 a0 	jmp	0x140c6
   1403c:	0c 94 63 a0 	jmp	0x140c6
   14040:	0c 94 63 a0 	jmp	0x140c6
   14044:	0c 94 63 a0 	jmp	0x140c6
   14048:	0c 94 63 a0 	jmp	0x140c6
   1404c:	0c 94 63 a0 	jmp	0x140c6
   14050:	0c 94 63 a0 	jmp	0x140c6
   14054:	0c 94 63 a0 	jmp	0x140c6
   14058:	0c 94 63 a0 	jmp	0x140c6
   1405c:	0c 94 63 a0 	jmp	0x140c6
   14060:	0c 94 63 a0 	jmp	0x140c6
   14064:	0c 94 63 a0 	jmp	0x140c6
   14068:	0c 94 63 a0 	jmp	0x140c6
   1406c:	0c 94 63 a0 	jmp	0x140c6
   14070:	0c 94 63 a0 	jmp	0x140c6
   14074:	0c 94 63 a0 	jmp	0x140c6
   14078:	0c 94 63 a0 	jmp	0x140c6
   1407c:	0c 94 63 a0 	jmp	0x140c6
   14080:	0c 94 63 a0 	jmp	0x140c6
   14084:	0c 94 63 a0 	jmp	0x140c6
   14088:	0c 94 63 a0 	jmp	0x140c6

0001408c <__ctors_end>:
   1408c:	11 24       	eor	r1, r1
   1408e:	1f be       	out	0x3f, r1	; 63
   14090:	c0 ef       	ldi	r28, 0xF0	; 240
   14092:	dc e0       	ldi	r29, 0x0C	; 12
   14094:	de bf       	out	0x3e, r29	; 62
   14096:	cd bf       	out	0x3d, r28	; 61

00014098 <__do_copy_data>:
   14098:	1a e0       	ldi	r17, 0x0A	; 10
   1409a:	a0 ef       	ldi	r26, 0xF0	; 240
   1409c:	ba e0       	ldi	r27, 0x0A	; 10
   1409e:	e8 e3       	ldi	r30, 0x38	; 56
   140a0:	f2 e4       	ldi	r31, 0x42	; 66
   140a2:	01 e0       	ldi	r16, 0x01	; 1
   140a4:	0b bf       	out	0x3b, r16	; 59
   140a6:	02 c0       	rjmp	.+4      	; 0x140ac
   140a8:	07 90       	elpm	r0, Z+
   140aa:	0d 92       	st	X+, r0
   140ac:	a0 3f       	cpi	r26, 0xF0	; 240
   140ae:	b1 07       	cpc	r27, r17
   140b0:	d9 f7       	brne	.-10     	; 0x140a8

000140b2 <__do_clear_bss>:
   140b2:	1a e0       	ldi	r17, 0x0A	; 10
   140b4:	a0 ef       	ldi	r26, 0xF0	; 240
   140b6:	ba e0       	ldi	r27, 0x0A	; 10
   140b8:	01 c0       	rjmp	.+2      	; 0x140bc

000140ba <.do_clear_bss_loop>:
   140ba:	1d 92       	st	X+, r1

000140bc <.do_clear_bss_start>:
   140bc:	a6 3f       	cpi	r26, 0xF6	; 246
   140be:	b1 07       	cpc	r27, r17
   140c0:	e1 f7       	brne	.-8      	; 0x140ba
   140c2:	0c 94 94 a0 	jmp	0x14128

000140c6 <__bad_interrupt>:
   140c6:	0c 94 00 a0 	jmp	0x14000

000140ca <getCurrentThread.1394>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 
   asm volatile("push r20" "\n\t"
   140ca:	4f 93       	push	r20
   140cc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   140ce:	ec e0       	ldi	r30, 0x0C	; 12
   140d0:	fa ee       	ldi	r31, 0xEA	; 234
   140d2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   140d4:	84 2f       	mov	r24, r20
   140d6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   140d8:	5f 91       	pop	r21
   140da:	4f 91       	pop	r20
   140dc:	08 95       	ret

000140de <yield.1393>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADINDEXFUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELDFUNCTION; 
 yieldfp();                              
   140de:	e0 e0       	ldi	r30, 0x00	; 0
   140e0:	fa ee       	ldi	r31, 0xEA	; 234
   140e2:	09 95       	icall
   140e4:	08 95       	ret

000140e6 <sleepThread.1392>:
   140e6:	0f 93       	push	r16
   140e8:	1f 93       	push	r17
   140ea:	8c 01       	movw	r16, r24
   140ec:	0e 94 65 a0 	call	0x140ca
   140f0:	dc 01       	movw	r26, r24
   140f2:	ed 91       	ld	r30, X+
   140f4:	fc 91       	ld	r31, X
   140f6:	11 97       	sbiw	r26, 0x01	; 1
   140f8:	84 e0       	ldi	r24, 0x04	; 4
   140fa:	82 83       	std	Z+2, r24	; 0x02
   140fc:	ed 91       	ld	r30, X+
   140fe:	fc 91       	ld	r31, X
   14100:	10 8f       	std	Z+24, r17	; 0x18
   14102:	07 8b       	std	Z+23, r16	; 0x17
   14104:	0e 94 6f a0 	call	0x140de
   14108:	1f 91       	pop	r17
   1410a:	0f 91       	pop	r16
   1410c:	08 95       	ret

0001410e <syscall_postThreadTask.1400>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POSTTHREADTASK; 
 postthreadfp();                              
   1410e:	e8 e6       	ldi	r30, 0x68	; 104
   14110:	fa ee       	ldi	r31, 0xEA	; 234
   14112:	09 95       	icall
   14114:	08 95       	ret

00014116 <wakeupMeSerial.1714>:
//wakeup the current thread once an incoming packet arrives 

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE; 
   14116:	e0 91 f2 0a 	lds	r30, 0x0AF2
   1411a:	f0 91 f3 0a 	lds	r31, 0x0AF3
   1411e:	82 e0       	ldi	r24, 0x02	; 2
   14120:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14122:	0e 94 87 a0 	call	0x1410e
   14126:	08 95       	ret

00014128 <main>:
uint16_t reading;


int main()
{ 
   14128:	bf 92       	push	r11
   1412a:	cf 92       	push	r12
   1412c:	df 92       	push	r13
   1412e:	ef 92       	push	r14
   14130:	ff 92       	push	r15
   14132:	0f 93       	push	r16
   14134:	1f 93       	push	r17
   14136:	cf 93       	push	r28
   14138:	df 93       	push	r29

   __asm__ __volatile__("sei" ::);
   1413a:	78 94       	sei
  
   
   
   while (1)
   {
   	  sleepThread(125);
   1413c:	8d e7       	ldi	r24, 0x7D	; 125
   1413e:	90 e0       	ldi	r25, 0x00	; 0
   14140:	0e 94 73 a0 	call	0x140e6
int get_light()
{
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADCLIGHT;
   current_thread = getCurrentThread();    
   14144:	0e 94 65 a0 	call	0x140ca
   14148:	8c 01       	movw	r16, r24
   fp(); 
   1414a:	e0 e4       	ldi	r30, 0x40	; 64
   1414c:	fa ee       	ldi	r31, 0xEA	; 234
   1414e:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   14150:	d8 01       	movw	r26, r16
   14152:	ed 91       	ld	r30, X+
   14154:	fc 91       	ld	r31, X
   14156:	87 89       	ldd	r24, Z+23	; 0x17
   14158:	90 8d       	ldd	r25, Z+24	; 0x18
      reading = get_light(); 
   1415a:	90 93 f1 0a 	sts	0x0AF1, r25
   1415e:	80 93 f0 0a 	sts	0x0AF0, r24
mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GETRADIOMUTEXFUNCTION; 
   asm volatile("push r20" "\n\t"
   14162:	4f 93       	push	r20
   14164:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   14166:	e0 e1       	ldi	r30, 0x10	; 16
   14168:	fa ee       	ldi	r31, 0xEA	; 234
   1416a:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   1416c:	c4 2f       	mov	r28, r20
   1416e:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   14170:	5f 91       	pop	r21
   14172:	4f 91       	pop	r20

  
   
   msend = getRadioMutexAddress();   
   current_thread = getCurrentThread(); 
   14174:	0e 94 65 a0 	call	0x140ca
   14178:	4f 93       	push	r20
   1417a:	5f 93       	push	r21
   1417c:	ec e5       	ldi	r30, 0x5C	; 92
   1417e:	fa ee       	ldi	r31, 0xEA	; 234
   14180:	09 95       	icall
   14182:	04 2f       	mov	r16, r20
   14184:	15 2f       	mov	r17, r21
   14186:	5f 91       	pop	r21
   14188:	4f 91       	pop	r20
   1418a:	0e 94 65 a0 	call	0x140ca
   1418e:	7c 01       	movw	r14, r24
   14190:	4f 93       	push	r20
   14192:	5f 93       	push	r21
   14194:	ec e1       	ldi	r30, 0x1C	; 28
   14196:	fa ee       	ldi	r31, 0xEA	; 234
   14198:	09 95       	icall
   1419a:	c4 2e       	mov	r12, r20
   1419c:	d5 2e       	mov	r13, r21
   1419e:	5f 91       	pop	r21
   141a0:	4f 91       	pop	r20


_atomic_t _atomic_start(void) 
{
  _atomic_t result = SREG;
   141a2:	bf b6       	in	r11, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
   141a4:	f8 94       	cli
   141a6:	88 81       	ld	r24, Y
   141a8:	88 23       	and	r24, r24
   141aa:	91 f0       	breq	.+36     	; 0x141d0
   141ac:	d7 01       	movw	r26, r14
   141ae:	ed 91       	ld	r30, X+
   141b0:	fc 91       	ld	r31, X
   141b2:	11 97       	sbiw	r26, 0x01	; 1
   141b4:	83 e0       	ldi	r24, 0x03	; 3
   141b6:	82 83       	std	Z+2, r24	; 0x02
   141b8:	ed 91       	ld	r30, X+
   141ba:	fc 91       	ld	r31, X
   141bc:	d0 8f       	std	Z+24, r29	; 0x18
   141be:	c7 8b       	std	Z+23, r28	; 0x17
   141c0:	89 81       	ldd	r24, Y+1	; 0x01
   141c2:	8f 5f       	subi	r24, 0xFF	; 255
   141c4:	89 83       	std	Y+1, r24	; 0x01
   141c6:	0e 94 6f a0 	call	0x140de
   141ca:	89 81       	ldd	r24, Y+1	; 0x01
   141cc:	81 50       	subi	r24, 0x01	; 1
   141ce:	89 83       	std	Y+1, r24	; 0x01
   141d0:	81 e0       	ldi	r24, 0x01	; 1
   141d2:	88 83       	st	Y, r24
   141d4:	8c 2d       	mov	r24, r12
   141d6:	99 27       	eor	r25, r25
   141d8:	8a 83       	std	Y+2, r24	; 0x02
   141da:	8b 2d       	mov	r24, r11
   141dc:	99 27       	eor	r25, r25
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg; 
   141de:	8f bf       	out	0x3f, r24	; 63
   radioinfoaddr = getCurrentRadioInfo();

   Mutex_lock(msend);
     
   radioinfoaddr-> socket_port = port; 
   141e0:	81 e0       	ldi	r24, 0x01	; 1
   141e2:	90 e0       	ldi	r25, 0x00	; 0
   141e4:	f8 01       	movw	r30, r16
   141e6:	91 83       	std	Z+1, r25	; 0x01
   141e8:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address; 
   141ea:	8f ef       	ldi	r24, 0xFF	; 255
   141ec:	9f ef       	ldi	r25, 0xFF	; 255
   141ee:	93 83       	std	Z+3, r25	; 0x03
   141f0:	82 83       	std	Z+2, r24	; 0x02
   radioinfoaddr->socket_msg_len  = length; 
   141f2:	82 e0       	ldi	r24, 0x02	; 2
   141f4:	84 83       	std	Z+4, r24	; 0x04
   radioinfoaddr->socket_msg  = msg;
   141f6:	80 ef       	ldi	r24, 0xF0	; 240
   141f8:	9a e0       	ldi	r25, 0x0A	; 10
   141fa:	96 83       	std	Z+6, r25	; 0x06
   141fc:	85 83       	std	Z+5, r24	; 0x05
   141fe:	e4 e1       	ldi	r30, 0x14	; 20
   14200:	fa ee       	ldi	r31, 0xEA	; 234
   14202:	09 95       	icall
    
   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg(); 

   sleepThread(30); 
   14204:	8e e1       	ldi	r24, 0x1E	; 30
   14206:	90 e0       	ldi	r25, 0x00	; 0
   14208:	0e 94 73 a0 	call	0x140e6
   1420c:	e8 eb       	ldi	r30, 0xB8	; 184
   1420e:	fa ee       	ldi	r31, 0xEA	; 234
   14210:	09 95       	icall
   14212:	4f 93       	push	r20
   14214:	5f 93       	push	r21
   14216:	4c 2f       	mov	r20, r28
   14218:	5d 2f       	mov	r21, r29
   1421a:	e8 e1       	ldi	r30, 0x18	; 24
   1421c:	fa ee       	ldi	r31, 0xEA	; 234
   1421e:	09 95       	icall
   14220:	5f 91       	pop	r21
   14222:	4f 91       	pop	r20
   14224:	8b cf       	rjmp	.-234    	; 0x1413c

00014226 <wakeupMe.3240>:
   
   disableRadioState();

  
   Mutex_unlock(msend); 

   return; 
}



//wakeup the current thread once an incoming packet arrives 

void wakeupMe()
{
  mythread->state = STATE_ACTIVE; 
   14226:	e0 91 f4 0a 	lds	r30, 0x0AF4
   1422a:	f0 91 f5 0a 	lds	r31, 0x0AF5
   1422e:	82 e0       	ldi	r24, 0x02	; 2
   14230:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14232:	0e 94 87 a0 	call	0x1410e
   14236:	08 95       	ret
