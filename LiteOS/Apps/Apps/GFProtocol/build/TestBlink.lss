
TestBlink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000550  00013800  00013800  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          0000007f  00800af0  00800af0  000005c4  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  000005c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  000009cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  00000a50  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  00000a70  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001a57  00000000  00000000  00000a8b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002d1  00000000  00000000  000024e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000061c  00000000  00000000  000027b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000c0  00000000  00000000  00002dcf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005f2  00000000  00000000  00002e8f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000002db  00000000  00000000  00003481  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00013800 <__vectors>:
   13800:	0c 94 46 9c 	jmp	0x1388c
   13804:	0c 94 63 9c 	jmp	0x138c6
   13808:	0c 94 63 9c 	jmp	0x138c6
   1380c:	0c 94 63 9c 	jmp	0x138c6
   13810:	0c 94 63 9c 	jmp	0x138c6
   13814:	0c 94 63 9c 	jmp	0x138c6
   13818:	0c 94 63 9c 	jmp	0x138c6
   1381c:	0c 94 63 9c 	jmp	0x138c6
   13820:	0c 94 63 9c 	jmp	0x138c6
   13824:	0c 94 63 9c 	jmp	0x138c6
   13828:	0c 94 63 9c 	jmp	0x138c6
   1382c:	0c 94 63 9c 	jmp	0x138c6
   13830:	0c 94 63 9c 	jmp	0x138c6
   13834:	0c 94 63 9c 	jmp	0x138c6
   13838:	0c 94 63 9c 	jmp	0x138c6
   1383c:	0c 94 63 9c 	jmp	0x138c6
   13840:	0c 94 63 9c 	jmp	0x138c6
   13844:	0c 94 63 9c 	jmp	0x138c6
   13848:	0c 94 63 9c 	jmp	0x138c6
   1384c:	0c 94 63 9c 	jmp	0x138c6
   13850:	0c 94 63 9c 	jmp	0x138c6
   13854:	0c 94 63 9c 	jmp	0x138c6
   13858:	0c 94 63 9c 	jmp	0x138c6
   1385c:	0c 94 63 9c 	jmp	0x138c6
   13860:	0c 94 63 9c 	jmp	0x138c6
   13864:	0c 94 63 9c 	jmp	0x138c6
   13868:	0c 94 63 9c 	jmp	0x138c6
   1386c:	0c 94 63 9c 	jmp	0x138c6
   13870:	0c 94 63 9c 	jmp	0x138c6
   13874:	0c 94 63 9c 	jmp	0x138c6
   13878:	0c 94 63 9c 	jmp	0x138c6
   1387c:	0c 94 63 9c 	jmp	0x138c6
   13880:	0c 94 63 9c 	jmp	0x138c6
   13884:	0c 94 63 9c 	jmp	0x138c6
   13888:	0c 94 63 9c 	jmp	0x138c6

0001388c <__ctors_end>:
   1388c:	11 24       	eor	r1, r1
   1388e:	1f be       	out	0x3f, r1	; 63
   13890:	c0 ef       	ldi	r28, 0xF0	; 240
   13892:	dc e0       	ldi	r29, 0x0C	; 12
   13894:	de bf       	out	0x3e, r29	; 62
   13896:	cd bf       	out	0x3d, r28	; 61

00013898 <__do_copy_data>:
   13898:	1a e0       	ldi	r17, 0x0A	; 10
   1389a:	a0 ef       	ldi	r26, 0xF0	; 240
   1389c:	ba e0       	ldi	r27, 0x0A	; 10
   1389e:	e0 e5       	ldi	r30, 0x50	; 80
   138a0:	fd e3       	ldi	r31, 0x3D	; 61
   138a2:	01 e0       	ldi	r16, 0x01	; 1
   138a4:	0b bf       	out	0x3b, r16	; 59
   138a6:	02 c0       	rjmp	.+4      	; 0x138ac
   138a8:	07 90       	elpm	r0, Z+
   138aa:	0d 92       	st	X+, r0
   138ac:	a0 3f       	cpi	r26, 0xF0	; 240
   138ae:	b1 07       	cpc	r27, r17
   138b0:	d9 f7       	brne	.-10     	; 0x138a8

000138b2 <__do_clear_bss>:
   138b2:	1b e0       	ldi	r17, 0x0B	; 11
   138b4:	a0 ef       	ldi	r26, 0xF0	; 240
   138b6:	ba e0       	ldi	r27, 0x0A	; 10
   138b8:	01 c0       	rjmp	.+2      	; 0x138bc

000138ba <.do_clear_bss_loop>:
   138ba:	1d 92       	st	X+, r1

000138bc <.do_clear_bss_start>:
   138bc:	af 36       	cpi	r26, 0x6F	; 111
   138be:	b1 07       	cpc	r27, r17
   138c0:	e1 f7       	brne	.-8      	; 0x138ba
   138c2:	0c 94 69 9d 	jmp	0x13ad2

000138c6 <__bad_interrupt>:
   138c6:	0c 94 00 9c 	jmp	0x13800

000138ca <wakeupMeOnNbrMsg.1529>:

void wakeupMeOnNbrMsg() {
   int i;
   uint8_t neighbornodeid; 
   for ( i = 0; i < numOfNeighbors; i ++ ) {
   138ca:	a0 91 6a 0b 	lds	r26, 0x0B6A
   138ce:	6a 2f       	mov	r22, r26
   138d0:	77 27       	eor	r23, r23
      if (( nbtTable[ i ].valid == 1 ) && ( nbtTable[ i ].nodeid == incomingNbrMsg[ 0 ] )) {
   138d2:	80 91 39 0b 	lds	r24, 0x0B39
   138d6:	48 2f       	mov	r20, r24
   138d8:	55 27       	eor	r21, r21
   138da:	e0 ef       	ldi	r30, 0xF0	; 240
   138dc:	fa e0       	ldi	r31, 0x0A	; 10
   138de:	20 e0       	ldi	r18, 0x00	; 0
   138e0:	30 e0       	ldi	r19, 0x00	; 0
   138e2:	0b c0       	rjmp	.+22     	; 0x138fa
   138e4:	84 81       	ldd	r24, Z+4	; 0x04
   138e6:	81 30       	cpi	r24, 0x01	; 1
   138e8:	29 f4       	brne	.+10     	; 0x138f4
   138ea:	80 81       	ld	r24, Z
   138ec:	91 81       	ldd	r25, Z+1	; 0x01
   138ee:	84 17       	cp	r24, r20
   138f0:	95 07       	cpc	r25, r21
   138f2:	51 f1       	breq	.+84     	; 0x13948
   138f4:	2f 5f       	subi	r18, 0xFF	; 255
   138f6:	3f 4f       	sbci	r19, 0xFF	; 255
   138f8:	35 96       	adiw	r30, 0x05	; 5
   138fa:	26 17       	cp	r18, r22
   138fc:	37 07       	cpc	r19, r23
   138fe:	94 f3       	brlt	.-28     	; 0x138e4
         return ;
      }
   }

   neighbornodeid = incomingNbrMsg[0]; 

   if ((neighbornodeid != nodeid -1 )&&( neighbornodeid != nodeid+1))
   13900:	20 91 5e 0b 	lds	r18, 0x0B5E
   13904:	30 91 5f 0b 	lds	r19, 0x0B5F
   13908:	c9 01       	movw	r24, r18
   1390a:	01 97       	sbiw	r24, 0x01	; 1
   1390c:	48 17       	cp	r20, r24
   1390e:	59 07       	cpc	r21, r25
   13910:	29 f0       	breq	.+10     	; 0x1391c
   13912:	2f 5f       	subi	r18, 0xFF	; 255
   13914:	3f 4f       	sbci	r19, 0xFF	; 255
   13916:	42 17       	cp	r20, r18
   13918:	53 07       	cpc	r21, r19
   1391a:	b1 f4       	brne	.+44     	; 0x13948
      return; 

   nbtTable[ numOfNeighbors ].nodeid = incomingNbrMsg[ 0 ];
   1391c:	fb 01       	movw	r30, r22
   1391e:	ee 0f       	add	r30, r30
   13920:	ff 1f       	adc	r31, r31
   13922:	ee 0f       	add	r30, r30
   13924:	ff 1f       	adc	r31, r31
   13926:	e6 0f       	add	r30, r22
   13928:	f7 1f       	adc	r31, r23
   1392a:	e0 51       	subi	r30, 0x10	; 16
   1392c:	f5 4f       	sbci	r31, 0xF5	; 245
   1392e:	51 83       	std	Z+1, r21	; 0x01
   13930:	40 83       	st	Z, r20
   nbtTable[ numOfNeighbors ].local_x = incomingNbrMsg[ 1 ];
   13932:	80 91 3a 0b 	lds	r24, 0x0B3A
   13936:	82 83       	std	Z+2, r24	; 0x02
   nbtTable[ numOfNeighbors ].local_y = incomingNbrMsg[ 2 ];
   13938:	80 91 3b 0b 	lds	r24, 0x0B3B
   1393c:	83 83       	std	Z+3, r24	; 0x03
   nbtTable[ numOfNeighbors ].valid = 1;
   1393e:	81 e0       	ldi	r24, 0x01	; 1
   13940:	84 83       	std	Z+4, r24	; 0x04
   numOfNeighbors ++;
   13942:	af 5f       	subi	r26, 0xFF	; 255
   13944:	a0 93 6a 0b 	sts	0x0B6A, r26
   13948:	08 95       	ret

0001394a <getCurrentThread.1385>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 
   asm volatile("push r20" "\n\t"
   1394a:	4f 93       	push	r20
   1394c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   1394e:	ec e0       	ldi	r30, 0x0C	; 12
   13950:	fa ee       	ldi	r31, 0xEA	; 234
   13952:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   13954:	84 2f       	mov	r24, r20
   13956:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   13958:	5f 91       	pop	r21
   1395a:	4f 91       	pop	r20
   1395c:	08 95       	ret

0001395e <getCurrentRadioHandleAddr.1438>:
   radiohandletype *currentradioinfo; 

   void (*getaddrfp)(void) = (void (*)(void))GETCURRENTRADIOHANDLE; 

   asm volatile("push r20" "\n\t"
   1395e:	4f 93       	push	r20
   13960:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   13962:	e0 e6       	ldi	r30, 0x60	; 96
   13964:	fa ee       	ldi	r31, 0xEA	; 234
   13966:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   13968:	84 2f       	mov	r24, r20
   1396a:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
   1396c:	5f 91       	pop	r21
   1396e:	4f 91       	pop	r20
   13970:	08 95       	ret

00013972 <syscall_postThreadTask.1391>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADINDEXFUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELDFUNCTION; 
 yieldfp();                              
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POSTTHREADTASK; 
 postthreadfp();                              
   13972:	e8 e6       	ldi	r30, 0x68	; 104
   13974:	fa ee       	ldi	r31, 0xEA	; 234
   13976:	09 95       	icall
   13978:	08 95       	ret

0001397a <wakeupMeOnDataMsg.1514>:
   1397a:	e0 91 62 0b 	lds	r30, 0x0B62
   1397e:	f0 91 63 0b 	lds	r31, 0x0B63
   13982:	82 e0       	ldi	r24, 0x02	; 2
   13984:	82 83       	std	Z+2, r24	; 0x02
   13986:	81 e0       	ldi	r24, 0x01	; 1
   13988:	80 93 13 0b 	sts	0x0B13, r24
   1398c:	0e 94 b9 9c 	call	0x13972
   13990:	08 95       	ret

00013992 <wakeupMeSerial.1864>:
//wakeup the current thread once an incoming packet arrives 

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE; 
   13992:	e0 91 6b 0b 	lds	r30, 0x0B6B
   13996:	f0 91 6c 0b 	lds	r31, 0x0B6C
   1399a:	82 e0       	ldi	r24, 0x02	; 2
   1399c:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   1399e:	0e 94 b9 9c 	call	0x13972
   139a2:	08 95       	ret

000139a4 <yield.1384>:
   139a4:	e0 e0       	ldi	r30, 0x00	; 0
   139a6:	fa ee       	ldi	r31, 0xEA	; 234
   139a8:	09 95       	icall
   139aa:	08 95       	ret

000139ac <sleepThread.1383>:
   139ac:	0f 93       	push	r16
   139ae:	1f 93       	push	r17
   139b0:	8c 01       	movw	r16, r24
   139b2:	0e 94 a5 9c 	call	0x1394a
   139b6:	dc 01       	movw	r26, r24
   139b8:	ed 91       	ld	r30, X+
   139ba:	fc 91       	ld	r31, X
   139bc:	11 97       	sbiw	r26, 0x01	; 1
   139be:	84 e0       	ldi	r24, 0x04	; 4
   139c0:	82 83       	std	Z+2, r24	; 0x02
   139c2:	ed 91       	ld	r30, X+
   139c4:	fc 91       	ld	r31, X
   139c6:	10 8f       	std	Z+24, r17	; 0x18
   139c8:	07 8b       	std	Z+23, r16	; 0x17
   139ca:	0e 94 d2 9c 	call	0x139a4
   139ce:	1f 91       	pop	r17
   139d0:	0f 91       	pop	r16
   139d2:	08 95       	ret

000139d4 <radioSend.1443>:
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo; 
}


void setRadioFreq(uint16_t freq)
{
  
   void (*getaddrfp)(void) = (void (*)(void))SETRADIOFREQFUNCTION; 

   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
      
   asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (freq)
                );
   getaddrfp(); 
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return; 
}

void setRadioChannel(uint8_t channel)
{
  
  uint16_t maskchannel = channel; 
  
  void (*getaddrfp)(void) = (void (*)(void))SETRADIOCHANNELFUNCTION; 

  asm volatile("push r20" "\n\t"
               "push r21" "\n\t"
               ::);
      
  asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp(); 
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return; 
}

void setRadioPower(uint8_t power)
{
  
  uint16_t maskchannel = power; 
  
  void (*getaddrfp)(void) = (void (*)(void))SETRADIOPOWERFUNCTION; 

  asm volatile("push r20" "\n\t"
               "push r21" "\n\t"
               ::);
      
  asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp(); 
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return; 
}



radioinfotype *getCurrentRadioInfo()
{
   radioinfotype *currentradioinfo; 
   void (*getaddrfp)(void) = (void (*)(void))GETCURRENTRADIOINFO; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo; 
}


void disableRadioState()
{
  
   void (*disableradiofp)(void) = (void (*)(void))DISABLERADIOSTATE; 
   
   disableradiofp();     

   return;	
}


void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
   139d4:	4f 92       	push	r4
   139d6:	5f 92       	push	r5
   139d8:	6f 92       	push	r6
   139da:	7f 92       	push	r7
   139dc:	8f 92       	push	r8
   139de:	9f 92       	push	r9
   139e0:	af 92       	push	r10
   139e2:	bf 92       	push	r11
   139e4:	cf 92       	push	r12
   139e6:	df 92       	push	r13
   139e8:	ef 92       	push	r14
   139ea:	ff 92       	push	r15
   139ec:	0f 93       	push	r16
   139ee:	1f 93       	push	r17
   139f0:	cf 93       	push	r28
   139f2:	df 93       	push	r29
   139f4:	5c 01       	movw	r10, r24
   139f6:	4b 01       	movw	r8, r22
   139f8:	44 2e       	mov	r4, r20
   139fa:	39 01       	movw	r6, r18
mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GETRADIOMUTEXFUNCTION; 
   asm volatile("push r20" "\n\t"
   139fc:	4f 93       	push	r20
   139fe:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   13a00:	e0 e1       	ldi	r30, 0x10	; 16
   13a02:	fa ee       	ldi	r31, 0xEA	; 234
   13a04:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   13a06:	c4 2f       	mov	r28, r20
   13a08:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   13a0a:	5f 91       	pop	r21
   13a0c:	4f 91       	pop	r20
 
 
   mutex* msend; 
   thread** current_thread; 
   radioinfotype *radioinfoaddr; 

  
   
   msend = getRadioMutexAddress();   
   current_thread = getCurrentThread(); 
   13a0e:	0e 94 a5 9c 	call	0x1394a
   13a12:	4f 93       	push	r20
   13a14:	5f 93       	push	r21
   13a16:	ec e5       	ldi	r30, 0x5C	; 92
   13a18:	fa ee       	ldi	r31, 0xEA	; 234
   13a1a:	09 95       	icall
   13a1c:	04 2f       	mov	r16, r20
   13a1e:	15 2f       	mov	r17, r21
   13a20:	5f 91       	pop	r21
   13a22:	4f 91       	pop	r20
   13a24:	0e 94 a5 9c 	call	0x1394a
   13a28:	7c 01       	movw	r14, r24
   13a2a:	4f 93       	push	r20
   13a2c:	5f 93       	push	r21
   13a2e:	ec e1       	ldi	r30, 0x1C	; 28
   13a30:	fa ee       	ldi	r31, 0xEA	; 234
   13a32:	09 95       	icall
   13a34:	c4 2e       	mov	r12, r20
   13a36:	d5 2e       	mov	r13, r21
   13a38:	5f 91       	pop	r21
   13a3a:	4f 91       	pop	r20


_atomic_t _atomic_start(void) 
{
  _atomic_t result = SREG;
   13a3c:	5f b6       	in	r5, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
   13a3e:	f8 94       	cli
   13a40:	88 81       	ld	r24, Y
   13a42:	88 23       	and	r24, r24
   13a44:	91 f0       	breq	.+36     	; 0x13a6a
   13a46:	d7 01       	movw	r26, r14
   13a48:	ed 91       	ld	r30, X+
   13a4a:	fc 91       	ld	r31, X
   13a4c:	11 97       	sbiw	r26, 0x01	; 1
   13a4e:	83 e0       	ldi	r24, 0x03	; 3
   13a50:	82 83       	std	Z+2, r24	; 0x02
   13a52:	ed 91       	ld	r30, X+
   13a54:	fc 91       	ld	r31, X
   13a56:	d0 8f       	std	Z+24, r29	; 0x18
   13a58:	c7 8b       	std	Z+23, r28	; 0x17
   13a5a:	89 81       	ldd	r24, Y+1	; 0x01
   13a5c:	8f 5f       	subi	r24, 0xFF	; 255
   13a5e:	89 83       	std	Y+1, r24	; 0x01
   13a60:	0e 94 d2 9c 	call	0x139a4
   13a64:	89 81       	ldd	r24, Y+1	; 0x01
   13a66:	81 50       	subi	r24, 0x01	; 1
   13a68:	89 83       	std	Y+1, r24	; 0x01
   13a6a:	81 e0       	ldi	r24, 0x01	; 1
   13a6c:	88 83       	st	Y, r24
   13a6e:	8c 2d       	mov	r24, r12
   13a70:	99 27       	eor	r25, r25
   13a72:	8a 83       	std	Y+2, r24	; 0x02
   13a74:	85 2d       	mov	r24, r5
   13a76:	99 27       	eor	r25, r25
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg; 
   13a78:	8f bf       	out	0x3f, r24	; 63
   radioinfoaddr = getCurrentRadioInfo();

   Mutex_lock(msend);
     
   radioinfoaddr-> socket_port = port; 
   13a7a:	f8 01       	movw	r30, r16
   13a7c:	b1 82       	std	Z+1, r11	; 0x01
   13a7e:	a0 82       	st	Z, r10
   radioinfoaddr->socket_addr = address; 
   13a80:	93 82       	std	Z+3, r9	; 0x03
   13a82:	82 82       	std	Z+2, r8	; 0x02
   radioinfoaddr->socket_msg_len  = length; 
   13a84:	44 82       	std	Z+4, r4	; 0x04
   radioinfoaddr->socket_msg  = msg;
   13a86:	76 82       	std	Z+6, r7	; 0x06
   13a88:	65 82       	std	Z+5, r6	; 0x05
   13a8a:	e4 e1       	ldi	r30, 0x14	; 20
   13a8c:	fa ee       	ldi	r31, 0xEA	; 234
   13a8e:	09 95       	icall
    
   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg(); 

   sleepThread(30); 
   13a90:	8e e1       	ldi	r24, 0x1E	; 30
   13a92:	90 e0       	ldi	r25, 0x00	; 0
   13a94:	0e 94 d6 9c 	call	0x139ac
   13a98:	e8 eb       	ldi	r30, 0xB8	; 184
   13a9a:	fa ee       	ldi	r31, 0xEA	; 234
   13a9c:	09 95       	icall
   13a9e:	4f 93       	push	r20
   13aa0:	5f 93       	push	r21
   13aa2:	4c 2f       	mov	r20, r28
   13aa4:	5d 2f       	mov	r21, r29
   13aa6:	e8 e1       	ldi	r30, 0x18	; 24
   13aa8:	fa ee       	ldi	r31, 0xEA	; 234
   13aaa:	09 95       	icall
   13aac:	5f 91       	pop	r21
   13aae:	4f 91       	pop	r20
   13ab0:	df 91       	pop	r29
   13ab2:	cf 91       	pop	r28
   13ab4:	1f 91       	pop	r17
   13ab6:	0f 91       	pop	r16
   13ab8:	ff 90       	pop	r15
   13aba:	ef 90       	pop	r14
   13abc:	df 90       	pop	r13
   13abe:	cf 90       	pop	r12
   13ac0:	bf 90       	pop	r11
   13ac2:	af 90       	pop	r10
   13ac4:	9f 90       	pop	r9
   13ac6:	8f 90       	pop	r8
   13ac8:	7f 90       	pop	r7
   13aca:	6f 90       	pop	r6
   13acc:	5f 90       	pop	r5
   13ace:	4f 90       	pop	r4
   13ad0:	08 95       	ret

00013ad2 <main>:
   return ;
}

//-------------------------------------------------------------------------
void registerNeighborhoodPacket() {

   _atomic_t currentatomic;
   radiohandletype *radiohandleaddr;
   void (*getaddrfp)(void) = (void (*)(void))SETCURRENTRADIOHANDLE; 

   radiohandleaddr = getCurrentRadioHandleAddr(); 
   
   incomingNbrLength = 0;
   //set up the radiohandleaddr data structures
   radiohandleaddr->port = 11;
   radiohandleaddr->maxLength = 16;
   radiohandleaddr->dataReady = &incomingNbrLength;
   radiohandleaddr->data = incomingNbrMsg;
   radiohandleaddr->packetinfo = incomingNbrPacketInfo;
   radiohandleaddr->handlefunc = wakeupMeOnNbrMsg;
   //close the interrupt     
   currentatomic = _atomic_start();
   //call the radio handle set to store the data structure into the handle vectors 
   getaddrfp(); 
   //open the interrupt 
   _atomic_end( currentatomic );
   return ;
}

//-------------------------------------------------------------------------
static uint8_t nbrUpdateMsg[ 16 ];

void setNeighborMsg() {
   nbrUpdateMsg[ 0 ] = nodeid;
   nbrUpdateMsg[ 1 ] = nodeid % 256;
   nbrUpdateMsg[ 2 ] = nodeid / 256;
   return ;
}

//This is the entry point. It broadcasts neighbor exchanges perodically, or handles incoming packets (non-update neighbor)

void main() {
   13ad2:	ef 92       	push	r14
   13ad4:	ff 92       	push	r15
   13ad6:	0f 93       	push	r16
   13ad8:	1f 93       	push	r17

   uint8_t destx, desty, from, to;
   uint8_t i;
   uint16_t maxdist;
   uint8_t index;
   uint8_t portnum;

   packetsremote = packetslocal = packetsdeliver = 0;
   13ada:	10 92 69 0b 	sts	0x0B69, r1
   13ade:	10 92 68 0b 	sts	0x0B68, r1
   13ae2:	10 92 65 0b 	sts	0x0B65, r1
   13ae6:	10 92 64 0b 	sts	0x0B64, r1
   13aea:	10 92 67 0b 	sts	0x0B67, r1
   13aee:	10 92 66 0b 	sts	0x0B66, r1
   13af2:	e4 ef       	ldi	r30, 0xF4	; 244
   13af4:	fa e0       	ldi	r31, 0x0A	; 10
   13af6:	10 82       	st	Z, r1
   13af8:	35 96       	adiw	r30, 0x05	; 5
   13afa:	8b e0       	ldi	r24, 0x0B	; 11
   13afc:	e7 31       	cpi	r30, 0x17	; 23
   13afe:	f8 07       	cpc	r31, r24
   13b00:	d1 f7       	brne	.-12     	; 0x13af6
   13b02:	10 92 6a 0b 	sts	0x0B6A, r1
   13b06:	10 92 13 0b 	sts	0x0B13, r1
}



int random()
{
	
	 int ret; 
   void (*getrandomfp)(void) = (void (*)(void))GETRANDOM16FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getrandomfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	              "mov %B0, r21" "\n\t"
				 :"=r" (ret)
				 :
                );
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return ret; 
	
}



uint16_t getnodeID()
	{
		
	   int ret; 
	   void (*fp)(void) = (void (*)(void))GETNODEIDFUNCTION; 
	   asm volatile("push r20" "\n\t"
   13b0a:	4f 93       	push	r20
   13b0c:	5f 93       	push	r21
					"push r21" "\n\t"
					::);
	   fp();	  
   13b0e:	ec ec       	ldi	r30, 0xCC	; 204
   13b10:	fa ee       	ldi	r31, 0xEA	; 234
   13b12:	09 95       	icall
	   asm volatile(" mov %A0, r20" "\n\t"
   13b14:	84 2f       	mov	r24, r20
   13b16:	95 2f       	mov	r25, r21
					  "mov %B0, r21" "\n\t"
					 :"=r" (ret)
					 :
					);
	   asm volatile("pop r21" "\n\t"
   13b18:	5f 91       	pop	r21
   13b1a:	4f 91       	pop	r20

   index = 100;
   initTable();
   nodeid = getnodeID();
   13b1c:	90 93 5f 0b 	sts	0x0B5F, r25
   13b20:	80 93 5e 0b 	sts	0x0B5E, r24
   
   //register both the negibhorhood update and the message incoming 

   thiscurrentthread = getCurrentThread(); 
   13b24:	0e 94 a5 9c 	call	0x1394a
   13b28:	fc 01       	movw	r30, r24
   13b2a:	90 93 61 0b 	sts	0x0B61, r25
   13b2e:	80 93 60 0b 	sts	0x0B60, r24
   currentthread = *thiscurrentthread; 
   13b32:	80 81       	ld	r24, Z
   13b34:	91 81       	ldd	r25, Z+1	; 0x01
   13b36:	90 93 63 0b 	sts	0x0B63, r25
   13b3a:	80 93 62 0b 	sts	0x0B62, r24
   13b3e:	0e 94 af 9c 	call	0x1395e
   13b42:	fc 01       	movw	r30, r24
   13b44:	10 92 34 0b 	sts	0x0B34, r1
   13b48:	8a e0       	ldi	r24, 0x0A	; 10
   13b4a:	90 e0       	ldi	r25, 0x00	; 0
   13b4c:	91 83       	std	Z+1, r25	; 0x01
   13b4e:	80 83       	st	Z, r24
   13b50:	80 e2       	ldi	r24, 0x20	; 32
   13b52:	82 83       	std	Z+2, r24	; 0x02
   13b54:	84 e3       	ldi	r24, 0x34	; 52
   13b56:	9b e0       	ldi	r25, 0x0B	; 11
   13b58:	94 83       	std	Z+4, r25	; 0x04
   13b5a:	83 83       	std	Z+3, r24	; 0x03
   13b5c:	84 e1       	ldi	r24, 0x14	; 20
   13b5e:	9b e0       	ldi	r25, 0x0B	; 11
   13b60:	96 83       	std	Z+6, r25	; 0x06
   13b62:	85 83       	std	Z+5, r24	; 0x05
   13b64:	85 e3       	ldi	r24, 0x35	; 53
   13b66:	9b e0       	ldi	r25, 0x0B	; 11
   13b68:	90 87       	std	Z+8, r25	; 0x08
   13b6a:	87 83       	std	Z+7, r24	; 0x07
   13b6c:	8d eb       	ldi	r24, 0xBD	; 189
   13b6e:	9c e9       	ldi	r25, 0x9C	; 156
   13b70:	93 87       	std	Z+11, r25	; 0x0b
   13b72:	82 87       	std	Z+10, r24	; 0x0a
   13b74:	0f b7       	in	r16, 0x3f	; 63
   13b76:	f8 94       	cli
   13b78:	11 27       	eor	r17, r17
   13b7a:	10 92 13 0b 	sts	0x0B13, r1
   13b7e:	e4 e6       	ldi	r30, 0x64	; 100
   13b80:	fa ee       	ldi	r31, 0xEA	; 234
   13b82:	09 95       	icall
   13b84:	0f bf       	out	0x3f, r16	; 63
   13b86:	0e 94 af 9c 	call	0x1395e
   13b8a:	fc 01       	movw	r30, r24
   13b8c:	10 92 49 0b 	sts	0x0B49, r1
   13b90:	8b e0       	ldi	r24, 0x0B	; 11
   13b92:	90 e0       	ldi	r25, 0x00	; 0
   13b94:	91 83       	std	Z+1, r25	; 0x01
   13b96:	80 83       	st	Z, r24
   13b98:	80 e1       	ldi	r24, 0x10	; 16
   13b9a:	82 83       	std	Z+2, r24	; 0x02
   13b9c:	89 e4       	ldi	r24, 0x49	; 73
   13b9e:	9b e0       	ldi	r25, 0x0B	; 11
   13ba0:	94 83       	std	Z+4, r25	; 0x04
   13ba2:	83 83       	std	Z+3, r24	; 0x03
   13ba4:	89 e3       	ldi	r24, 0x39	; 57
   13ba6:	9b e0       	ldi	r25, 0x0B	; 11
   13ba8:	96 83       	std	Z+6, r25	; 0x06
   13baa:	85 83       	std	Z+5, r24	; 0x05
   13bac:	8a e4       	ldi	r24, 0x4A	; 74
   13bae:	9b e0       	ldi	r25, 0x0B	; 11
   13bb0:	90 87       	std	Z+8, r25	; 0x08
   13bb2:	87 83       	std	Z+7, r24	; 0x07
   13bb4:	85 e6       	ldi	r24, 0x65	; 101
   13bb6:	9c e9       	ldi	r25, 0x9C	; 156
   13bb8:	93 87       	std	Z+11, r25	; 0x0b
   13bba:	82 87       	std	Z+10, r24	; 0x0a
   13bbc:	0f b7       	in	r16, 0x3f	; 63
   13bbe:	f8 94       	cli
   13bc0:	11 27       	eor	r17, r17
   13bc2:	e4 e6       	ldi	r30, 0x64	; 100
   13bc4:	fa ee       	ldi	r31, 0xEA	; 234
   13bc6:	09 95       	icall
   13bc8:	0f bf       	out	0x3f, r16	; 63
   
   registerDataPacket();
   registerNeighborhoodPacket();



   while ( 1 ) {

	  if (iswakenup == 1)
   13bca:	80 91 13 0b 	lds	r24, 0x0B13
   13bce:	81 30       	cpi	r24, 0x01	; 1
   13bd0:	49 f0       	breq	.+18     	; 0x13be4
	  {
       //If event occurs then skip the current sleep 
	  }
	  else
      sleepThread( NBR_UPDATE_CYCLE );
   13bd2:	88 e8       	ldi	r24, 0x88	; 136
   13bd4:	93 e1       	ldi	r25, 0x13	; 19
   13bd6:	0e 94 d6 9c 	call	0x139ac
	  
      //wakes up and check the new data message?


	  if ( iswakenup == 1 ) {
   13bda:	80 91 13 0b 	lds	r24, 0x0B13
   13bde:	81 30       	cpi	r24, 0x01	; 1
   13be0:	09 f0       	breq	.+2      	; 0x13be4
   13be2:	97 c0       	rjmp	.+302    	; 0x13d12
	  	
         //handles the data message by restructing it and broadcast it based on the neighborhood table information 
         //sends out the new modified message to the next hop and waits for its complete
         //This must be a data packet, whether remote or local!!!

		 iswakenup = 0;
   13be4:	10 92 13 0b 	sts	0x0B13, r1

		 destx = incomingMsg[ 0 ];
   13be8:	f0 90 14 0b 	lds	r15, 0x0B14
         desty = incomingMsg[ 1 ];
   13bec:	10 91 15 0b 	lds	r17, 0x0B15
         from = incomingMsg[ 2 ];
   13bf0:	e0 90 16 0b 	lds	r14, 0x0B16
         to = incomingMsg[ 3 ];
         portnum = incomingMsg[ 4 ];
   13bf4:	50 91 18 0b 	lds	r21, 0x0B18

		 if ( to == nodeid ) {
   13bf8:	80 91 17 0b 	lds	r24, 0x0B17
   13bfc:	99 27       	eor	r25, r25
   13bfe:	20 91 5e 0b 	lds	r18, 0x0B5E
   13c02:	30 91 5f 0b 	lds	r19, 0x0B5F
   13c06:	82 17       	cp	r24, r18
   13c08:	93 07       	cpc	r25, r19
   13c0a:	39 f0       	breq	.+14     	; 0x13c1a
            //StandardSocketSend( portnum, 0, incomingDataLength, incomingMsg );
            radioSend(portnum, 0, incomingDataLength, incomingMsg); 
			packetsdeliver ++; 
         }
          else
        {
            index = 100;
			maxdist = 32000;
            for ( i = 0; i < numOfNeighbors; i ++ ) {
   13c0c:	00 91 6a 0b 	lds	r16, 0x0B6A
   13c10:	60 e0       	ldi	r22, 0x00	; 0
   13c12:	a0 e0       	ldi	r26, 0x00	; 0
   13c14:	bd e7       	ldi	r27, 0x7D	; 125
   13c16:	74 e6       	ldi	r23, 0x64	; 100
   13c18:	40 c0       	rjmp	.+128    	; 0x13c9a
   13c1a:	24 e1       	ldi	r18, 0x14	; 20
   13c1c:	3b e0       	ldi	r19, 0x0B	; 11
   13c1e:	40 91 34 0b 	lds	r20, 0x0B34
   13c22:	60 e0       	ldi	r22, 0x00	; 0
   13c24:	70 e0       	ldi	r23, 0x00	; 0
   13c26:	85 2f       	mov	r24, r21
   13c28:	99 27       	eor	r25, r25
   13c2a:	0e 94 ea 9c 	call	0x139d4
   13c2e:	80 91 68 0b 	lds	r24, 0x0B68
   13c32:	90 91 69 0b 	lds	r25, 0x0B69
   13c36:	01 96       	adiw	r24, 0x01	; 1
   13c38:	90 93 69 0b 	sts	0x0B69, r25
   13c3c:	80 93 68 0b 	sts	0x0B68, r24
   13c40:	c4 cf       	rjmp	.-120    	; 0x13bca
               if ( nbtTable[ i ].valid == 1 ) {
   13c42:	86 2f       	mov	r24, r22
   13c44:	99 27       	eor	r25, r25
   13c46:	fc 01       	movw	r30, r24
   13c48:	ee 0f       	add	r30, r30
   13c4a:	ff 1f       	adc	r31, r31
   13c4c:	ee 0f       	add	r30, r30
   13c4e:	ff 1f       	adc	r31, r31
   13c50:	e8 0f       	add	r30, r24
   13c52:	f9 1f       	adc	r31, r25
   13c54:	e0 51       	subi	r30, 0x10	; 16
   13c56:	f5 4f       	sbci	r31, 0xF5	; 245
   13c58:	84 81       	ldd	r24, Z+4	; 0x04
   13c5a:	81 30       	cpi	r24, 0x01	; 1
   13c5c:	e9 f4       	brne	.+58     	; 0x13c98
                  uint16_t tempdist;
                  tempdist = ( nbtTable[ i ].local_x - destx )*( nbtTable[ i ].local_x - destx ) + ( nbtTable[ i ].local_y - desty )*( nbtTable[ i ].local_y - desty );
   13c5e:	82 81       	ldd	r24, Z+2	; 0x02
   13c60:	99 27       	eor	r25, r25
   13c62:	8f 19       	sub	r24, r15
   13c64:	91 09       	sbc	r25, r1
   13c66:	23 81       	ldd	r18, Z+3	; 0x03
   13c68:	33 27       	eor	r19, r19
   13c6a:	21 1b       	sub	r18, r17
   13c6c:	31 09       	sbc	r19, r1
   13c6e:	88 9f       	mul	r24, r24
   13c70:	a0 01       	movw	r20, r0
   13c72:	89 9f       	mul	r24, r25
   13c74:	50 0d       	add	r21, r0
   13c76:	98 9f       	mul	r25, r24
   13c78:	50 0d       	add	r21, r0
   13c7a:	11 24       	eor	r1, r1
   13c7c:	22 9f       	mul	r18, r18
   13c7e:	c0 01       	movw	r24, r0
   13c80:	23 9f       	mul	r18, r19
   13c82:	90 0d       	add	r25, r0
   13c84:	32 9f       	mul	r19, r18
   13c86:	90 0d       	add	r25, r0
   13c88:	11 24       	eor	r1, r1
   13c8a:	48 0f       	add	r20, r24
   13c8c:	59 1f       	adc	r21, r25
                  if ( tempdist < maxdist ) {
   13c8e:	4a 17       	cp	r20, r26
   13c90:	5b 07       	cpc	r21, r27
   13c92:	10 f4       	brcc	.+4      	; 0x13c98
   13c94:	da 01       	movw	r26, r20
   13c96:	76 2f       	mov	r23, r22
   13c98:	6f 5f       	subi	r22, 0xFF	; 255
   13c9a:	60 17       	cp	r22, r16
   13c9c:	91 f6       	brne	.-92     	; 0x13c42
                     index = i;
                     maxdist = tempdist;
                  }
               }
            }
            if ( index != 100 ) {
   13c9e:	74 36       	cpi	r23, 0x64	; 100
   13ca0:	09 f4       	brne	.+2      	; 0x13ca4
   13ca2:	93 cf       	rjmp	.-218    	; 0x13bca
               radioSend( 10, nbtTable[ index ].nodeid, incomingDataLength, incomingMsg );
   13ca4:	87 2f       	mov	r24, r23
   13ca6:	99 27       	eor	r25, r25
   13ca8:	fc 01       	movw	r30, r24
   13caa:	ee 0f       	add	r30, r30
   13cac:	ff 1f       	adc	r31, r31
   13cae:	ee 0f       	add	r30, r30
   13cb0:	ff 1f       	adc	r31, r31
   13cb2:	e8 0f       	add	r30, r24
   13cb4:	f9 1f       	adc	r31, r25
   13cb6:	e0 51       	subi	r30, 0x10	; 16
   13cb8:	f5 4f       	sbci	r31, 0xF5	; 245
   13cba:	60 81       	ld	r22, Z
   13cbc:	71 81       	ldd	r23, Z+1	; 0x01
   13cbe:	24 e1       	ldi	r18, 0x14	; 20
   13cc0:	3b e0       	ldi	r19, 0x0B	; 11
   13cc2:	40 91 34 0b 	lds	r20, 0x0B34
   13cc6:	8a e0       	ldi	r24, 0x0A	; 10
   13cc8:	90 e0       	ldi	r25, 0x00	; 0
   13cca:	0e 94 ea 9c 	call	0x139d4

void greenToggle()
{
 void (*greenfp)() = (void (*)(void))GREENTOGGLEFUNCTION; 
 greenfp();                              
   13cce:	e4 e0       	ldi	r30, 0x04	; 4
   13cd0:	fa ee       	ldi	r31, 0xEA	; 234
   13cd2:	09 95       	icall
			   greenToggle(); 
               incomingDataLength = 0;
   13cd4:	10 92 34 0b 	sts	0x0B34, r1
               if (from == nodeid)
   13cd8:	2e 2d       	mov	r18, r14
   13cda:	33 27       	eor	r19, r19
   13cdc:	80 91 5e 0b 	lds	r24, 0x0B5E
   13ce0:	90 91 5f 0b 	lds	r25, 0x0B5F
   13ce4:	28 17       	cp	r18, r24
   13ce6:	39 07       	cpc	r19, r25
   13ce8:	51 f4       	brne	.+20     	; 0x13cfe
			   	packetslocal ++;
   13cea:	80 91 64 0b 	lds	r24, 0x0B64
   13cee:	90 91 65 0b 	lds	r25, 0x0B65
   13cf2:	01 96       	adiw	r24, 0x01	; 1
   13cf4:	90 93 65 0b 	sts	0x0B65, r25
   13cf8:	80 93 64 0b 	sts	0x0B64, r24
   13cfc:	66 cf       	rjmp	.-308    	; 0x13bca
			   else 
			   packetsremote ++; 
   13cfe:	80 91 66 0b 	lds	r24, 0x0B66
   13d02:	90 91 67 0b 	lds	r25, 0x0B67
   13d06:	01 96       	adiw	r24, 0x01	; 1
   13d08:	90 93 67 0b 	sts	0x0B67, r25
   13d0c:	80 93 66 0b 	sts	0x0B66, r24
   13d10:	5c cf       	rjmp	.-328    	; 0x13bca
   13d12:	80 91 5e 0b 	lds	r24, 0x0B5E
   13d16:	90 91 5f 0b 	lds	r25, 0x0B5F
   13d1a:	80 93 4e 0b 	sts	0x0B4E, r24
   13d1e:	80 93 4f 0b 	sts	0x0B4F, r24
   13d22:	89 2f       	mov	r24, r25
   13d24:	99 27       	eor	r25, r25
   13d26:	80 93 50 0b 	sts	0x0B50, r24
            }
         }
      }
       else 

	     {
         //sends out hte neighborhood update message in case the previous action has used up the time slot anyway. The next
         //sleep will be another NBR_UPDATE_CYCLE 

		 setNeighborMsg();
         radioSend(11, 0xffff, 16, nbrUpdateMsg);  	
   13d2a:	2e e4       	ldi	r18, 0x4E	; 78
   13d2c:	3b e0       	ldi	r19, 0x0B	; 11
   13d2e:	40 e1       	ldi	r20, 0x10	; 16
   13d30:	6f ef       	ldi	r22, 0xFF	; 255
   13d32:	7f ef       	ldi	r23, 0xFF	; 255
   13d34:	8b e0       	ldi	r24, 0x0B	; 11
   13d36:	90 e0       	ldi	r25, 0x00	; 0
   13d38:	0e 94 ea 9c 	call	0x139d4
   13d3c:	46 cf       	rjmp	.-372    	; 0x13bca

00013d3e <wakeupMe.3390>:
   
   disableRadioState();

  
   Mutex_unlock(msend); 

   return; 
}



//wakeup the current thread once an incoming packet arrives 

void wakeupMe()
{
  mythread->state = STATE_ACTIVE; 
   13d3e:	e0 91 6d 0b 	lds	r30, 0x0B6D
   13d42:	f0 91 6e 0b 	lds	r31, 0x0B6E
   13d46:	82 e0       	ldi	r24, 0x02	; 2
   13d48:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   13d4a:	0e 94 b9 9c 	call	0x13972
   13d4e:	08 95       	ret
