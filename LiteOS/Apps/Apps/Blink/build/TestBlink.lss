
TestBlink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000144  00014000  00014000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000004  00800af0  00800af0  000001b8  2**0
                  ALLOC
  2 .stab         00000414  00000000  00000000  000001b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000071  00000000  00000000  000005cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  0000063d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  0000065d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000c96  00000000  00000000  00000678  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000001df  00000000  00000000  0000130e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001ac  00000000  00000000  000014ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000050  00000000  00000000  0000169c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000027f  00000000  00000000  000016ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000018  00000000  00000000  0000196b  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00014000 <__vectors>:
   14000:	0c 94 46 a0 	jmp	0x1408c	; 0x1408c <__ctors_end>
   14004:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14008:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   1400c:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14010:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14014:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14018:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   1401c:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14020:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14024:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14028:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   1402c:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14030:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14034:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14038:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   1403c:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14040:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14044:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14048:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   1404c:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14050:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14054:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14058:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   1405c:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14060:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14064:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14068:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   1406c:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14070:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14074:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14078:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   1407c:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14080:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14084:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>
   14088:	0c 94 65 a0 	jmp	0x140ca	; 0x140ca <__bad_interrupt>

0001408c <__ctors_end>:
   1408c:	11 24       	eor	r1, r1
   1408e:	1f be       	out	0x3f, r1	; 63
   14090:	c0 ef       	ldi	r28, 0xF0	; 240
   14092:	dc e0       	ldi	r29, 0x0C	; 12
   14094:	de bf       	out	0x3e, r29	; 62
   14096:	cd bf       	out	0x3d, r28	; 61

00014098 <__do_copy_data>:
   14098:	1a e0       	ldi	r17, 0x0A	; 10
   1409a:	a0 ef       	ldi	r26, 0xF0	; 240
   1409c:	ba e0       	ldi	r27, 0x0A	; 10
   1409e:	e4 e4       	ldi	r30, 0x44	; 68
   140a0:	f1 e4       	ldi	r31, 0x41	; 65
   140a2:	01 e0       	ldi	r16, 0x01	; 1
   140a4:	0b bf       	out	0x3b, r16	; 59
   140a6:	02 c0       	rjmp	.+4      	; 0x140ac <__do_copy_data+0x14>
   140a8:	07 90       	elpm	r0, Z+
   140aa:	0d 92       	st	X+, r0
   140ac:	a0 3f       	cpi	r26, 0xF0	; 240
   140ae:	b1 07       	cpc	r27, r17
   140b0:	d9 f7       	brne	.-10     	; 0x140a8 <__do_copy_data+0x10>

000140b2 <__do_clear_bss>:
   140b2:	1a e0       	ldi	r17, 0x0A	; 10
   140b4:	a0 ef       	ldi	r26, 0xF0	; 240
   140b6:	ba e0       	ldi	r27, 0x0A	; 10
   140b8:	01 c0       	rjmp	.+2      	; 0x140bc <.do_clear_bss_start>

000140ba <.do_clear_bss_loop>:
   140ba:	1d 92       	st	X+, r1

000140bc <.do_clear_bss_start>:
   140bc:	a4 3f       	cpi	r26, 0xF4	; 244
   140be:	b1 07       	cpc	r27, r17
   140c0:	e1 f7       	brne	.-8      	; 0x140ba <.do_clear_bss_loop>
   140c2:	0e 94 67 a0 	call	0x140ce	; 0x140ce <main>
   140c6:	0c 94 a1 a0 	jmp	0x14142	; 0x14142 <_exit>

000140ca <__bad_interrupt>:
   140ca:	0c 94 00 a0 	jmp	0x14000	; 0x14000 <__vectors>

000140ce <main>:



int main()
{
   140ce:	1f 93       	push	r17
 uint8_t index;  
 __asm__ __volatile__("sei" ::); 
   140d0:	78 94       	sei
   140d2:	10 e0       	ldi	r17, 0x00	; 0

void greenToggle()
{
 void (*greenfp)() = (void (*)(void))GREENTOGGLEFUNCTION; 
 greenfp();                              
   140d4:	e4 e0       	ldi	r30, 0x04	; 4
   140d6:	fa ee       	ldi	r31, 0xEA	; 234
   140d8:	09 95       	icall
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 
   asm volatile("push r20" "\n\t"
   140da:	4f 93       	push	r20
   140dc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   140de:	ec e0       	ldi	r30, 0x0C	; 12
   140e0:	fa ee       	ldi	r31, 0xEA	; 234
   140e2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   140e4:	a4 2f       	mov	r26, r20
   140e6:	b5 2f       	mov	r27, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   140e8:	5f 91       	pop	r21
   140ea:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADINDEXFUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   140ec:	ed 91       	ld	r30, X+
   140ee:	fc 91       	ld	r31, X
   140f0:	11 97       	sbiw	r26, 0x01	; 1
   140f2:	84 e0       	ldi	r24, 0x04	; 4
   140f4:	82 83       	std	Z+2, r24	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   140f6:	ed 91       	ld	r30, X+
   140f8:	fc 91       	ld	r31, X
   140fa:	84 e6       	ldi	r24, 0x64	; 100
   140fc:	90 e0       	ldi	r25, 0x00	; 0
   140fe:	90 8f       	std	Z+24, r25	; 0x18
   14100:	87 8b       	std	Z+23, r24	; 0x17
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELDFUNCTION; 
 yieldfp();                              
   14102:	e0 e0       	ldi	r30, 0x00	; 0
   14104:	fa ee       	ldi	r31, 0xEA	; 234
   14106:	09 95       	icall
 
   for (index = 0;index <100;index++)
   14108:	1f 5f       	subi	r17, 0xFF	; 255
   1410a:	14 36       	cpi	r17, 0x64	; 100
   1410c:	19 f7       	brne	.-58     	; 0x140d4 <main+0x6>
   	{
	   greenToggle();      
	   sleepThread(100);
    }
   
	return 0; 
}
   1410e:	80 e0       	ldi	r24, 0x00	; 0
   14110:	90 e0       	ldi	r25, 0x00	; 0
   14112:	1f 91       	pop	r17
   14114:	08 95       	ret

00014116 <syscall_postThreadTask.1391>:
}



void syscall_postThreadTask()
{
   14116:	e8 e6       	ldi	r30, 0x68	; 104
   14118:	fa ee       	ldi	r31, 0xEA	; 234
   1411a:	09 95       	icall
   1411c:	08 95       	ret

0001411e <wakeupMeSerial.1721>:

//wakeup the current thread once an incoming packet arrives 

void wakeupMeSerial()
{
   1411e:	e0 91 f0 0a 	lds	r30, 0x0AF0
   14122:	f0 91 f1 0a 	lds	r31, 0x0AF1
   14126:	82 e0       	ldi	r24, 0x02	; 2
   14128:	82 83       	std	Z+2, r24	; 0x02
  mythreadserial->state = STATE_ACTIVE; 
  syscall_postThreadTask();
   1412a:	0e 94 8b a0 	call	0x14116	; 0x14116 <syscall_postThreadTask.1391>
   1412e:	08 95       	ret

00014130 <wakeupMe.3247>:

//wakeup the current thread once an incoming packet arrives 

void wakeupMe()
{
   14130:	e0 91 f2 0a 	lds	r30, 0x0AF2
   14134:	f0 91 f3 0a 	lds	r31, 0x0AF3
   14138:	82 e0       	ldi	r24, 0x02	; 2
   1413a:	82 83       	std	Z+2, r24	; 0x02
  mythread->state = STATE_ACTIVE; 
  syscall_postThreadTask();
   1413c:	0e 94 8b a0 	call	0x14116	; 0x14116 <syscall_postThreadTask.1391>
   14140:	08 95       	ret

00014142 <_exit>:
   14142:	ff cf       	rjmp	.-2      	; 0x14142 <_exit>
