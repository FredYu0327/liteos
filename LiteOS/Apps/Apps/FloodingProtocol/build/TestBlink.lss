
TestBlink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004e8  00013800  00013800  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000064  00800af0  00800af0  0000055c  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  0000055c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  00000964  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  000009e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  00000a08  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001988  00000000  00000000  00000a23  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002b2  00000000  00000000  000023ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000056f  00000000  00000000  0000265d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000d0  00000000  00000000  00002bcc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000592  00000000  00000000  00002c9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000001f1  00000000  00000000  0000322e  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00013800 <__vectors>:
   13800:	0c 94 46 9c 	jmp	0x1388c
   13804:	0c 94 63 9c 	jmp	0x138c6
   13808:	0c 94 63 9c 	jmp	0x138c6
   1380c:	0c 94 63 9c 	jmp	0x138c6
   13810:	0c 94 63 9c 	jmp	0x138c6
   13814:	0c 94 63 9c 	jmp	0x138c6
   13818:	0c 94 63 9c 	jmp	0x138c6
   1381c:	0c 94 63 9c 	jmp	0x138c6
   13820:	0c 94 63 9c 	jmp	0x138c6
   13824:	0c 94 63 9c 	jmp	0x138c6
   13828:	0c 94 63 9c 	jmp	0x138c6
   1382c:	0c 94 63 9c 	jmp	0x138c6
   13830:	0c 94 63 9c 	jmp	0x138c6
   13834:	0c 94 63 9c 	jmp	0x138c6
   13838:	0c 94 63 9c 	jmp	0x138c6
   1383c:	0c 94 63 9c 	jmp	0x138c6
   13840:	0c 94 63 9c 	jmp	0x138c6
   13844:	0c 94 63 9c 	jmp	0x138c6
   13848:	0c 94 63 9c 	jmp	0x138c6
   1384c:	0c 94 63 9c 	jmp	0x138c6
   13850:	0c 94 63 9c 	jmp	0x138c6
   13854:	0c 94 63 9c 	jmp	0x138c6
   13858:	0c 94 63 9c 	jmp	0x138c6
   1385c:	0c 94 63 9c 	jmp	0x138c6
   13860:	0c 94 63 9c 	jmp	0x138c6
   13864:	0c 94 63 9c 	jmp	0x138c6
   13868:	0c 94 63 9c 	jmp	0x138c6
   1386c:	0c 94 63 9c 	jmp	0x138c6
   13870:	0c 94 63 9c 	jmp	0x138c6
   13874:	0c 94 63 9c 	jmp	0x138c6
   13878:	0c 94 63 9c 	jmp	0x138c6
   1387c:	0c 94 63 9c 	jmp	0x138c6
   13880:	0c 94 63 9c 	jmp	0x138c6
   13884:	0c 94 63 9c 	jmp	0x138c6
   13888:	0c 94 63 9c 	jmp	0x138c6

0001388c <__ctors_end>:
   1388c:	11 24       	eor	r1, r1
   1388e:	1f be       	out	0x3f, r1	; 63
   13890:	c0 ef       	ldi	r28, 0xF0	; 240
   13892:	dc e0       	ldi	r29, 0x0C	; 12
   13894:	de bf       	out	0x3e, r29	; 62
   13896:	cd bf       	out	0x3d, r28	; 61

00013898 <__do_copy_data>:
   13898:	1a e0       	ldi	r17, 0x0A	; 10
   1389a:	a0 ef       	ldi	r26, 0xF0	; 240
   1389c:	ba e0       	ldi	r27, 0x0A	; 10
   1389e:	e8 ee       	ldi	r30, 0xE8	; 232
   138a0:	fc e3       	ldi	r31, 0x3C	; 60
   138a2:	01 e0       	ldi	r16, 0x01	; 1
   138a4:	0b bf       	out	0x3b, r16	; 59
   138a6:	02 c0       	rjmp	.+4      	; 0x138ac
   138a8:	07 90       	elpm	r0, Z+
   138aa:	0d 92       	st	X+, r0
   138ac:	a0 3f       	cpi	r26, 0xF0	; 240
   138ae:	b1 07       	cpc	r27, r17
   138b0:	d9 f7       	brne	.-10     	; 0x138a8

000138b2 <__do_clear_bss>:
   138b2:	1b e0       	ldi	r17, 0x0B	; 11
   138b4:	a0 ef       	ldi	r26, 0xF0	; 240
   138b6:	ba e0       	ldi	r27, 0x0A	; 10
   138b8:	01 c0       	rjmp	.+2      	; 0x138bc

000138ba <.do_clear_bss_loop>:
   138ba:	1d 92       	st	X+, r1

000138bc <.do_clear_bss_start>:
   138bc:	a4 35       	cpi	r26, 0x54	; 84
   138be:	b1 07       	cpc	r27, r17
   138c0:	e1 f7       	brne	.-8      	; 0x138ba
   138c2:	0c 94 5c 9d 	jmp	0x13ab8

000138c6 <__bad_interrupt>:
   138c6:	0c 94 00 9c 	jmp	0x13800

000138ca <historycheck.1510>:
}


uint8_t historycheck(uint16_t nodeid, uint16_t randomid)
{
   138ca:	9c 01       	movw	r18, r24
   138cc:	e0 ef       	ldi	r30, 0xF0	; 240
   138ce:	fa e0       	ldi	r31, 0x0A	; 10
   uint8_t i; 
   for (i=0; i < HISTORYBUFFERSIZE; i++) {
   	 if (historypackettable[i].valid == 0)
   138d0:	84 81       	ldd	r24, Z+4	; 0x04
   138d2:	88 23       	and	r24, r24
   138d4:	69 f0       	breq	.+26     	; 0x138f0
	 	continue;
	 if ((historypackettable[i].randomsig == randomid ) && (historypackettable[i].nodeid == nodeid))
   138d6:	80 81       	ld	r24, Z
   138d8:	91 81       	ldd	r25, Z+1	; 0x01
   138da:	86 17       	cp	r24, r22
   138dc:	97 07       	cpc	r25, r23
   138de:	41 f4       	brne	.+16     	; 0x138f0
   138e0:	82 81       	ldd	r24, Z+2	; 0x02
   138e2:	93 81       	ldd	r25, Z+3	; 0x03
   138e4:	82 17       	cp	r24, r18
   138e6:	93 07       	cpc	r25, r19
   138e8:	19 f4       	brne	.+6      	; 0x138f0
   138ea:	81 e0       	ldi	r24, 0x01	; 1
   138ec:	90 e0       	ldi	r25, 0x00	; 0
   138ee:	08 95       	ret
   138f0:	35 96       	adiw	r30, 0x05	; 5
   138f2:	8b e0       	ldi	r24, 0x0B	; 11
   138f4:	e2 32       	cpi	r30, 0x22	; 34
   138f6:	f8 07       	cpc	r31, r24
   138f8:	59 f7       	brne	.-42     	; 0x138d0
   138fa:	80 e0       	ldi	r24, 0x00	; 0
   138fc:	90 e0       	ldi	r25, 0x00	; 0
	 	return 1; 
   	}
   return 0; 
}
   138fe:	08 95       	ret

00013900 <inserthistorytable.1524>:


void inserthistorytable(uint16_t nodeid, uint16_t randomid)
{

   historypackettable[indexOfPackets].valid = 1; 
   13900:	20 91 4f 0b 	lds	r18, 0x0B4F
   13904:	33 27       	eor	r19, r19
   13906:	f9 01       	movw	r30, r18
   13908:	ee 0f       	add	r30, r30
   1390a:	ff 1f       	adc	r31, r31
   1390c:	ee 0f       	add	r30, r30
   1390e:	ff 1f       	adc	r31, r31
   13910:	e2 0f       	add	r30, r18
   13912:	f3 1f       	adc	r31, r19
   13914:	e0 51       	subi	r30, 0x10	; 16
   13916:	f5 4f       	sbci	r31, 0xF5	; 245
   13918:	41 e0       	ldi	r20, 0x01	; 1
   1391a:	44 83       	std	Z+4, r20	; 0x04
   historypackettable[indexOfPackets].nodeid = nodeid; 
   1391c:	93 83       	std	Z+3, r25	; 0x03
   1391e:	82 83       	std	Z+2, r24	; 0x02
   historypackettable[indexOfPackets].randomsig = randomid; 
   13920:	71 83       	std	Z+1, r23	; 0x01
   13922:	60 83       	st	Z, r22
   indexOfPackets = (indexOfPackets + 1)%HISTORYBUFFERSIZE;
   13924:	c9 01       	movw	r24, r18
   13926:	01 96       	adiw	r24, 0x01	; 1
   13928:	6a e0       	ldi	r22, 0x0A	; 10
   1392a:	70 e0       	ldi	r23, 0x00	; 0
   1392c:	0e 94 4d 9e 	call	0x13c9a
   13930:	80 93 4f 0b 	sts	0x0B4F, r24
   13934:	08 95       	ret

00013936 <getCurrentThread.1385>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 
   asm volatile("push r20" "\n\t"
   13936:	4f 93       	push	r20
   13938:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   1393a:	ec e0       	ldi	r30, 0x0C	; 12
   1393c:	fa ee       	ldi	r31, 0xEA	; 234
   1393e:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   13940:	84 2f       	mov	r24, r20
   13942:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   13944:	5f 91       	pop	r21
   13946:	4f 91       	pop	r20
   13948:	08 95       	ret

0001394a <random.1408>:
{
	
	 int ret; 
   void (*getrandomfp)(void) = (void (*)(void))GETRANDOM16FUNCTION; 
   asm volatile("push r20" "\n\t"
   1394a:	4f 93       	push	r20
   1394c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getrandomfp();     
   1394e:	ec eb       	ldi	r30, 0xBC	; 188
   13950:	fa ee       	ldi	r31, 0xEA	; 234
   13952:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   13954:	84 2f       	mov	r24, r20
   13956:	95 2f       	mov	r25, r21
	              "mov %B0, r21" "\n\t"
				 :"=r" (ret)
				 :
                );
   asm volatile("pop r21" "\n\t"
   13958:	5f 91       	pop	r21
   1395a:	4f 91       	pop	r20
   1395c:	08 95       	ret

0001395e <syscall_postThreadTask.1391>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADINDEXFUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELDFUNCTION; 
 yieldfp();                              
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POSTTHREADTASK; 
 postthreadfp();                              
   1395e:	e8 e6       	ldi	r30, 0x68	; 104
   13960:	fa ee       	ldi	r31, 0xEA	; 234
   13962:	09 95       	icall
   13964:	08 95       	ret

00013966 <wakeupMeOnDataMsg.1534>:
   return;  
}



//-------------------------------------------------------------------------
static uint8_t incomingMsg[ 32 ];
static uint8_t incomingDataLength;
static uint8_t incomingPacketInfo[ 4 ];


//Handles incoming data msg. This usually wakesup the current thread 
void wakeupMeOnDataMsg() {

   thisthread->state = STATE_ACTIVE;
   13966:	e0 91 4d 0b 	lds	r30, 0x0B4D
   1396a:	f0 91 4e 0b 	lds	r31, 0x0B4E
   1396e:	82 e0       	ldi	r24, 0x02	; 2
   13970:	82 83       	std	Z+2, r24	; 0x02
   syscall_postThreadTask();    
   13972:	0e 94 af 9c 	call	0x1395e
   13976:	08 95       	ret

00013978 <wakeupMeSerial.1826>:
//wakeup the current thread once an incoming packet arrives 

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE; 
   13978:	e0 91 50 0b 	lds	r30, 0x0B50
   1397c:	f0 91 51 0b 	lds	r31, 0x0B51
   13980:	82 e0       	ldi	r24, 0x02	; 2
   13982:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   13984:	0e 94 af 9c 	call	0x1395e
   13988:	08 95       	ret

0001398a <yield.1384>:
   1398a:	e0 e0       	ldi	r30, 0x00	; 0
   1398c:	fa ee       	ldi	r31, 0xEA	; 234
   1398e:	09 95       	icall
   13990:	08 95       	ret

00013992 <sleepThread.1383>:
   13992:	0f 93       	push	r16
   13994:	1f 93       	push	r17
   13996:	8c 01       	movw	r16, r24
   13998:	0e 94 9b 9c 	call	0x13936
   1399c:	dc 01       	movw	r26, r24
   1399e:	ed 91       	ld	r30, X+
   139a0:	fc 91       	ld	r31, X
   139a2:	11 97       	sbiw	r26, 0x01	; 1
   139a4:	84 e0       	ldi	r24, 0x04	; 4
   139a6:	82 83       	std	Z+2, r24	; 0x02
   139a8:	ed 91       	ld	r30, X+
   139aa:	fc 91       	ld	r31, X
   139ac:	10 8f       	std	Z+24, r17	; 0x18
   139ae:	07 8b       	std	Z+23, r16	; 0x17
   139b0:	0e 94 c5 9c 	call	0x1398a
   139b4:	1f 91       	pop	r17
   139b6:	0f 91       	pop	r16
   139b8:	08 95       	ret

000139ba <radioSend.1443>:
}


void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
   139ba:	4f 92       	push	r4
   139bc:	5f 92       	push	r5
   139be:	6f 92       	push	r6
   139c0:	7f 92       	push	r7
   139c2:	8f 92       	push	r8
   139c4:	9f 92       	push	r9
   139c6:	af 92       	push	r10
   139c8:	bf 92       	push	r11
   139ca:	cf 92       	push	r12
   139cc:	df 92       	push	r13
   139ce:	ef 92       	push	r14
   139d0:	ff 92       	push	r15
   139d2:	0f 93       	push	r16
   139d4:	1f 93       	push	r17
   139d6:	cf 93       	push	r28
   139d8:	df 93       	push	r29
   139da:	5c 01       	movw	r10, r24
   139dc:	4b 01       	movw	r8, r22
   139de:	44 2e       	mov	r4, r20
   139e0:	39 01       	movw	r6, r18
mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GETRADIOMUTEXFUNCTION; 
   asm volatile("push r20" "\n\t"
   139e2:	4f 93       	push	r20
   139e4:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   139e6:	e0 e1       	ldi	r30, 0x10	; 16
   139e8:	fa ee       	ldi	r31, 0xEA	; 234
   139ea:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   139ec:	c4 2f       	mov	r28, r20
   139ee:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   139f0:	5f 91       	pop	r21
   139f2:	4f 91       	pop	r20
 
 
   mutex* msend; 
   thread** current_thread; 
   radioinfotype *radioinfoaddr; 

  
   
   msend = getRadioMutexAddress();   
   current_thread = getCurrentThread(); 
   139f4:	0e 94 9b 9c 	call	0x13936
   139f8:	4f 93       	push	r20
   139fa:	5f 93       	push	r21
   139fc:	ec e5       	ldi	r30, 0x5C	; 92
   139fe:	fa ee       	ldi	r31, 0xEA	; 234
   13a00:	09 95       	icall
   13a02:	04 2f       	mov	r16, r20
   13a04:	15 2f       	mov	r17, r21
   13a06:	5f 91       	pop	r21
   13a08:	4f 91       	pop	r20
   13a0a:	0e 94 9b 9c 	call	0x13936
   13a0e:	7c 01       	movw	r14, r24
   13a10:	4f 93       	push	r20
   13a12:	5f 93       	push	r21
   13a14:	ec e1       	ldi	r30, 0x1C	; 28
   13a16:	fa ee       	ldi	r31, 0xEA	; 234
   13a18:	09 95       	icall
   13a1a:	c4 2e       	mov	r12, r20
   13a1c:	d5 2e       	mov	r13, r21
   13a1e:	5f 91       	pop	r21
   13a20:	4f 91       	pop	r20
   13a22:	5f b6       	in	r5, 0x3f	; 63
   13a24:	f8 94       	cli
   13a26:	88 81       	ld	r24, Y
   13a28:	88 23       	and	r24, r24
   13a2a:	91 f0       	breq	.+36     	; 0x13a50
   13a2c:	d7 01       	movw	r26, r14
   13a2e:	ed 91       	ld	r30, X+
   13a30:	fc 91       	ld	r31, X
   13a32:	11 97       	sbiw	r26, 0x01	; 1
   13a34:	83 e0       	ldi	r24, 0x03	; 3
   13a36:	82 83       	std	Z+2, r24	; 0x02
   13a38:	ed 91       	ld	r30, X+
   13a3a:	fc 91       	ld	r31, X
   13a3c:	d0 8f       	std	Z+24, r29	; 0x18
   13a3e:	c7 8b       	std	Z+23, r28	; 0x17
   13a40:	89 81       	ldd	r24, Y+1	; 0x01
   13a42:	8f 5f       	subi	r24, 0xFF	; 255
   13a44:	89 83       	std	Y+1, r24	; 0x01
   13a46:	0e 94 c5 9c 	call	0x1398a
   13a4a:	89 81       	ldd	r24, Y+1	; 0x01
   13a4c:	81 50       	subi	r24, 0x01	; 1
   13a4e:	89 83       	std	Y+1, r24	; 0x01
   13a50:	81 e0       	ldi	r24, 0x01	; 1
   13a52:	88 83       	st	Y, r24
   13a54:	8c 2d       	mov	r24, r12
   13a56:	99 27       	eor	r25, r25
   13a58:	8a 83       	std	Y+2, r24	; 0x02
   13a5a:	85 2d       	mov	r24, r5
   13a5c:	99 27       	eor	r25, r25
   13a5e:	8f bf       	out	0x3f, r24	; 63
   radioinfoaddr = getCurrentRadioInfo();

   Mutex_lock(msend);
     
   radioinfoaddr-> socket_port = port; 
   13a60:	f8 01       	movw	r30, r16
   13a62:	b1 82       	std	Z+1, r11	; 0x01
   13a64:	a0 82       	st	Z, r10
   radioinfoaddr->socket_addr = address; 
   13a66:	93 82       	std	Z+3, r9	; 0x03
   13a68:	82 82       	std	Z+2, r8	; 0x02
   radioinfoaddr->socket_msg_len  = length; 
   13a6a:	44 82       	std	Z+4, r4	; 0x04
   radioinfoaddr->socket_msg  = msg;
   13a6c:	76 82       	std	Z+6, r7	; 0x06
   13a6e:	65 82       	std	Z+5, r6	; 0x05
   13a70:	e4 e1       	ldi	r30, 0x14	; 20
   13a72:	fa ee       	ldi	r31, 0xEA	; 234
   13a74:	09 95       	icall
    
   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg(); 

   sleepThread(30); 
   13a76:	8e e1       	ldi	r24, 0x1E	; 30
   13a78:	90 e0       	ldi	r25, 0x00	; 0
   13a7a:	0e 94 c9 9c 	call	0x13992
   13a7e:	e8 eb       	ldi	r30, 0xB8	; 184
   13a80:	fa ee       	ldi	r31, 0xEA	; 234
   13a82:	09 95       	icall
   13a84:	4f 93       	push	r20
   13a86:	5f 93       	push	r21
   13a88:	4c 2f       	mov	r20, r28
   13a8a:	5d 2f       	mov	r21, r29
   13a8c:	e8 e1       	ldi	r30, 0x18	; 24
   13a8e:	fa ee       	ldi	r31, 0xEA	; 234
   13a90:	09 95       	icall
   13a92:	5f 91       	pop	r21
   13a94:	4f 91       	pop	r20
   13a96:	df 91       	pop	r29
   13a98:	cf 91       	pop	r28
   13a9a:	1f 91       	pop	r17
   13a9c:	0f 91       	pop	r16
   13a9e:	ff 90       	pop	r15
   13aa0:	ef 90       	pop	r14
   13aa2:	df 90       	pop	r13
   13aa4:	cf 90       	pop	r12
   13aa6:	bf 90       	pop	r11
   13aa8:	af 90       	pop	r10
   13aaa:	9f 90       	pop	r9
   13aac:	8f 90       	pop	r8
   13aae:	7f 90       	pop	r7
   13ab0:	6f 90       	pop	r6
   13ab2:	5f 90       	pop	r5
   13ab4:	4f 90       	pop	r4
   13ab6:	08 95       	ret

00013ab8 <main>:
}


//Registers the data packet for receving incoming packets. This enables receving both remote and local data packets

void registerDataPacket() {

   _atomic_t currentatomic;
   radiohandletype *radiohandleaddr;
   
   void (*getaddrfp)(void) = (void (*)(void))SETCURRENTRADIOHANDLE; 

   //Finds the radio handle, so that when this code is ported to be externally used, it will be obtained via a system call 
   radiohandleaddr =  getCurrentRadioHandleAddr();

   incomingDataLength = 0;
   
   //set up the radiohandleaddr data structures
   radiohandleaddr->port = 20;
   radiohandleaddr->maxLength = 32;
   radiohandleaddr->dataReady = &incomingDataLength;
   radiohandleaddr->data = incomingMsg;
   radiohandleaddr->packetinfo = incomingPacketInfo;
   radiohandleaddr->handlefunc = wakeupMeOnDataMsg;

   //close the interrupt     
   currentatomic = _atomic_start();
   
   //call the radio handle set to store the data structure into the handle vectors 
   getaddrfp();     
   //syscall_registerEvent();
   
   //open the interrupt 
   _atomic_end( currentatomic );
   return ;
}




//This is the entry point. It broadcasts neighbor exchanges perodically, or handles incoming packets (non-update neighbor)

int main() {
   13ab8:	df 92       	push	r13
   13aba:	ef 92       	push	r14
   13abc:	ff 92       	push	r15
   13abe:	0f 93       	push	r16
   13ac0:	1f 93       	push	r17
   13ac2:	cf 93       	push	r28
   13ac4:	df 93       	push	r29
   13ac6:	e4 ef       	ldi	r30, 0xF4	; 244
   13ac8:	fa e0       	ldi	r31, 0x0A	; 10
   13aca:	10 82       	st	Z, r1
   13acc:	35 96       	adiw	r30, 0x05	; 5
   13ace:	8b e0       	ldi	r24, 0x0B	; 11
   13ad0:	e6 32       	cpi	r30, 0x26	; 38
   13ad2:	f8 07       	cpc	r31, r24
   13ad4:	d1 f7       	brne	.-12     	; 0x13aca
   13ad6:	10 92 4f 0b 	sts	0x0B4F, r1
	             "pop r20" "\n\t"
	              ::);
   return ret; 
	
}



uint16_t getnodeID()
	{
		
	   int ret; 
	   void (*fp)(void) = (void (*)(void))GETNODEIDFUNCTION; 
	   asm volatile("push r20" "\n\t"
   13ada:	4f 93       	push	r20
   13adc:	5f 93       	push	r21
					"push r21" "\n\t"
					::);
	   fp();	  
   13ade:	ec ec       	ldi	r30, 0xCC	; 204
   13ae0:	fa ee       	ldi	r31, 0xEA	; 234
   13ae2:	09 95       	icall
	   asm volatile(" mov %A0, r20" "\n\t"
   13ae4:	e4 2e       	mov	r14, r20
   13ae6:	f5 2e       	mov	r15, r21
					  "mov %B0, r21" "\n\t"
					 :"=r" (ret)
					 :
					);
	   asm volatile("pop r21" "\n\t"
   13ae8:	5f 91       	pop	r21
   13aea:	4f 91       	pop	r20

   uint8_t portnum;
   uint16_t nodeid; 

   uint16_t randomsig;
   uint16_t incomingnodeid; 

   uint8_t temp;
   uint8_t jitter; 
   uint16_t comingnodeid; 
  

   initTable();
   nodeid = getnodeID();
   
   //register both the negibhorhood update and the message incoming 

   thiscurrentthread = getCurrentThread(); 
   13aec:	0e 94 9b 9c 	call	0x13936
   13af0:	fc 01       	movw	r30, r24
   13af2:	90 93 4c 0b 	sts	0x0B4C, r25
   13af6:	80 93 4b 0b 	sts	0x0B4B, r24
   thisthread = *thiscurrentthread; 
   13afa:	80 81       	ld	r24, Z
   13afc:	91 81       	ldd	r25, Z+1	; 0x01
   13afe:	90 93 4e 0b 	sts	0x0B4E, r25
   13b02:	80 93 4d 0b 	sts	0x0B4D, r24
   13b06:	4f 93       	push	r20
   13b08:	5f 93       	push	r21
   13b0a:	e0 e6       	ldi	r30, 0x60	; 96
   13b0c:	fa ee       	ldi	r31, 0xEA	; 234
   13b0e:	09 95       	icall
   13b10:	e4 2f       	mov	r30, r20
   13b12:	f5 2f       	mov	r31, r21
   13b14:	5f 91       	pop	r21
   13b16:	4f 91       	pop	r20
   13b18:	10 92 42 0b 	sts	0x0B42, r1
   13b1c:	84 e1       	ldi	r24, 0x14	; 20
   13b1e:	90 e0       	ldi	r25, 0x00	; 0
   13b20:	91 83       	std	Z+1, r25	; 0x01
   13b22:	80 83       	st	Z, r24
   13b24:	80 e2       	ldi	r24, 0x20	; 32
   13b26:	82 83       	std	Z+2, r24	; 0x02
   13b28:	82 e4       	ldi	r24, 0x42	; 66
   13b2a:	9b e0       	ldi	r25, 0x0B	; 11
   13b2c:	94 83       	std	Z+4, r25	; 0x04
   13b2e:	83 83       	std	Z+3, r24	; 0x03
   13b30:	82 e2       	ldi	r24, 0x22	; 34
   13b32:	9b e0       	ldi	r25, 0x0B	; 11
   13b34:	96 83       	std	Z+6, r25	; 0x06
   13b36:	85 83       	std	Z+5, r24	; 0x05
   13b38:	83 e4       	ldi	r24, 0x43	; 67
   13b3a:	9b e0       	ldi	r25, 0x0B	; 11
   13b3c:	90 87       	std	Z+8, r25	; 0x08
   13b3e:	87 83       	std	Z+7, r24	; 0x07
   13b40:	83 eb       	ldi	r24, 0xB3	; 179
   13b42:	9c e9       	ldi	r25, 0x9C	; 156
   13b44:	93 87       	std	Z+11, r25	; 0x0b
   13b46:	82 87       	std	Z+10, r24	; 0x0a
   13b48:	0f b7       	in	r16, 0x3f	; 63
   13b4a:	f8 94       	cli
   13b4c:	11 27       	eor	r17, r17
   13b4e:	e4 e6       	ldi	r30, 0x64	; 100
   13b50:	fa ee       	ldi	r31, 0xEA	; 234
   13b52:	09 95       	icall
   13b54:	0f bf       	out	0x3f, r16	; 63
      
   registerDataPacket();

   packetsreceived = packetsdelivered = 0; 
   13b56:	10 92 4a 0b 	sts	0x0B4A, r1
   13b5a:	10 92 49 0b 	sts	0x0B49, r1
   13b5e:	10 92 48 0b 	sts	0x0B48, r1
   13b62:	10 92 47 0b 	sts	0x0B47, r1
   13b66:	0e 94 9b 9c 	call	0x13936
   13b6a:	fc 01       	movw	r30, r24
   13b6c:	01 90       	ld	r0, Z+
   13b6e:	f0 81       	ld	r31, Z
   13b70:	e0 2d       	mov	r30, r0
   13b72:	85 e0       	ldi	r24, 0x05	; 5
   13b74:	82 83       	std	Z+2, r24	; 0x02
   13b76:	0e 94 c5 9c 	call	0x1398a


   while ( 1 ) {

         hibernateThread();
		 incomingnodeid = 0; 
         //handles the data message by restructing it and broadcast it  
         //If the packet is new, send it both locally and remotely

		 temp  = incomingMsg[ 0 ];
		 
		 incomingnodeid += ((uint16_t)temp); 
		 temp = incomingMsg[ 1 ];
		 incomingnodeid += ((uint16_t)temp) * 256;
   13b7a:	20 91 22 0b 	lds	r18, 0x0B22
   13b7e:	80 91 23 0b 	lds	r24, 0x0B23
   13b82:	99 27       	eor	r25, r25
   13b84:	18 2f       	mov	r17, r24
   13b86:	00 27       	eor	r16, r16
   13b88:	02 0f       	add	r16, r18
   13b8a:	11 1d       	adc	r17, r1

         randomsig = 0; 
		 temp = incomingMsg[ 2 ];
		 randomsig += ((uint16_t)temp);

   	     temp = incomingMsg[ 3 ];
		 randomsig += ((uint16_t)temp) * 256;
   13b8c:	20 91 24 0b 	lds	r18, 0x0B24
   13b90:	80 91 25 0b 	lds	r24, 0x0B25
   13b94:	99 27       	eor	r25, r25
   13b96:	d8 2f       	mov	r29, r24
   13b98:	cc 27       	eor	r28, r28
   13b9a:	c2 0f       	add	r28, r18
   13b9c:	d1 1d       	adc	r29, r1

		 portnum = incomingMsg[4]; 
   13b9e:	d0 90 26 0b 	lds	r13, 0x0B26

		 if ((nodeid == incomingnodeid)&&(historycheck(incomingnodeid, randomsig) == 0))
   13ba2:	e0 16       	cp	r14, r16
   13ba4:	f1 06       	cpc	r15, r17
   13ba6:	69 f5       	brne	.+90     	; 0x13c02
   13ba8:	be 01       	movw	r22, r28
   13baa:	c7 01       	movw	r24, r14
   13bac:	0e 94 65 9c 	call	0x138ca
   13bb0:	88 23       	and	r24, r24
   13bb2:	39 f5       	brne	.+78     	; 0x13c02
		 	{
    		 	inserthistorytable(incomingnodeid, randomsig); 
   13bb4:	be 01       	movw	r22, r28
   13bb6:	c7 01       	movw	r24, r14
   13bb8:	0e 94 80 9c 	call	0x13900
				incomingMsg[5] = nodeid%256; 
   13bbc:	e0 92 27 0b 	sts	0x0B27, r14
				incomingMsg[6] = nodeid/256; 
   13bc0:	8f 2d       	mov	r24, r15
   13bc2:	99 27       	eor	r25, r25
   13bc4:	80 93 28 0b 	sts	0x0B28, r24
				
				jitter = random()%20;
   13bc8:	0e 94 a5 9c 	call	0x1394a
				sleepThread(jitter); 
   13bcc:	64 e1       	ldi	r22, 0x14	; 20
   13bce:	70 e0       	ldi	r23, 0x00	; 0
   13bd0:	0e 94 4d 9e 	call	0x13c9a
   13bd4:	99 27       	eor	r25, r25
   13bd6:	0e 94 c9 9c 	call	0x13992
				radioSend(20, 0xffff, incomingDataLength, incomingMsg);
   13bda:	22 e2       	ldi	r18, 0x22	; 34
   13bdc:	3b e0       	ldi	r19, 0x0B	; 11
   13bde:	40 91 42 0b 	lds	r20, 0x0B42
   13be2:	6f ef       	ldi	r22, 0xFF	; 255
   13be4:	7f ef       	ldi	r23, 0xFF	; 255
   13be6:	84 e1       	ldi	r24, 0x14	; 20
   13be8:	90 e0       	ldi	r25, 0x00	; 0
   13bea:	0e 94 dd 9c 	call	0x139ba
				packetsreceived ++; 
   13bee:	80 91 47 0b 	lds	r24, 0x0B47
   13bf2:	90 91 48 0b 	lds	r25, 0x0B48
   13bf6:	01 96       	adiw	r24, 0x01	; 1
   13bf8:	90 93 48 0b 	sts	0x0B48, r25
   13bfc:	80 93 47 0b 	sts	0x0B47, r24
   13c00:	b2 cf       	rjmp	.-156    	; 0x13b66
		    }
		 

		 else if (historycheck(incomingnodeid, randomsig) == 0)
   13c02:	be 01       	movw	r22, r28
   13c04:	c8 01       	movw	r24, r16
   13c06:	0e 94 65 9c 	call	0x138ca
   13c0a:	88 23       	and	r24, r24
   13c0c:	09 f0       	breq	.+2      	; 0x13c10
   13c0e:	ab cf       	rjmp	.-170    	; 0x13b66
		 	{
             
				comingnodeid = incomingMsg[5];
   13c10:	80 91 27 0b 	lds	r24, 0x0B27
   13c14:	28 2f       	mov	r18, r24
   13c16:	33 27       	eor	r19, r19
				if ((comingnodeid != nodeid -1 )&&( comingnodeid!=nodeid+1))
   13c18:	c7 01       	movw	r24, r14
   13c1a:	01 97       	sbiw	r24, 0x01	; 1
   13c1c:	28 17       	cp	r18, r24
   13c1e:	39 07       	cpc	r19, r25
   13c20:	31 f0       	breq	.+12     	; 0x13c2e
   13c22:	c7 01       	movw	r24, r14
   13c24:	01 96       	adiw	r24, 0x01	; 1
   13c26:	28 17       	cp	r18, r24
   13c28:	39 07       	cpc	r19, r25
   13c2a:	09 f0       	breq	.+2      	; 0x13c2e
   13c2c:	9c cf       	rjmp	.-200    	; 0x13b66
					{
					}
				else
					{
                radioSend(portnum, 0, incomingDataLength, incomingMsg); 
   13c2e:	22 e2       	ldi	r18, 0x22	; 34
   13c30:	3b e0       	ldi	r19, 0x0B	; 11
   13c32:	40 91 42 0b 	lds	r20, 0x0B42
   13c36:	60 e0       	ldi	r22, 0x00	; 0
   13c38:	70 e0       	ldi	r23, 0x00	; 0
   13c3a:	8d 2d       	mov	r24, r13
   13c3c:	99 27       	eor	r25, r25
   13c3e:	0e 94 dd 9c 	call	0x139ba
				
				inserthistorytable(incomingnodeid, randomsig); 
   13c42:	be 01       	movw	r22, r28
   13c44:	c8 01       	movw	r24, r16
   13c46:	0e 94 80 9c 	call	0x13900

				incomingMsg[5] = nodeid%256;
   13c4a:	e0 92 27 0b 	sts	0x0B27, r14
				
				jitter = random()%20;
   13c4e:	0e 94 a5 9c 	call	0x1394a
				sleepThread(jitter); 
   13c52:	64 e1       	ldi	r22, 0x14	; 20
   13c54:	70 e0       	ldi	r23, 0x00	; 0
   13c56:	0e 94 4d 9e 	call	0x13c9a
   13c5a:	99 27       	eor	r25, r25
   13c5c:	0e 94 c9 9c 	call	0x13992
				radioSend(20, 0xffff, incomingDataLength, incomingMsg);
   13c60:	22 e2       	ldi	r18, 0x22	; 34
   13c62:	3b e0       	ldi	r19, 0x0B	; 11
   13c64:	40 91 42 0b 	lds	r20, 0x0B42
   13c68:	6f ef       	ldi	r22, 0xFF	; 255
   13c6a:	7f ef       	ldi	r23, 0xFF	; 255
   13c6c:	84 e1       	ldi	r24, 0x14	; 20
   13c6e:	90 e0       	ldi	r25, 0x00	; 0
   13c70:	0e 94 dd 9c 	call	0x139ba
				packetsdelivered++; 
   13c74:	80 91 49 0b 	lds	r24, 0x0B49
   13c78:	90 91 4a 0b 	lds	r25, 0x0B4A
   13c7c:	01 96       	adiw	r24, 0x01	; 1
   13c7e:	90 93 4a 0b 	sts	0x0B4A, r25
   13c82:	80 93 49 0b 	sts	0x0B49, r24
   13c86:	6f cf       	rjmp	.-290    	; 0x13b66

00013c88 <wakeupMe.3352>:
   
   disableRadioState();

  
   Mutex_unlock(msend); 

   return; 
}



//wakeup the current thread once an incoming packet arrives 

void wakeupMe()
{
  mythread->state = STATE_ACTIVE; 
   13c88:	e0 91 52 0b 	lds	r30, 0x0B52
   13c8c:	f0 91 53 0b 	lds	r31, 0x0B53
   13c90:	82 e0       	ldi	r24, 0x02	; 2
   13c92:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   13c94:	0e 94 af 9c 	call	0x1395e
   13c98:	08 95       	ret

00013c9a <__divmodhi4>:
   13c9a:	97 fb       	bst	r25, 7
   13c9c:	09 2e       	mov	r0, r25
   13c9e:	07 26       	eor	r0, r23
   13ca0:	0a d0       	rcall	.+20     	; 0x13cb6
   13ca2:	77 fd       	sbrc	r23, 7
   13ca4:	04 d0       	rcall	.+8      	; 0x13cae
   13ca6:	0c d0       	rcall	.+24     	; 0x13cc0
   13ca8:	06 d0       	rcall	.+12     	; 0x13cb6
   13caa:	00 20       	and	r0, r0
   13cac:	1a f4       	brpl	.+6      	; 0x13cb4

00013cae <__divmodhi4_neg2>:
   13cae:	70 95       	com	r23
   13cb0:	61 95       	neg	r22
   13cb2:	7f 4f       	sbci	r23, 0xFF	; 255

00013cb4 <__divmodhi4_exit>:
   13cb4:	08 95       	ret

00013cb6 <__divmodhi4_neg1>:
   13cb6:	f6 f7       	brtc	.-4      	; 0x13cb4
   13cb8:	90 95       	com	r25
   13cba:	81 95       	neg	r24
   13cbc:	9f 4f       	sbci	r25, 0xFF	; 255
   13cbe:	08 95       	ret

00013cc0 <__udivmodhi4>:
   13cc0:	aa 1b       	sub	r26, r26
   13cc2:	bb 1b       	sub	r27, r27
   13cc4:	51 e1       	ldi	r21, 0x11	; 17
   13cc6:	07 c0       	rjmp	.+14     	; 0x13cd6

00013cc8 <__udivmodhi4_loop>:
   13cc8:	aa 1f       	adc	r26, r26
   13cca:	bb 1f       	adc	r27, r27
   13ccc:	a6 17       	cp	r26, r22
   13cce:	b7 07       	cpc	r27, r23
   13cd0:	10 f0       	brcs	.+4      	; 0x13cd6
   13cd2:	a6 1b       	sub	r26, r22
   13cd4:	b7 0b       	sbc	r27, r23

00013cd6 <__udivmodhi4_ep>:
   13cd6:	88 1f       	adc	r24, r24
   13cd8:	99 1f       	adc	r25, r25
   13cda:	5a 95       	dec	r21
   13cdc:	a9 f7       	brne	.-22     	; 0x13cc8
   13cde:	80 95       	com	r24
   13ce0:	90 95       	com	r25
   13ce2:	bc 01       	movw	r22, r24
   13ce4:	cd 01       	movw	r24, r26
   13ce6:	08 95       	ret
