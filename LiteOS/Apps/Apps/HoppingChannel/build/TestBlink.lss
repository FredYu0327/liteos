
TestBlink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800af0  00013a8c  00000320  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000028c  00013800  00013800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000004  00800b00  00800b00  00000330  2**0
                  ALLOC
  3 .stab         00000408  00000000  00000000  00000330  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000084  00000000  00000000  00000738  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  000007bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000001b  00000000  00000000  000007dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001365  00000000  00000000  000007f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000261  00000000  00000000  00001b5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000003a4  00000000  00000000  00001dbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000090  00000000  00000000  00002161  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000041f  00000000  00000000  000021f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000006b  00000000  00000000  00002610  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  0000267b  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00013800 <__vectors>:
   13800:	0c 94 46 9c 	jmp	0x1388c
   13804:	0c 94 63 9c 	jmp	0x138c6
   13808:	0c 94 63 9c 	jmp	0x138c6
   1380c:	0c 94 63 9c 	jmp	0x138c6
   13810:	0c 94 63 9c 	jmp	0x138c6
   13814:	0c 94 63 9c 	jmp	0x138c6
   13818:	0c 94 63 9c 	jmp	0x138c6
   1381c:	0c 94 63 9c 	jmp	0x138c6
   13820:	0c 94 63 9c 	jmp	0x138c6
   13824:	0c 94 63 9c 	jmp	0x138c6
   13828:	0c 94 63 9c 	jmp	0x138c6
   1382c:	0c 94 63 9c 	jmp	0x138c6
   13830:	0c 94 63 9c 	jmp	0x138c6
   13834:	0c 94 63 9c 	jmp	0x138c6
   13838:	0c 94 63 9c 	jmp	0x138c6
   1383c:	0c 94 63 9c 	jmp	0x138c6
   13840:	0c 94 63 9c 	jmp	0x138c6
   13844:	0c 94 63 9c 	jmp	0x138c6
   13848:	0c 94 63 9c 	jmp	0x138c6
   1384c:	0c 94 63 9c 	jmp	0x138c6
   13850:	0c 94 63 9c 	jmp	0x138c6
   13854:	0c 94 63 9c 	jmp	0x138c6
   13858:	0c 94 63 9c 	jmp	0x138c6
   1385c:	0c 94 63 9c 	jmp	0x138c6
   13860:	0c 94 63 9c 	jmp	0x138c6
   13864:	0c 94 63 9c 	jmp	0x138c6
   13868:	0c 94 63 9c 	jmp	0x138c6
   1386c:	0c 94 63 9c 	jmp	0x138c6
   13870:	0c 94 63 9c 	jmp	0x138c6
   13874:	0c 94 63 9c 	jmp	0x138c6
   13878:	0c 94 63 9c 	jmp	0x138c6
   1387c:	0c 94 63 9c 	jmp	0x138c6
   13880:	0c 94 63 9c 	jmp	0x138c6
   13884:	0c 94 63 9c 	jmp	0x138c6
   13888:	0c 94 63 9c 	jmp	0x138c6

0001388c <__ctors_end>:
   1388c:	11 24       	eor	r1, r1
   1388e:	1f be       	out	0x3f, r1	; 63
   13890:	c0 ef       	ldi	r28, 0xF0	; 240
   13892:	dc e0       	ldi	r29, 0x0C	; 12
   13894:	de bf       	out	0x3e, r29	; 62
   13896:	cd bf       	out	0x3d, r28	; 61

00013898 <__do_copy_data>:
   13898:	1b e0       	ldi	r17, 0x0B	; 11
   1389a:	a0 ef       	ldi	r26, 0xF0	; 240
   1389c:	ba e0       	ldi	r27, 0x0A	; 10
   1389e:	ec e8       	ldi	r30, 0x8C	; 140
   138a0:	fa e3       	ldi	r31, 0x3A	; 58
   138a2:	01 e0       	ldi	r16, 0x01	; 1
   138a4:	0b bf       	out	0x3b, r16	; 59
   138a6:	02 c0       	rjmp	.+4      	; 0x138ac
   138a8:	07 90       	elpm	r0, Z+
   138aa:	0d 92       	st	X+, r0
   138ac:	a0 30       	cpi	r26, 0x00	; 0
   138ae:	b1 07       	cpc	r27, r17
   138b0:	d9 f7       	brne	.-10     	; 0x138a8

000138b2 <__do_clear_bss>:
   138b2:	1b e0       	ldi	r17, 0x0B	; 11
   138b4:	a0 e0       	ldi	r26, 0x00	; 0
   138b6:	bb e0       	ldi	r27, 0x0B	; 11
   138b8:	01 c0       	rjmp	.+2      	; 0x138bc

000138ba <.do_clear_bss_loop>:
   138ba:	1d 92       	st	X+, r1

000138bc <.do_clear_bss_start>:
   138bc:	a4 30       	cpi	r26, 0x04	; 4
   138be:	b1 07       	cpc	r27, r17
   138c0:	e1 f7       	brne	.-8      	; 0x138ba
   138c2:	0c 94 9f 9c 	jmp	0x1393e

000138c6 <__bad_interrupt>:
   138c6:	0c 94 00 9c 	jmp	0x13800

000138ca <setRadioChannel.1449>:
  uint16_t maskchannel = channel; 
  
  void (*getaddrfp)(void) = (void (*)(void))SETRADIOCHANNELFUNCTION; 

  asm volatile("push r20" "\n\t"
   138ca:	4f 93       	push	r20
   138cc:	5f 93       	push	r21
               "push r21" "\n\t"
               ::);
      
  asm volatile(" mov r20, %A0" "\n\t"
   138ce:	99 27       	eor	r25, r25
   138d0:	48 2f       	mov	r20, r24
   138d2:	59 2f       	mov	r21, r25
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp(); 
   138d4:	e4 ec       	ldi	r30, 0xC4	; 196
   138d6:	fa ee       	ldi	r31, 0xEA	; 234
   138d8:	09 95       	icall
   asm volatile("pop r21" "\n\t"
   138da:	5f 91       	pop	r21
   138dc:	4f 91       	pop	r20
   138de:	08 95       	ret

000138e0 <getCurrentThread.1394>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 
   asm volatile("push r20" "\n\t"
   138e0:	4f 93       	push	r20
   138e2:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   138e4:	ec e0       	ldi	r30, 0x0C	; 12
   138e6:	fa ee       	ldi	r31, 0xEA	; 234
   138e8:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   138ea:	84 2f       	mov	r24, r20
   138ec:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   138ee:	5f 91       	pop	r21
   138f0:	4f 91       	pop	r20
   138f2:	08 95       	ret

000138f4 <yield.1393>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADINDEXFUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELDFUNCTION; 
 yieldfp();                              
   138f4:	e0 e0       	ldi	r30, 0x00	; 0
   138f6:	fa ee       	ldi	r31, 0xEA	; 234
   138f8:	09 95       	icall
   138fa:	08 95       	ret

000138fc <sleepThread.1392>:
   138fc:	0f 93       	push	r16
   138fe:	1f 93       	push	r17
   13900:	8c 01       	movw	r16, r24
   13902:	0e 94 70 9c 	call	0x138e0
   13906:	dc 01       	movw	r26, r24
   13908:	ed 91       	ld	r30, X+
   1390a:	fc 91       	ld	r31, X
   1390c:	11 97       	sbiw	r26, 0x01	; 1
   1390e:	84 e0       	ldi	r24, 0x04	; 4
   13910:	82 83       	std	Z+2, r24	; 0x02
   13912:	ed 91       	ld	r30, X+
   13914:	fc 91       	ld	r31, X
   13916:	10 8f       	std	Z+24, r17	; 0x18
   13918:	07 8b       	std	Z+23, r16	; 0x17
   1391a:	0e 94 7a 9c 	call	0x138f4
   1391e:	1f 91       	pop	r17
   13920:	0f 91       	pop	r16
   13922:	08 95       	ret

00013924 <syscall_postThreadTask.1400>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POSTTHREADTASK; 
 postthreadfp();                              
   13924:	e8 e6       	ldi	r30, 0x68	; 104
   13926:	fa ee       	ldi	r31, 0xEA	; 234
   13928:	09 95       	icall
   1392a:	08 95       	ret

0001392c <wakeupMeSerial.1711>:
//wakeup the current thread once an incoming packet arrives 

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE; 
   1392c:	e0 91 00 0b 	lds	r30, 0x0B00
   13930:	f0 91 01 0b 	lds	r31, 0x0B01
   13934:	82 e0       	ldi	r24, 0x02	; 2
   13936:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   13938:	0e 94 92 9c 	call	0x13924
   1393c:	08 95       	ret

0001393e <main>:



int main()
{ 
   1393e:	6f 92       	push	r6
   13940:	7f 92       	push	r7
   13942:	8f 92       	push	r8
   13944:	9f 92       	push	r9
   13946:	af 92       	push	r10
   13948:	bf 92       	push	r11
   1394a:	cf 92       	push	r12
   1394c:	df 92       	push	r13
   1394e:	ef 92       	push	r14
   13950:	ff 92       	push	r15
   13952:	0f 93       	push	r16
   13954:	1f 93       	push	r17
   13956:	cf 93       	push	r28
   13958:	df 93       	push	r29
   1395a:	9b e0       	ldi	r25, 0x0B	; 11
   1395c:	a9 2e       	mov	r10, r25

 uint8_t channel;
 
 for (channel = 11;channel <25;channel++)
 { setRadioChannel(channel); 
   1395e:	8a 2d       	mov	r24, r10
   13960:	0e 94 65 9c 	call	0x138ca
  
 radioSend_string("Hello, world!\n"); 
   13964:	80 ef       	ldi	r24, 0xF0	; 240
   13966:	68 2e       	mov	r6, r24
   13968:	8a e0       	ldi	r24, 0x0A	; 10
   1396a:	78 2e       	mov	r7, r24
   1396c:	f3 01       	movw	r30, r6
   1396e:	01 c0       	rjmp	.+2      	; 0x13972
   13970:	31 96       	adiw	r30, 0x01	; 1


int String_length(char* s) {
	int count=0;
	while(s[count] != '\0')
   13972:	80 81       	ld	r24, Z
   13974:	88 23       	and	r24, r24
   13976:	e1 f7       	brne	.-8      	; 0x13970
   13978:	e0 5f       	subi	r30, 0xF0	; 240
   1397a:	fa 40       	sbci	r31, 0x0A	; 10
   1397c:	4f 01       	movw	r8, r30
mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GETRADIOMUTEXFUNCTION; 
   asm volatile("push r20" "\n\t"
   1397e:	4f 93       	push	r20
   13980:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   13982:	e0 e1       	ldi	r30, 0x10	; 16
   13984:	fa ee       	ldi	r31, 0xEA	; 234
   13986:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   13988:	c4 2f       	mov	r28, r20
   1398a:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   1398c:	5f 91       	pop	r21
   1398e:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return; 
}

void setRadioPower(uint8_t power)
{
  
  uint16_t maskchannel = power; 
  
  void (*getaddrfp)(void) = (void (*)(void))SETRADIOPOWERFUNCTION; 

  asm volatile("push r20" "\n\t"
               "push r21" "\n\t"
               ::);
      
  asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp(); 
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return; 
}



radioinfotype *getCurrentRadioInfo()
{
   radioinfotype *currentradioinfo; 
   void (*getaddrfp)(void) = (void (*)(void))GETCURRENTRADIOINFO; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo; 
}


void disableRadioState()
{
  
   void (*disableradiofp)(void) = (void (*)(void))DISABLERADIOSTATE; 
   
   disableradiofp();     

   return;	
}


void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
 
 
   mutex* msend; 
   thread** current_thread; 
   radioinfotype *radioinfoaddr; 

  
   
   msend = getRadioMutexAddress();   
   current_thread = getCurrentThread(); 
   13990:	0e 94 70 9c 	call	0x138e0
   13994:	4f 93       	push	r20
   13996:	5f 93       	push	r21
   13998:	ec e5       	ldi	r30, 0x5C	; 92
   1399a:	fa ee       	ldi	r31, 0xEA	; 234
   1399c:	09 95       	icall
   1399e:	04 2f       	mov	r16, r20
   139a0:	15 2f       	mov	r17, r21
   139a2:	5f 91       	pop	r21
   139a4:	4f 91       	pop	r20
   139a6:	0e 94 70 9c 	call	0x138e0
   139aa:	7c 01       	movw	r14, r24
   139ac:	4f 93       	push	r20
   139ae:	5f 93       	push	r21
   139b0:	ec e1       	ldi	r30, 0x1C	; 28
   139b2:	fa ee       	ldi	r31, 0xEA	; 234
   139b4:	09 95       	icall
   139b6:	c4 2e       	mov	r12, r20
   139b8:	d5 2e       	mov	r13, r21
   139ba:	5f 91       	pop	r21
   139bc:	4f 91       	pop	r20


_atomic_t _atomic_start(void) 
{
  _atomic_t result = SREG;
   139be:	bf b6       	in	r11, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
   139c0:	f8 94       	cli
   139c2:	88 81       	ld	r24, Y
   139c4:	88 23       	and	r24, r24
   139c6:	91 f0       	breq	.+36     	; 0x139ec
   139c8:	d7 01       	movw	r26, r14
   139ca:	ed 91       	ld	r30, X+
   139cc:	fc 91       	ld	r31, X
   139ce:	11 97       	sbiw	r26, 0x01	; 1
   139d0:	83 e0       	ldi	r24, 0x03	; 3
   139d2:	82 83       	std	Z+2, r24	; 0x02
   139d4:	ed 91       	ld	r30, X+
   139d6:	fc 91       	ld	r31, X
   139d8:	d0 8f       	std	Z+24, r29	; 0x18
   139da:	c7 8b       	std	Z+23, r28	; 0x17
   139dc:	89 81       	ldd	r24, Y+1	; 0x01
   139de:	8f 5f       	subi	r24, 0xFF	; 255
   139e0:	89 83       	std	Y+1, r24	; 0x01
   139e2:	0e 94 7a 9c 	call	0x138f4
   139e6:	89 81       	ldd	r24, Y+1	; 0x01
   139e8:	81 50       	subi	r24, 0x01	; 1
   139ea:	89 83       	std	Y+1, r24	; 0x01
   139ec:	81 e0       	ldi	r24, 0x01	; 1
   139ee:	88 83       	st	Y, r24
   139f0:	8c 2d       	mov	r24, r12
   139f2:	99 27       	eor	r25, r25
   139f4:	8a 83       	std	Y+2, r24	; 0x02
   139f6:	8b 2d       	mov	r24, r11
   139f8:	99 27       	eor	r25, r25
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg; 
   139fa:	8f bf       	out	0x3f, r24	; 63
   radioinfoaddr = getCurrentRadioInfo();

   Mutex_lock(msend);
     
   radioinfoaddr-> socket_port = port; 
   139fc:	81 e0       	ldi	r24, 0x01	; 1
   139fe:	90 e0       	ldi	r25, 0x00	; 0
   13a00:	f8 01       	movw	r30, r16
   13a02:	91 83       	std	Z+1, r25	; 0x01
   13a04:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address; 
   13a06:	8f ef       	ldi	r24, 0xFF	; 255
   13a08:	9f ef       	ldi	r25, 0xFF	; 255
   13a0a:	93 83       	std	Z+3, r25	; 0x03
   13a0c:	82 83       	std	Z+2, r24	; 0x02
   radioinfoaddr->socket_msg_len  = length; 
   13a0e:	84 82       	std	Z+4, r8	; 0x04
   radioinfoaddr->socket_msg  = msg;
   13a10:	76 82       	std	Z+6, r7	; 0x06
   13a12:	65 82       	std	Z+5, r6	; 0x05
   13a14:	e4 e1       	ldi	r30, 0x14	; 20
   13a16:	fa ee       	ldi	r31, 0xEA	; 234
   13a18:	09 95       	icall
    
   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg(); 

   sleepThread(30); 
   13a1a:	8e e1       	ldi	r24, 0x1E	; 30
   13a1c:	90 e0       	ldi	r25, 0x00	; 0
   13a1e:	0e 94 7e 9c 	call	0x138fc
   13a22:	e8 eb       	ldi	r30, 0xB8	; 184
   13a24:	fa ee       	ldi	r31, 0xEA	; 234
   13a26:	09 95       	icall
   13a28:	4f 93       	push	r20
   13a2a:	5f 93       	push	r21
   13a2c:	4c 2f       	mov	r20, r28
   13a2e:	5d 2f       	mov	r21, r29
   13a30:	e8 e1       	ldi	r30, 0x18	; 24
   13a32:	fa ee       	ldi	r31, 0xEA	; 234
   13a34:	09 95       	icall
   13a36:	5f 91       	pop	r21
   13a38:	4f 91       	pop	r20

void greenToggle()
{
 void (*greenfp)() = (void (*)(void))GREENTOGGLEFUNCTION; 
 greenfp();                              
   13a3a:	e4 e0       	ldi	r30, 0x04	; 4
   13a3c:	fa ee       	ldi	r31, 0xEA	; 234
   13a3e:	09 95       	icall
 greenToggle();
 sleepThread(1000);
   13a40:	88 ee       	ldi	r24, 0xE8	; 232
   13a42:	93 e0       	ldi	r25, 0x03	; 3
   13a44:	0e 94 7e 9c 	call	0x138fc
   13a48:	a3 94       	inc	r10
   13a4a:	f9 e1       	ldi	r31, 0x19	; 25
   13a4c:	af 16       	cp	r10, r31
   13a4e:	09 f0       	breq	.+2      	; 0x13a52
   13a50:	86 cf       	rjmp	.-244    	; 0x1395e

 }
 
 channel = 15; 
 setRadioChannel(channel); 
   13a52:	8f e0       	ldi	r24, 0x0F	; 15
   13a54:	0e 94 65 9c 	call	0x138ca
 return 0; 

}
   13a58:	80 e0       	ldi	r24, 0x00	; 0
   13a5a:	90 e0       	ldi	r25, 0x00	; 0
   13a5c:	df 91       	pop	r29
   13a5e:	cf 91       	pop	r28
   13a60:	1f 91       	pop	r17
   13a62:	0f 91       	pop	r16
   13a64:	ff 90       	pop	r15
   13a66:	ef 90       	pop	r14
   13a68:	df 90       	pop	r13
   13a6a:	cf 90       	pop	r12
   13a6c:	bf 90       	pop	r11
   13a6e:	af 90       	pop	r10
   13a70:	9f 90       	pop	r9
   13a72:	8f 90       	pop	r8
   13a74:	7f 90       	pop	r7
   13a76:	6f 90       	pop	r6
   13a78:	08 95       	ret

00013a7a <wakeupMe.3237>:
   
   disableRadioState();

  
   Mutex_unlock(msend); 

   return; 
}



//wakeup the current thread once an incoming packet arrives 

void wakeupMe()
{
  mythread->state = STATE_ACTIVE; 
   13a7a:	e0 91 02 0b 	lds	r30, 0x0B02
   13a7e:	f0 91 03 0b 	lds	r31, 0x0B03
   13a82:	82 e0       	ldi	r24, 0x02	; 2
   13a84:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   13a86:	0e 94 92 9c 	call	0x13924
   13a8a:	08 95       	ret
