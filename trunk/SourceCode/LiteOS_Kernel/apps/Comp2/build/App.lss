
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000186  0000dc00  0000dc00  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000002  00800c08  00800c08  000001fa  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  000001fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  00000604  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  00000688  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  000006a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000fe2  00000000  00000000  000006c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000001d9  00000000  00000000  000016a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001fb  00000000  00000000  0000187e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000040  00000000  00000000  00001a79  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000002f9  00000000  00000000  00001ab9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000009e  00000000  00000000  00001db2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000060  00000000  00000000  00001e50  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

0000dc00 <__vectors>:
    dc00:	0c 94 46 6e 	jmp	0xdc8c	; 0xdc8c <__ctors_end>
    dc04:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc08:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc0c:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc10:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc14:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc18:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc1c:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc20:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc24:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc28:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc2c:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc30:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc34:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc38:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc3c:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc40:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc44:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc48:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc4c:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc50:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc54:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc58:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc5c:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc60:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc64:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc68:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc6c:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc70:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc74:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc78:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc7c:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc80:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc84:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>
    dc88:	0c 94 63 6e 	jmp	0xdcc6	; 0xdcc6 <__bad_interrupt>

0000dc8c <__ctors_end>:
    dc8c:	11 24       	eor	r1, r1
    dc8e:	1f be       	out	0x3f, r1	; 63
    dc90:	ce e9       	ldi	r28, 0x9E	; 158
    dc92:	dc e0       	ldi	r29, 0x0C	; 12
    dc94:	de bf       	out	0x3e, r29	; 62
    dc96:	cd bf       	out	0x3d, r28	; 61

0000dc98 <__do_copy_data>:
    dc98:	1c e0       	ldi	r17, 0x0C	; 12
    dc9a:	a8 e0       	ldi	r26, 0x08	; 8
    dc9c:	bc e0       	ldi	r27, 0x0C	; 12
    dc9e:	e6 e8       	ldi	r30, 0x86	; 134
    dca0:	fd ed       	ldi	r31, 0xDD	; 221
    dca2:	00 e0       	ldi	r16, 0x00	; 0
    dca4:	0b bf       	out	0x3b, r16	; 59
    dca6:	02 c0       	rjmp	.+4      	; 0xdcac <__do_copy_data+0x14>
    dca8:	07 90       	elpm	r0, Z+
    dcaa:	0d 92       	st	X+, r0
    dcac:	a8 30       	cpi	r26, 0x08	; 8
    dcae:	b1 07       	cpc	r27, r17
    dcb0:	d9 f7       	brne	.-10     	; 0xdca8 <__do_copy_data+0x10>

0000dcb2 <__do_clear_bss>:
    dcb2:	1c e0       	ldi	r17, 0x0C	; 12
    dcb4:	a8 e0       	ldi	r26, 0x08	; 8
    dcb6:	bc e0       	ldi	r27, 0x0C	; 12
    dcb8:	01 c0       	rjmp	.+2      	; 0xdcbc <.do_clear_bss_start>

0000dcba <.do_clear_bss_loop>:
    dcba:	1d 92       	st	X+, r1

0000dcbc <.do_clear_bss_start>:
    dcbc:	aa 30       	cpi	r26, 0x0A	; 10
    dcbe:	b1 07       	cpc	r27, r17
    dcc0:	e1 f7       	brne	.-8      	; 0xdcba <.do_clear_bss_loop>
    dcc2:	0c 94 6f 6e 	jmp	0xdcde	; 0xdcde <main>

0000dcc6 <__bad_interrupt>:
    dcc6:	0c 94 00 6e 	jmp	0xdc00	; 0xdc00 <__vectors>

0000dcca <getCurrentThread.1404>:

//Warning: this returns the address of the currentthread pointer. 

thread **getCurrentThread()
{
    dcca:	4f 93       	push	r20
    dccc:	5f 93       	push	r21
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    dcce:	ec e0       	ldi	r30, 0x0C	; 12
    dcd0:	fa ee       	ldi	r31, 0xEA	; 234
    dcd2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    dcd4:	84 2f       	mov	r24, r20
    dcd6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
    dcd8:	5f 91       	pop	r21
    dcda:	4f 91       	pop	r20
    dcdc:	08 95       	ret

0000dcde <main>:
#define PRG_RDB(addr) pgm_read_byte(addr)
#endif

int main()
{
    dcde:	78 94       	sei
 uint16_t index;
 uint8_t index2; 
  thread** current_thread;
 
 __asm__ __volatile__("sei" ::); 
 

	  
    current_thread = getCurrentThread();  
    dce0:	0e 94 65 6e 	call	0xdcca	; 0xdcca <getCurrentThread.1404>
    dce4:	dc 01       	movw	r26, r24
    
   (*current_thread)->ecbptr->share = 333; 
    dce6:	ed 91       	ld	r30, X+
    dce8:	fc 91       	ld	r31, X
    dcea:	11 97       	sbiw	r26, 0x01	; 1
    dcec:	05 a0       	ldd	r0, Z+37	; 0x25
    dcee:	f6 a1       	ldd	r31, Z+38	; 0x26
    dcf0:	e0 2d       	mov	r30, r0
    dcf2:	8d e4       	ldi	r24, 0x4D	; 77
    dcf4:	81 83       	std	Z+1, r24	; 0x01
   (*current_thread)->ecbptr->totalenergy =  7500000; 
    dcf6:	ed 91       	ld	r30, X+
    dcf8:	fc 91       	ld	r31, X
    dcfa:	05 a0       	ldd	r0, Z+37	; 0x25
    dcfc:	f6 a1       	ldd	r31, Z+38	; 0x26
    dcfe:	e0 2d       	mov	r30, r0
    dd00:	80 ee       	ldi	r24, 0xE0	; 224
    dd02:	90 e7       	ldi	r25, 0x70	; 112
    dd04:	a2 e7       	ldi	r26, 0x72	; 114
    dd06:	b0 e0       	ldi	r27, 0x00	; 0
    dd08:	83 83       	std	Z+3, r24	; 0x03
    dd0a:	94 83       	std	Z+4, r25	; 0x04
    dd0c:	a5 83       	std	Z+5, r26	; 0x05
    dd0e:	b6 83       	std	Z+6, r27	; 0x06
   (*current_thread)->ecbptr->remainenergy = 7500000; 
    dd10:	87 83       	std	Z+7, r24	; 0x07
    dd12:	90 87       	std	Z+8, r25	; 0x08
    dd14:	a1 87       	std	Z+9, r26	; 0x09
    dd16:	b2 87       	std	Z+10, r27	; 0x0a
     
   sbi(MCUCR, SM0);
    dd18:	85 b7       	in	r24, 0x35	; 53
    dd1a:	88 60       	ori	r24, 0x08	; 8
    dd1c:	85 bf       	out	0x35, r24	; 53

   sbi(MCUCR, SM1);
    dd1e:	85 b7       	in	r24, 0x35	; 53
    dd20:	80 61       	ori	r24, 0x10	; 16
    dd22:	85 bf       	out	0x35, r24	; 53
   cbi(MCUCR, SM2); 
    dd24:	85 b7       	in	r24, 0x35	; 53
    dd26:	8b 7f       	andi	r24, 0xFB	; 251
    dd28:	85 bf       	out	0x35, r24	; 53
   sbi(MCUCR, SE);
    dd2a:	85 b7       	in	r24, 0x35	; 53
    dd2c:	80 62       	ori	r24, 0x20	; 32
    dd2e:	85 bf       	out	0x35, r24	; 53
    dd30:	20 e0       	ldi	r18, 0x00	; 0
    dd32:	30 e0       	ldi	r19, 0x00	; 0
    dd34:	1c c0       	rjmp	.+56     	; 0xdd6e <main+0x90>
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}


void **getKernelStackPtr()
	{
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
}







uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    dd36:	0e 94 65 6e 	call	0xdcca	; 0xdcca <getCurrentThread.1404>
    dd3a:	dc 01       	movw	r26, r24
     
   (*current_thread)->state = 4;
    dd3c:	ed 91       	ld	r30, X+
    dd3e:	fc 91       	ld	r31, X
    dd40:	11 97       	sbiw	r26, 0x01	; 1
    dd42:	84 e0       	ldi	r24, 0x04	; 4
    dd44:	82 83       	std	Z+2, r24	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    dd46:	ed 91       	ld	r30, X+
    dd48:	fc 91       	ld	r31, X
    dd4a:	84 e6       	ldi	r24, 0x64	; 100
    dd4c:	90 e0       	ldi	r25, 0x00	; 0
    dd4e:	94 8f       	std	Z+28, r25	; 0x1c
    dd50:	83 8f       	std	Z+27, r24	; 0x1b
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    dd52:	e0 e0       	ldi	r30, 0x00	; 0
    dd54:	fa ee       	ldi	r31, 0xEA	; 234
    dd56:	09 95       	icall
    dd58:	eb cf       	rjmp	.-42     	; 0xdd30 <main+0x52>
   
   
   while(1)
   	{
	   
	   for (index=0;index<1200;index++)
	    for (index2=0;index2<123;index2++)
	        {
	        	__asm__ __volatile__("nop" ::); 
    dd5a:	00 00       	nop
    dd5c:	8f 5f       	subi	r24, 0xFF	; 255
    dd5e:	8b 37       	cpi	r24, 0x7B	; 123
    dd60:	e1 f7       	brne	.-8      	; 0xdd5a <main+0x7c>
    dd62:	2f 5f       	subi	r18, 0xFF	; 255
    dd64:	3f 4f       	sbci	r19, 0xFF	; 255
    dd66:	84 e0       	ldi	r24, 0x04	; 4
    dd68:	20 3b       	cpi	r18, 0xB0	; 176
    dd6a:	38 07       	cpc	r19, r24
    dd6c:	21 f3       	breq	.-56     	; 0xdd36 <main+0x58>
    dd6e:	80 e0       	ldi	r24, 0x00	; 0
    dd70:	f4 cf       	rjmp	.-24     	; 0xdd5a <main+0x7c>

0000dd72 <wakeupMe.3692>:

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
    dd72:	e0 91 08 0c 	lds	r30, 0x0C08
    dd76:	f0 91 09 0c 	lds	r31, 0x0C09
    dd7a:	82 e0       	ldi	r24, 0x02	; 2
    dd7c:	82 83       	std	Z+2, r24	; 0x02
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    dd7e:	e8 e6       	ldi	r30, 0x68	; 104
    dd80:	fa ee       	ldi	r31, 0xEA	; 234
    dd82:	09 95       	icall
    dd84:	08 95       	ret
