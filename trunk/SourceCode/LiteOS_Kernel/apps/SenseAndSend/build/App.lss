
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000039e  0000f000  0000f000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          0000001c  00800c80  00800c80  00000412  2**0
                  ALLOC
  2 .debug_aranges 00000020  00000000  00000000  00000412  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 0000001b  00000000  00000000  00000432  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00001a7c  00000000  00000000  0000044d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000028c  00000000  00000000  00001ec9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   0000046f  00000000  00000000  00002155  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000050  00000000  00000000  000025c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000004d9  00000000  00000000  00002614  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000016e  00000000  00000000  00002aed  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000158  00000000  00000000  00002c5b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000f000 <__vectors>:
    f000:	0c 94 46 78 	jmp	0xf08c	; 0xf08c <__ctors_end>
    f004:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f008:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f00c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f010:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f014:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f018:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f01c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f020:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f024:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f028:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f02c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f030:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f034:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f038:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f03c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f040:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f044:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f048:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f04c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f050:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f054:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f058:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f05c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f060:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f064:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f068:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f06c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f070:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f074:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f078:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f07c:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f080:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f084:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>
    f088:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <__bad_interrupt>

0000f08c <__ctors_end>:
    f08c:	11 24       	eor	r1, r1
    f08e:	1f be       	out	0x3f, r1	; 63
    f090:	cc ea       	ldi	r28, 0xAC	; 172
    f092:	dd e0       	ldi	r29, 0x0D	; 13
    f094:	de bf       	out	0x3e, r29	; 62
    f096:	cd bf       	out	0x3d, r28	; 61

0000f098 <__do_copy_data>:
    f098:	1c e0       	ldi	r17, 0x0C	; 12
    f09a:	a0 e8       	ldi	r26, 0x80	; 128
    f09c:	bc e0       	ldi	r27, 0x0C	; 12
    f09e:	ee e9       	ldi	r30, 0x9E	; 158
    f0a0:	f3 ef       	ldi	r31, 0xF3	; 243
    f0a2:	00 e0       	ldi	r16, 0x00	; 0
    f0a4:	0b bf       	out	0x3b, r16	; 59
    f0a6:	02 c0       	rjmp	.+4      	; 0xf0ac <__do_copy_data+0x14>
    f0a8:	07 90       	elpm	r0, Z+
    f0aa:	0d 92       	st	X+, r0
    f0ac:	a0 38       	cpi	r26, 0x80	; 128
    f0ae:	b1 07       	cpc	r27, r17
    f0b0:	d9 f7       	brne	.-10     	; 0xf0a8 <__do_copy_data+0x10>

0000f0b2 <__do_clear_bss>:
    f0b2:	1c e0       	ldi	r17, 0x0C	; 12
    f0b4:	a0 e8       	ldi	r26, 0x80	; 128
    f0b6:	bc e0       	ldi	r27, 0x0C	; 12
    f0b8:	01 c0       	rjmp	.+2      	; 0xf0bc <.do_clear_bss_start>

0000f0ba <.do_clear_bss_loop>:
    f0ba:	1d 92       	st	X+, r1

0000f0bc <.do_clear_bss_start>:
    f0bc:	ac 39       	cpi	r26, 0x9C	; 156
    f0be:	b1 07       	cpc	r27, r17
    f0c0:	e1 f7       	brne	.-8      	; 0xf0ba <.do_clear_bss_loop>
    f0c2:	0e 94 7d 78 	call	0xf0fa	; 0xf0fa <main>
    f0c6:	0c 94 cd 79 	jmp	0xf39a	; 0xf39a <_exit>

0000f0ca <__bad_interrupt>:
    f0ca:	0c 94 00 78 	jmp	0xf000	; 0xf000 <__vectors>

0000f0ce <getCurrentThread.1336>:

thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f0ce:	4f 93       	push	r20
    f0d0:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f0d2:	ec e0       	ldi	r30, 0x0C	; 12
    f0d4:	fa ee       	ldi	r31, 0xEA	; 234
    f0d6:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f0d8:	24 2f       	mov	r18, r20
    f0da:	35 2f       	mov	r19, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f0dc:	5f 91       	pop	r21
    f0de:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}
    f0e0:	c9 01       	movw	r24, r18
    f0e2:	08 95       	ret

0000f0e4 <getCurrentRadioInfoAddr.1422>:

radioinfotype *getCurrentRadioInfoAddr()
{
   radioinfotype *currentradioinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_INFO_ADDR;
   asm volatile("push r20" "\n\t"
    f0e4:	4f 93       	push	r20
    f0e6:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();
    f0e8:	ec e5       	ldi	r30, 0x5C	; 92
    f0ea:	fa ee       	ldi	r31, 0xEA	; 234
    f0ec:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f0ee:	24 2f       	mov	r18, r20
    f0f0:	35 2f       	mov	r19, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f0f2:	5f 91       	pop	r21
    f0f4:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo;
}
    f0f6:	c9 01       	movw	r24, r18
    f0f8:	08 95       	ret

0000f0fa <main>:

uint16_t reading;


int main()
{ 
    f0fa:	2f 92       	push	r2
    f0fc:	3f 92       	push	r3
    f0fe:	4f 92       	push	r4
    f100:	5f 92       	push	r5
    f102:	6f 92       	push	r6
    f104:	7f 92       	push	r7
    f106:	8f 92       	push	r8
    f108:	9f 92       	push	r9
    f10a:	af 92       	push	r10
    f10c:	bf 92       	push	r11
    f10e:	cf 92       	push	r12
    f110:	df 92       	push	r13
    f112:	ef 92       	push	r14
    f114:	ff 92       	push	r15
    f116:	0f 93       	push	r16
    f118:	1f 93       	push	r17
    f11a:	df 93       	push	r29
    f11c:	cf 93       	push	r28
    f11e:	00 d0       	rcall	.+0      	; 0xf120 <main+0x26>
    f120:	cd b7       	in	r28, 0x3d	; 61
    f122:	de b7       	in	r29, 0x3e	; 62
uint16_t i; 
   __asm__ __volatile__("sei" ::);
    f124:	78 94       	sei
	 uint16_t returnval; 
 
	 radioinfotype *radioinfoaddr;
	 thread **current_thread; 
	  
   current_thread = getCurrentThread(); 
    f126:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1336>
    f12a:	8c 01       	movw	r16, r24
uint32_t getCPUcount()
	{

	   uint32_t ret;
	   void (*fp)(void) = (void (*)(void))GET_CPU_COUNT_FUNCTION;
	   asm volatile("push r18" "\n\t"
    f12c:	2f 93       	push	r18
    f12e:	3f 93       	push	r19
    f130:	4f 93       	push	r20
    f132:	5f 93       	push	r21
					"push r19" "\n\t"
							"push r20" "\n\t"
									"push r21" "\n\t"
					::);
	   fp();
    f134:	ec e1       	ldi	r30, 0x1C	; 28
    f136:	fb ee       	ldi	r31, 0xEB	; 235
    f138:	09 95       	icall
	   asm volatile(" mov %A0, r18" "\n\t"
    f13a:	62 2f       	mov	r22, r18
    f13c:	73 2f       	mov	r23, r19
    f13e:	84 2f       	mov	r24, r20
    f140:	95 2f       	mov	r25, r21
								"mov %C0, r20" "\n\t"
											"mov %D0, r21" "\n\t"
					 :"=r" (ret)
					 :
					);
	   asm volatile("pop r21" "\n\t"
    f142:	5f 91       	pop	r21
    f144:	4f 91       	pop	r20
    f146:	3f 91       	pop	r19
    f148:	2f 91       	pop	r18
     
   currenttime = getCPUcount();
    f14a:	60 93 98 0c 	sts	0x0C98, r22
    f14e:	70 93 99 0c 	sts	0x0C99, r23
    f152:	80 93 9a 0c 	sts	0x0C9A, r24
    f156:	90 93 9b 0c 	sts	0x0C9B, r25

   returnval = currenttime%10000;
    f15a:	20 e1       	ldi	r18, 0x10	; 16
    f15c:	37 e2       	ldi	r19, 0x27	; 39
    f15e:	40 e0       	ldi	r20, 0x00	; 0
    f160:	50 e0       	ldi	r21, 0x00	; 0
    f162:	0e 94 ab 79 	call	0xf356	; 0xf356 <__udivmodsi4>
    f166:	7a 83       	std	Y+2, r23	; 0x02
    f168:	69 83       	std	Y+1, r22	; 0x01
   
   (*current_thread)->state = 11;
    f16a:	d8 01       	movw	r26, r16
    f16c:	ed 91       	ld	r30, X+
    f16e:	fc 91       	ld	r31, X
    f170:	8b e0       	ldi	r24, 0x0B	; 11
    f172:	82 83       	std	Z+2, r24	; 0x02

   pcByte = ((uint8_t *) (&returnval)) + 1;
 
    
   msg[1] = *pcByte;
    f174:	8a 81       	ldd	r24, Y+2	; 0x02
    f176:	80 93 85 0c 	sts	0x0C85, r24
   pcByte--;
	 msg[0] = *pcByte; 
    f17a:	89 81       	ldd	r24, Y+1	; 0x01
    f17c:	80 93 84 0c 	sts	0x0C84, r24
	 
	 msg[2] = 1; 
    f180:	81 e0       	ldi	r24, 0x01	; 1
    f182:	80 93 86 0c 	sts	0x0C86, r24
uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f186:	4f 93       	push	r20
    f188:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f18a:	ec e1       	ldi	r30, 0x1C	; 28
    f18c:	fa ee       	ldi	r31, 0xEA	; 234
    f18e:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f190:	84 2f       	mov	r24, r20
    f192:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f194:	5f 91       	pop	r21
    f196:	4f 91       	pop	r20
	 msg[3] = getCurrentThreadIndex();
    f198:	80 93 87 0c 	sts	0x0C87, r24
	 
	 mystrcpy(&msg[4], (*current_thread)->threadName);
    f19c:	f8 01       	movw	r30, r16
    f19e:	80 81       	ld	r24, Z
    f1a0:	91 81       	ldd	r25, Z+1	; 0x01
    f1a2:	05 96       	adiw	r24, 0x05	; 5
    f1a4:	68 e8       	ldi	r22, 0x88	; 136
    f1a6:	e6 2e       	mov	r14, r22
    f1a8:	6c e0       	ldi	r22, 0x0C	; 12
    f1aa:	f6 2e       	mov	r15, r22
    f1ac:	97 01       	movw	r18, r14
    f1ae:	a0 e0       	ldi	r26, 0x00	; 0
    f1b0:	b0 e0       	ldi	r27, 0x00	; 0
    f1b2:	04 c0       	rjmp	.+8      	; 0xf1bc <main+0xc2>
void mystrcpy(char *dest, const char *src)
{
	int i;
	i = 0;
	while (src[i]!='\0')
	{ dest[i] = src[i];
    f1b4:	f9 01       	movw	r30, r18
    f1b6:	41 93       	st	Z+, r20
    f1b8:	9f 01       	movw	r18, r30
	i++;
    f1ba:	11 96       	adiw	r26, 0x01	; 1

void mystrcpy(char *dest, const char *src)
{
	int i;
	i = 0;
	while (src[i]!='\0')
    f1bc:	fc 01       	movw	r30, r24
    f1be:	ea 0f       	add	r30, r26
    f1c0:	fb 1f       	adc	r31, r27
    f1c2:	40 81       	ld	r20, Z
    f1c4:	44 23       	and	r20, r20
    f1c6:	b1 f7       	brne	.-20     	; 0xf1b4 <main+0xba>
	{ dest[i] = src[i];
	i++;
	}
	dest[i] = '\0';
    f1c8:	a8 57       	subi	r26, 0x78	; 120
    f1ca:	b3 4f       	sbci	r27, 0xF3	; 243
    f1cc:	1c 92       	st	X, r1
	 
	    
     radioinfoaddr = getCurrentRadioInfoAddr();
    f1ce:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <getCurrentRadioInfoAddr.1422>
    f1d2:	fc 01       	movw	r30, r24


     radioinfoaddr-> socket_port = 65;
    f1d4:	81 e4       	ldi	r24, 0x41	; 65
    f1d6:	90 e0       	ldi	r25, 0x00	; 0
    f1d8:	91 83       	std	Z+1, r25	; 0x01
    f1da:	80 83       	st	Z, r24
     radioinfoaddr->socket_addr = 0;
    f1dc:	13 82       	std	Z+3, r1	; 0x03
    f1de:	12 82       	std	Z+2, r1	; 0x02
     radioinfoaddr->socket_msg_len  = 16;
    f1e0:	80 e1       	ldi	r24, 0x10	; 16
    f1e2:	84 83       	std	Z+4, r24	; 0x04
     radioinfoaddr->socket_msg  = msg;
    f1e4:	84 e8       	ldi	r24, 0x84	; 132
    f1e6:	9c e0       	ldi	r25, 0x0C	; 12
    f1e8:	96 83       	std	Z+6, r25	; 0x06
    f1ea:	85 83       	std	Z+5, r24	; 0x05
thread* mythread;

void sendRadioMsg()
{
 void (*radiosendfp)() = (void (*)(void))SOCKET_RADIO_SEND_FUNCTION;
 radiosendfp();
    f1ec:	e4 e1       	ldi	r30, 0x14	; 20
    f1ee:	fa ee       	ldi	r31, 0xEA	; 234
    f1f0:	09 95       	icall


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f1f2:	e0 e0       	ldi	r30, 0x00	; 0
    f1f4:	fa ee       	ldi	r31, 0xEA	; 234
    f1f6:	09 95       	icall
{
   
	 uint8_t *pcByte;
	 radioinfotype *radioinfoaddr;
	 thread **current_thread; 
   current_thread = getCurrentThread(); 
    f1f8:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1336>
    f1fc:	8c 01       	movw	r16, r24
    
   (*current_thread)->state = 11;
    f1fe:	dc 01       	movw	r26, r24
    f200:	ed 91       	ld	r30, X+
    f202:	fc 91       	ld	r31, X
    f204:	8b e0       	ldi	r24, 0x0B	; 11
    f206:	82 83       	std	Z+2, r24	; 0x02
   pcByte = ((uint8_t *) (&index)) + 1;
 
   
 
    
   msg[1] = *pcByte;
    f208:	8a 81       	ldd	r24, Y+2	; 0x02
    f20a:	80 93 85 0c 	sts	0x0C85, r24
   pcByte--;
   msg[0] = *pcByte; 
    f20e:	89 81       	ldd	r24, Y+1	; 0x01
    f210:	80 93 84 0c 	sts	0x0C84, r24
	 
   msg[2] = 2; 
    f214:	82 e0       	ldi	r24, 0x02	; 2
    f216:	80 93 86 0c 	sts	0x0C86, r24
uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f21a:	4f 93       	push	r20
    f21c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f21e:	ec e1       	ldi	r30, 0x1C	; 28
    f220:	fa ee       	ldi	r31, 0xEA	; 234
    f222:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f224:	84 2f       	mov	r24, r20
    f226:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f228:	5f 91       	pop	r21
    f22a:	4f 91       	pop	r20
   msg[3] = getCurrentThreadIndex();
    f22c:	80 93 87 0c 	sts	0x0C87, r24
	 
   mystrcpy(&msg[4], (*current_thread)->threadName);
    f230:	f8 01       	movw	r30, r16
    f232:	80 81       	ld	r24, Z
    f234:	91 81       	ldd	r25, Z+1	; 0x01
    f236:	05 96       	adiw	r24, 0x05	; 5
    f238:	a0 e0       	ldi	r26, 0x00	; 0
    f23a:	b0 e0       	ldi	r27, 0x00	; 0
    f23c:	04 c0       	rjmp	.+8      	; 0xf246 <main+0x14c>
void mystrcpy(char *dest, const char *src)
{
	int i;
	i = 0;
	while (src[i]!='\0')
	{ dest[i] = src[i];
    f23e:	f7 01       	movw	r30, r14
    f240:	21 93       	st	Z+, r18
    f242:	7f 01       	movw	r14, r30
	i++;
    f244:	11 96       	adiw	r26, 0x01	; 1

void mystrcpy(char *dest, const char *src)
{
	int i;
	i = 0;
	while (src[i]!='\0')
    f246:	fc 01       	movw	r30, r24
    f248:	ea 0f       	add	r30, r26
    f24a:	fb 1f       	adc	r31, r27
    f24c:	20 81       	ld	r18, Z
    f24e:	22 23       	and	r18, r18
    f250:	b1 f7       	brne	.-20     	; 0xf23e <main+0x144>
	{ dest[i] = src[i];
	i++;
	}
	dest[i] = '\0';
    f252:	a8 57       	subi	r26, 0x78	; 120
    f254:	b3 4f       	sbci	r27, 0xF3	; 243
    f256:	1c 92       	st	X, r1
 	 
   radioinfoaddr = getCurrentRadioInfoAddr();
    f258:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <getCurrentRadioInfoAddr.1422>
    f25c:	fc 01       	movw	r30, r24


   radioinfoaddr-> socket_port = 65;
    f25e:	81 e4       	ldi	r24, 0x41	; 65
    f260:	90 e0       	ldi	r25, 0x00	; 0
    f262:	91 83       	std	Z+1, r25	; 0x01
    f264:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = 0;
    f266:	13 82       	std	Z+3, r1	; 0x03
    f268:	12 82       	std	Z+2, r1	; 0x02
   radioinfoaddr->socket_msg_len  = 16;
    f26a:	80 e1       	ldi	r24, 0x10	; 16
    f26c:	84 83       	std	Z+4, r24	; 0x04
   radioinfoaddr->socket_msg  = msg;
    f26e:	84 e8       	ldi	r24, 0x84	; 132
    f270:	9c e0       	ldi	r25, 0x0C	; 12
    f272:	96 83       	std	Z+6, r25	; 0x06
    f274:	85 83       	std	Z+5, r24	; 0x05
    f276:	e4 e1       	ldi	r30, 0x14	; 20
    f278:	fa ee       	ldi	r31, 0xEA	; 234
    f27a:	09 95       	icall


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f27c:	e0 e0       	ldi	r30, 0x00	; 0
    f27e:	fa ee       	ldi	r31, 0xEA	; 234
    f280:	09 95       	icall
   current_thread = getCurrentThread();
   radioinfoaddr = getCurrentRadioInfoAddr();

  // Mutex_lock(msend);

   radioinfoaddr-> socket_port = port;
    f282:	e1 2c       	mov	r14, r1
    f284:	5a ee       	ldi	r21, 0xEA	; 234
    f286:	f5 2e       	mov	r15, r21
    f288:	41 e0       	ldi	r20, 0x01	; 1
    f28a:	24 2e       	mov	r2, r20
    f28c:	31 2c       	mov	r3, r1
   radioinfoaddr->socket_addr = address;
    f28e:	44 24       	eor	r4, r4
    f290:	4a 94       	dec	r4
    f292:	54 2c       	mov	r5, r4
   radioinfoaddr->socket_msg_len  = length;
   radioinfoaddr->socket_msg  = msg;
    f294:	30 e8       	ldi	r19, 0x80	; 128
    f296:	63 2e       	mov	r6, r19
    f298:	3c e0       	ldi	r19, 0x0C	; 12
    f29a:	73 2e       	mov	r7, r19
thread* mythread;

void sendRadioMsg()
{
 void (*radiosendfp)() = (void (*)(void))SOCKET_RADIO_SEND_FUNCTION;
 radiosendfp();
    f29c:	24 e1       	ldi	r18, 0x14	; 20
    f29e:	82 2e       	mov	r8, r18
    f2a0:	2a ee       	ldi	r18, 0xEA	; 234
    f2a2:	92 2e       	mov	r9, r18
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    f2a4:	94 e1       	ldi	r25, 0x14	; 20
    f2a6:	a9 2e       	mov	r10, r25
    f2a8:	b1 2c       	mov	r11, r1
void disableRadioState()
{

   void (*disableradiofp)(void) = (void (*)(void))RESTORE_RADIO_STATE;

   disableradiofp();
    f2aa:	88 eb       	ldi	r24, 0xB8	; 184
    f2ac:	c8 2e       	mov	r12, r24
    f2ae:	8a ee       	ldi	r24, 0xEA	; 234
    f2b0:	d8 2e       	mov	r13, r24
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    f2b2:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1336>
    f2b6:	dc 01       	movw	r26, r24
     
   (*current_thread)->state = 4;
    f2b8:	ed 91       	ld	r30, X+
    f2ba:	fc 91       	ld	r31, X
    f2bc:	11 97       	sbiw	r26, 0x01	; 1
    f2be:	84 e0       	ldi	r24, 0x04	; 4
    f2c0:	82 83       	std	Z+2, r24	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    f2c2:	ed 91       	ld	r30, X+
    f2c4:	fc 91       	ld	r31, X
    f2c6:	ad e7       	ldi	r26, 0x7D	; 125
    f2c8:	b0 e0       	ldi	r27, 0x00	; 0
    f2ca:	b4 8f       	std	Z+28, r27	; 0x1c
    f2cc:	a3 8f       	std	Z+27, r26	; 0x1b


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f2ce:	f7 01       	movw	r30, r14
    f2d0:	09 95       	icall

int get_light()
{
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADC_READ_LIGHT;
   current_thread = getCurrentThread();    
    f2d2:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1336>
    f2d6:	8c 01       	movw	r16, r24
   fp(); 
    f2d8:	e0 e4       	ldi	r30, 0x40	; 64
    f2da:	fa ee       	ldi	r31, 0xEA	; 234
    f2dc:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
    f2de:	d8 01       	movw	r26, r16
    f2e0:	ed 91       	ld	r30, X+
    f2e2:	fc 91       	ld	r31, X
    f2e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    f2e6:	94 8d       	ldd	r25, Z+28	; 0x1c
 
  thread_rollback_snapshot(i);
   while (1)
   {
   	  sleepThread(125);
      reading = get_light(); 
    f2e8:	90 93 81 0c 	sts	0x0C81, r25
    f2ec:	80 93 80 0c 	sts	0x0C80, r24

mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GET_RADIO_MUTEX_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
    f2f0:	4f 93       	push	r20
    f2f2:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f2f4:	e0 e1       	ldi	r30, 0x10	; 16
    f2f6:	fa ee       	ldi	r31, 0xEA	; 234
    f2f8:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f2fa:	84 2f       	mov	r24, r20
    f2fc:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f2fe:	5f 91       	pop	r21
    f300:	4f 91       	pop	r20
   radioinfotype *radioinfoaddr;



   msend = getRadioMutexAddress();
   current_thread = getCurrentThread();
    f302:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1336>
   radioinfoaddr = getCurrentRadioInfoAddr();
    f306:	0e 94 72 78 	call	0xf0e4	; 0xf0e4 <getCurrentRadioInfoAddr.1422>
    f30a:	fc 01       	movw	r30, r24

  // Mutex_lock(msend);

   radioinfoaddr-> socket_port = port;
    f30c:	31 82       	std	Z+1, r3	; 0x01
    f30e:	20 82       	st	Z, r2
   radioinfoaddr->socket_addr = address;
    f310:	53 82       	std	Z+3, r5	; 0x03
    f312:	42 82       	std	Z+2, r4	; 0x02
   radioinfoaddr->socket_msg_len  = length;
    f314:	b2 e0       	ldi	r27, 0x02	; 2
    f316:	b4 83       	std	Z+4, r27	; 0x04
   radioinfoaddr->socket_msg  = msg;
    f318:	76 82       	std	Z+6, r7	; 0x06
    f31a:	65 82       	std	Z+5, r6	; 0x05
thread* mythread;

void sendRadioMsg()
{
 void (*radiosendfp)() = (void (*)(void))SOCKET_RADIO_SEND_FUNCTION;
 radiosendfp();
    f31c:	f4 01       	movw	r30, r8
    f31e:	09 95       	icall
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    f320:	0e 94 67 78 	call	0xf0ce	; 0xf0ce <getCurrentThread.1336>
    f324:	dc 01       	movw	r26, r24
     
   (*current_thread)->state = 4;
    f326:	ed 91       	ld	r30, X+
    f328:	fc 91       	ld	r31, X
    f32a:	11 97       	sbiw	r26, 0x01	; 1
    f32c:	84 e0       	ldi	r24, 0x04	; 4
    f32e:	82 83       	std	Z+2, r24	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    f330:	ed 91       	ld	r30, X+
    f332:	fc 91       	ld	r31, X
    f334:	b4 8e       	std	Z+28, r11	; 0x1c
    f336:	a3 8e       	std	Z+27, r10	; 0x1b


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f338:	f7 01       	movw	r30, r14
    f33a:	09 95       	icall
void disableRadioState()
{

   void (*disableradiofp)(void) = (void (*)(void))RESTORE_RADIO_STATE;

   disableradiofp();
    f33c:	f6 01       	movw	r30, r12
    f33e:	09 95       	icall
    f340:	b8 cf       	rjmp	.-144    	; 0xf2b2 <main+0x1b8>

0000f342 <wakeupMe.3551>:

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
    f342:	e0 91 82 0c 	lds	r30, 0x0C82
    f346:	f0 91 83 0c 	lds	r31, 0x0C83
    f34a:	82 e0       	ldi	r24, 0x02	; 2
    f34c:	82 83       	std	Z+2, r24	; 0x02


void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    f34e:	e8 e6       	ldi	r30, 0x68	; 104
    f350:	fa ee       	ldi	r31, 0xEA	; 234
    f352:	09 95       	icall
  syscall_postThreadTask();
}
    f354:	08 95       	ret

0000f356 <__udivmodsi4>:
    f356:	a1 e2       	ldi	r26, 0x21	; 33
    f358:	1a 2e       	mov	r1, r26
    f35a:	aa 1b       	sub	r26, r26
    f35c:	bb 1b       	sub	r27, r27
    f35e:	fd 01       	movw	r30, r26
    f360:	0d c0       	rjmp	.+26     	; 0xf37c <__udivmodsi4_ep>

0000f362 <__udivmodsi4_loop>:
    f362:	aa 1f       	adc	r26, r26
    f364:	bb 1f       	adc	r27, r27
    f366:	ee 1f       	adc	r30, r30
    f368:	ff 1f       	adc	r31, r31
    f36a:	a2 17       	cp	r26, r18
    f36c:	b3 07       	cpc	r27, r19
    f36e:	e4 07       	cpc	r30, r20
    f370:	f5 07       	cpc	r31, r21
    f372:	20 f0       	brcs	.+8      	; 0xf37c <__udivmodsi4_ep>
    f374:	a2 1b       	sub	r26, r18
    f376:	b3 0b       	sbc	r27, r19
    f378:	e4 0b       	sbc	r30, r20
    f37a:	f5 0b       	sbc	r31, r21

0000f37c <__udivmodsi4_ep>:
    f37c:	66 1f       	adc	r22, r22
    f37e:	77 1f       	adc	r23, r23
    f380:	88 1f       	adc	r24, r24
    f382:	99 1f       	adc	r25, r25
    f384:	1a 94       	dec	r1
    f386:	69 f7       	brne	.-38     	; 0xf362 <__udivmodsi4_loop>
    f388:	60 95       	com	r22
    f38a:	70 95       	com	r23
    f38c:	80 95       	com	r24
    f38e:	90 95       	com	r25
    f390:	9b 01       	movw	r18, r22
    f392:	ac 01       	movw	r20, r24
    f394:	bd 01       	movw	r22, r26
    f396:	cf 01       	movw	r24, r30
    f398:	08 95       	ret

0000f39a <_exit>:
    f39a:	f8 94       	cli

0000f39c <__stop_program>:
    f39c:	ff cf       	rjmp	.-2      	; 0xf39c <__stop_program>
