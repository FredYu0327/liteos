
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000394  00014600  00014600  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000025  00800a5a  00800a5a  00000408  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  00000408  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  00000810  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  00000894  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  000008b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000016b1  00000000  00000000  000008cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002e0  00000000  00000000  00001f80  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000004f1  00000000  00000000  00002260  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000080  00000000  00000000  00002751  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004da  00000000  00000000  000027d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000136  00000000  00000000  00002cab  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  00002de1  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00014600 <__vectors>:
   14600:	0c 94 46 a3 	jmp	0x1468c
   14604:	0c 94 63 a3 	jmp	0x146c6
   14608:	0c 94 63 a3 	jmp	0x146c6
   1460c:	0c 94 63 a3 	jmp	0x146c6
   14610:	0c 94 63 a3 	jmp	0x146c6
   14614:	0c 94 63 a3 	jmp	0x146c6
   14618:	0c 94 63 a3 	jmp	0x146c6
   1461c:	0c 94 63 a3 	jmp	0x146c6
   14620:	0c 94 63 a3 	jmp	0x146c6
   14624:	0c 94 63 a3 	jmp	0x146c6
   14628:	0c 94 63 a3 	jmp	0x146c6
   1462c:	0c 94 63 a3 	jmp	0x146c6
   14630:	0c 94 63 a3 	jmp	0x146c6
   14634:	0c 94 63 a3 	jmp	0x146c6
   14638:	0c 94 63 a3 	jmp	0x146c6
   1463c:	0c 94 63 a3 	jmp	0x146c6
   14640:	0c 94 63 a3 	jmp	0x146c6
   14644:	0c 94 63 a3 	jmp	0x146c6
   14648:	0c 94 63 a3 	jmp	0x146c6
   1464c:	0c 94 63 a3 	jmp	0x146c6
   14650:	0c 94 63 a3 	jmp	0x146c6
   14654:	0c 94 63 a3 	jmp	0x146c6
   14658:	0c 94 63 a3 	jmp	0x146c6
   1465c:	0c 94 63 a3 	jmp	0x146c6
   14660:	0c 94 63 a3 	jmp	0x146c6
   14664:	0c 94 63 a3 	jmp	0x146c6
   14668:	0c 94 63 a3 	jmp	0x146c6
   1466c:	0c 94 63 a3 	jmp	0x146c6
   14670:	0c 94 63 a3 	jmp	0x146c6
   14674:	0c 94 63 a3 	jmp	0x146c6
   14678:	0c 94 63 a3 	jmp	0x146c6
   1467c:	0c 94 63 a3 	jmp	0x146c6
   14680:	0c 94 63 a3 	jmp	0x146c6
   14684:	0c 94 63 a3 	jmp	0x146c6
   14688:	0c 94 63 a3 	jmp	0x146c6

0001468c <__ctors_end>:
   1468c:	11 24       	eor	r1, r1
   1468e:	1f be       	out	0x3f, r1	; 63
   14690:	ca e5       	ldi	r28, 0x5A	; 90
   14692:	db e0       	ldi	r29, 0x0B	; 11
   14694:	de bf       	out	0x3e, r29	; 62
   14696:	cd bf       	out	0x3d, r28	; 61

00014698 <__do_copy_data>:
   14698:	1a e0       	ldi	r17, 0x0A	; 10
   1469a:	aa e5       	ldi	r26, 0x5A	; 90
   1469c:	ba e0       	ldi	r27, 0x0A	; 10
   1469e:	e4 e9       	ldi	r30, 0x94	; 148
   146a0:	f9 e4       	ldi	r31, 0x49	; 73
   146a2:	01 e0       	ldi	r16, 0x01	; 1
   146a4:	0b bf       	out	0x3b, r16	; 59
   146a6:	02 c0       	rjmp	.+4      	; 0x146ac
   146a8:	07 90       	elpm	r0, Z+
   146aa:	0d 92       	st	X+, r0
   146ac:	aa 35       	cpi	r26, 0x5A	; 90
   146ae:	b1 07       	cpc	r27, r17
   146b0:	d9 f7       	brne	.-10     	; 0x146a8

000146b2 <__do_clear_bss>:
   146b2:	1a e0       	ldi	r17, 0x0A	; 10
   146b4:	aa e5       	ldi	r26, 0x5A	; 90
   146b6:	ba e0       	ldi	r27, 0x0A	; 10
   146b8:	01 c0       	rjmp	.+2      	; 0x146bc

000146ba <.do_clear_bss_loop>:
   146ba:	1d 92       	st	X+, r1

000146bc <.do_clear_bss_start>:
   146bc:	af 37       	cpi	r26, 0x7F	; 127
   146be:	b1 07       	cpc	r27, r17
   146c0:	e1 f7       	brne	.-8      	; 0x146ba
   146c2:	0c 94 87 a3 	jmp	0x1470e

000146c6 <__bad_interrupt>:
   146c6:	0c 94 00 a3 	jmp	0x14600

000146ca <getCurrentThread.1394>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   146ca:	4f 93       	push	r20
   146cc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   146ce:	ec e0       	ldi	r30, 0x0C	; 12
   146d0:	fa ee       	ldi	r31, 0xEA	; 234
   146d2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   146d4:	84 2f       	mov	r24, r20
   146d6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   146d8:	5f 91       	pop	r21
   146da:	4f 91       	pop	r20
   146dc:	08 95       	ret

000146de <yield.1393>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
   146de:	e0 e0       	ldi	r30, 0x00	; 0
   146e0:	fa ee       	ldi	r31, 0xEA	; 234
   146e2:	09 95       	icall
   146e4:	08 95       	ret

000146e6 <sleepThread.1392>:
   146e6:	0f 93       	push	r16
   146e8:	1f 93       	push	r17
   146ea:	8c 01       	movw	r16, r24
   146ec:	0e 94 65 a3 	call	0x146ca
   146f0:	dc 01       	movw	r26, r24
   146f2:	ed 91       	ld	r30, X+
   146f4:	fc 91       	ld	r31, X
   146f6:	11 97       	sbiw	r26, 0x01	; 1
   146f8:	84 e0       	ldi	r24, 0x04	; 4
   146fa:	82 83       	std	Z+2, r24	; 0x02
   146fc:	ed 91       	ld	r30, X+
   146fe:	fc 91       	ld	r31, X
   14700:	14 8f       	std	Z+28, r17	; 0x1c
   14702:	03 8f       	std	Z+27, r16	; 0x1b
   14704:	0e 94 6f a3 	call	0x146de
   14708:	1f 91       	pop	r17
   1470a:	0f 91       	pop	r16
   1470c:	08 95       	ret

0001470e <main>:
uint16_t sig; 
uint16_t incomingnode; 

int main()
{
   1470e:	bf 92       	push	r11
   14710:	cf 92       	push	r12
   14712:	df 92       	push	r13
   14714:	ef 92       	push	r14
   14716:	ff 92       	push	r15
   14718:	0f 93       	push	r16
   1471a:	1f 93       	push	r17
   1471c:	cf 93       	push	r28
   1471e:	df 93       	push	r29


 fromnode = tonode = 100;
   14720:	84 e6       	ldi	r24, 0x64	; 100
   14722:	80 93 6f 0a 	sts	0x0A6F, r24
 fromnode = 2; 
   14726:	82 e0       	ldi	r24, 0x02	; 2
   14728:	80 93 6e 0a 	sts	0x0A6E, r24
 
 
 __asm__ __volatile__("sei" ::); 
   1472c:	78 94       	sei
	{

	   int ret;
	   void (*fp)(void) = (void (*)(void))GET_NODE_ID_FUNCTION;
	   asm volatile("push r20" "\n\t"
   1472e:	4f 93       	push	r20
   14730:	5f 93       	push	r21
					"push r21" "\n\t"
					::);
	   fp();
   14732:	ec ec       	ldi	r30, 0xCC	; 204
   14734:	fa ee       	ldi	r31, 0xEA	; 234
   14736:	09 95       	icall
	   asm volatile(" mov %A0, r20" "\n\t"
   14738:	84 2f       	mov	r24, r20
   1473a:	95 2f       	mov	r25, r21
					  "mov %B0, r21" "\n\t"
					 :"=r" (ret)
					 :
					);
	   asm volatile("pop r21" "\n\t"
   1473c:	5f 91       	pop	r21
   1473e:	4f 91       	pop	r20
 
    nodeid = getnodeID();
   14740:	90 93 71 0a 	sts	0x0A71, r25
   14744:	80 93 70 0a 	sts	0x0A70, r24
	
	

  while (1)
  	{
  	 
      if (nodeid == fromnode)
   14748:	80 91 6e 0a 	lds	r24, 0x0A6E
   1474c:	99 27       	eor	r25, r25
   1474e:	20 91 70 0a 	lds	r18, 0x0A70
   14752:	30 91 71 0a 	lds	r19, 0x0A71
   14756:	28 17       	cp	r18, r24
   14758:	39 07       	cpc	r19, r25
   1475a:	09 f0       	breq	.+2      	; 0x1475e
   1475c:	95 c0       	rjmp	.+298    	; 0x14888
   1475e:	4f 93       	push	r20
   14760:	5f 93       	push	r21
   14762:	ec eb       	ldi	r30, 0xBC	; 188
   14764:	fa ee       	ldi	r31, 0xEA	; 234
   14766:	09 95       	icall
   14768:	24 2f       	mov	r18, r20
   1476a:	35 2f       	mov	r19, r21
   1476c:	5f 91       	pop	r21
   1476e:	4f 91       	pop	r20
      {    

      sig = rnd(); 
   14770:	30 93 73 0a 	sts	0x0A73, r19
   14774:	20 93 72 0a 	sts	0x0A72, r18
      msg[0] = nodeid%256;
   14778:	80 91 70 0a 	lds	r24, 0x0A70
   1477c:	90 91 71 0a 	lds	r25, 0x0A71
   14780:	80 93 5a 0a 	sts	0x0A5A, r24
			msg[1] = nodeid/256;
   14784:	89 2f       	mov	r24, r25
   14786:	99 27       	eor	r25, r25
   14788:	80 93 5b 0a 	sts	0x0A5B, r24
			msg[2] = sig%256;
   1478c:	20 93 5c 0a 	sts	0x0A5C, r18
			msg[3] = sig/256;
   14790:	23 2f       	mov	r18, r19
   14792:	33 27       	eor	r19, r19
   14794:	20 93 5d 0a 	sts	0x0A5D, r18
			msg[4] = 90; 
   14798:	8a e5       	ldi	r24, 0x5A	; 90
   1479a:	80 93 5e 0a 	sts	0x0A5E, r24
			msg[5] = 0xff;
   1479e:	8f ef       	ldi	r24, 0xFF	; 255
   147a0:	80 93 5f 0a 	sts	0x0A5F, r24
			msg[6] = 0xff;
   147a4:	80 93 60 0a 	sts	0x0A60, r24
			msg[7] = 'h';
   147a8:	88 e6       	ldi	r24, 0x68	; 104
   147aa:	80 93 61 0a 	sts	0x0A61, r24
			msg[8] = 'e';
   147ae:	85 e6       	ldi	r24, 0x65	; 101
   147b0:	80 93 62 0a 	sts	0x0A62, r24
			msg[9] = 'l';
   147b4:	8c e6       	ldi	r24, 0x6C	; 108
   147b6:	80 93 63 0a 	sts	0x0A63, r24
			msg[10] = 'l';
   147ba:	80 93 64 0a 	sts	0x0A64, r24
			msg[11] = 'o';
   147be:	8f e6       	ldi	r24, 0x6F	; 111
   147c0:	80 93 65 0a 	sts	0x0A65, r24
			msg[12] = 0;
   147c4:	10 92 66 0a 	sts	0x0A66, r1
mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GET_RADIO_MUTEX_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   147c8:	4f 93       	push	r20
   147ca:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   147cc:	e0 e1       	ldi	r30, 0x10	; 16
   147ce:	fa ee       	ldi	r31, 0xEA	; 234
   147d0:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   147d2:	c4 2f       	mov	r28, r20
   147d4:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   147d6:	5f 91       	pop	r21
   147d8:	4f 91       	pop	r20



   msend = getRadioMutexAddress();
   current_thread = getCurrentThread();
   147da:	0e 94 65 a3 	call	0x146ca
   147de:	4f 93       	push	r20
   147e0:	5f 93       	push	r21
   147e2:	ec e5       	ldi	r30, 0x5C	; 92
   147e4:	fa ee       	ldi	r31, 0xEA	; 234
   147e6:	09 95       	icall
   147e8:	04 2f       	mov	r16, r20
   147ea:	15 2f       	mov	r17, r21
   147ec:	5f 91       	pop	r21
   147ee:	4f 91       	pop	r20
   147f0:	0e 94 65 a3 	call	0x146ca
   147f4:	7c 01       	movw	r14, r24
   147f6:	4f 93       	push	r20
   147f8:	5f 93       	push	r21
   147fa:	ec e1       	ldi	r30, 0x1C	; 28
   147fc:	fa ee       	ldi	r31, 0xEA	; 234
   147fe:	09 95       	icall
   14800:	c4 2e       	mov	r12, r20
   14802:	d5 2e       	mov	r13, r21
   14804:	5f 91       	pop	r21
   14806:	4f 91       	pop	r20
   14808:	bf b6       	in	r11, 0x3f	; 63
   1480a:	f8 94       	cli
   1480c:	88 81       	ld	r24, Y
   1480e:	88 23       	and	r24, r24
   14810:	91 f0       	breq	.+36     	; 0x14836
   14812:	d7 01       	movw	r26, r14
   14814:	ed 91       	ld	r30, X+
   14816:	fc 91       	ld	r31, X
   14818:	11 97       	sbiw	r26, 0x01	; 1
   1481a:	83 e0       	ldi	r24, 0x03	; 3
   1481c:	82 83       	std	Z+2, r24	; 0x02
   1481e:	ed 91       	ld	r30, X+
   14820:	fc 91       	ld	r31, X
   14822:	d4 8f       	std	Z+28, r29	; 0x1c
   14824:	c3 8f       	std	Z+27, r28	; 0x1b
   14826:	89 81       	ldd	r24, Y+1	; 0x01
   14828:	8f 5f       	subi	r24, 0xFF	; 255
   1482a:	89 83       	std	Y+1, r24	; 0x01
   1482c:	0e 94 6f a3 	call	0x146de
   14830:	89 81       	ldd	r24, Y+1	; 0x01
   14832:	81 50       	subi	r24, 0x01	; 1
   14834:	89 83       	std	Y+1, r24	; 0x01
   14836:	81 e0       	ldi	r24, 0x01	; 1
   14838:	88 83       	st	Y, r24
   1483a:	8c 2d       	mov	r24, r12
   1483c:	99 27       	eor	r25, r25
   1483e:	8a 83       	std	Y+2, r24	; 0x02
   14840:	8b 2d       	mov	r24, r11
   14842:	99 27       	eor	r25, r25
   14844:	8f bf       	out	0x3f, r24	; 63
   radioinfoaddr = getCurrentRadioInfoAddr();

   Mutex_lock(msend);

   radioinfoaddr-> socket_port = port;
   14846:	84 e1       	ldi	r24, 0x14	; 20
   14848:	90 e0       	ldi	r25, 0x00	; 0
   1484a:	f8 01       	movw	r30, r16
   1484c:	91 83       	std	Z+1, r25	; 0x01
   1484e:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address;
   14850:	13 82       	std	Z+3, r1	; 0x03
   14852:	12 82       	std	Z+2, r1	; 0x02
   radioinfoaddr->socket_msg_len  = length;
   14854:	80 e1       	ldi	r24, 0x10	; 16
   14856:	84 83       	std	Z+4, r24	; 0x04
   radioinfoaddr->socket_msg  = msg;
   14858:	8a e5       	ldi	r24, 0x5A	; 90
   1485a:	9a e0       	ldi	r25, 0x0A	; 10
   1485c:	96 83       	std	Z+6, r25	; 0x06
   1485e:	85 83       	std	Z+5, r24	; 0x05
   14860:	e4 e1       	ldi	r30, 0x14	; 20
   14862:	fa ee       	ldi	r31, 0xEA	; 234
   14864:	09 95       	icall

   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg();

   sleepThread(30);
   14866:	8e e1       	ldi	r24, 0x1E	; 30
   14868:	90 e0       	ldi	r25, 0x00	; 0
   1486a:	0e 94 73 a3 	call	0x146e6
   1486e:	e8 eb       	ldi	r30, 0xB8	; 184
   14870:	fa ee       	ldi	r31, 0xEA	; 234
   14872:	09 95       	icall
   14874:	4f 93       	push	r20
   14876:	5f 93       	push	r21
   14878:	4c 2f       	mov	r20, r28
   1487a:	5d 2f       	mov	r21, r29
   1487c:	e8 e1       	ldi	r30, 0x18	; 24
   1487e:	fa ee       	ldi	r31, 0xEA	; 234
   14880:	09 95       	icall
   14882:	5f 91       	pop	r21
   14884:	4f 91       	pop	r20
   14886:	57 c0       	rjmp	.+174    	; 0x14936

   disableRadioState();


   Mutex_unlock(msend);

   return;
}



//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
  syscall_postThreadTask();


}





int radioReceive(uint16_t port, uint8_t maxlength, uint8_t *msg)

{


   thread** current_thread;

   _atomic_t currentatomic;


   radiohandletype *radiohandleaddr;


   void (*getaddrfp)(void) = (void (*)(void))REGISTER_RADIO_RECEIVE_EVENT;

   current_thread = getCurrentThread();
   14888:	0e 94 65 a3 	call	0x146ca
   1488c:	7c 01       	movw	r14, r24
   1488e:	4f 93       	push	r20
   14890:	5f 93       	push	r21
   14892:	e0 e6       	ldi	r30, 0x60	; 96
   14894:	fa ee       	ldi	r31, 0xEA	; 234
   14896:	09 95       	icall
   14898:	e4 2f       	mov	r30, r20
   1489a:	f5 2f       	mov	r31, r21
   1489c:	5f 91       	pop	r21
   1489e:	4f 91       	pop	r20

   radiohandleaddr = getCurrentRadioHandleAddr();

   //set up the radiohandleaddr data structures

   radiohandleaddr->port = port;
   148a0:	8a e5       	ldi	r24, 0x5A	; 90
   148a2:	90 e0       	ldi	r25, 0x00	; 0
   148a4:	91 83       	std	Z+1, r25	; 0x01
   148a6:	80 83       	st	Z, r24
   radiohandleaddr->maxLength = maxlength;
   148a8:	80 e1       	ldi	r24, 0x10	; 16
   148aa:	82 83       	std	Z+2, r24	; 0x02
   radiohandleaddr->dataReady = &radioReceiveDataReady;
   148ac:	86 e7       	ldi	r24, 0x76	; 118
   148ae:	9a e0       	ldi	r25, 0x0A	; 10
   148b0:	94 83       	std	Z+4, r25	; 0x04
   148b2:	83 83       	std	Z+3, r24	; 0x03
   radiohandleaddr->data = msg;
   148b4:	8a e5       	ldi	r24, 0x5A	; 90
   148b6:	9a e0       	ldi	r25, 0x0A	; 10
   148b8:	96 83       	std	Z+6, r25	; 0x06
   148ba:	85 83       	std	Z+5, r24	; 0x05
   radiohandleaddr->packetinfo = radioReceivePacketInfo;
   148bc:	87 e7       	ldi	r24, 0x77	; 119
   148be:	9a e0       	ldi	r25, 0x0A	; 10
   148c0:	90 87       	std	Z+8, r25	; 0x08
   148c2:	87 83       	std	Z+7, r24	; 0x07
   radiohandleaddr->handlefunc = wakeupMe;
   148c4:	84 ea       	ldi	r24, 0xA4	; 164
   148c6:	94 ea       	ldi	r25, 0xA4	; 164
   148c8:	93 87       	std	Z+11, r25	; 0x0b
   148ca:	82 87       	std	Z+10, r24	; 0x0a
   148cc:	0f b7       	in	r16, 0x3f	; 63
   148ce:	f8 94       	cli


   //close the interrupt
	currentatomic = _atomic_start();
   148d0:	11 27       	eor	r17, r17

   //call the radio handle set to store the data structure into the handle vectors
    getaddrfp();
   148d2:	e4 e6       	ldi	r30, 0x64	; 100
   148d4:	fa ee       	ldi	r31, 0xEA	; 234
   148d6:	09 95       	icall


   //set up the current thread into sleep mode
   (*current_thread)->state = STATE_SLEEP;
   148d8:	d7 01       	movw	r26, r14
   148da:	ed 91       	ld	r30, X+
   148dc:	fc 91       	ld	r31, X
   148de:	11 97       	sbiw	r26, 0x01	; 1
   148e0:	85 e0       	ldi	r24, 0x05	; 5
   148e2:	82 83       	std	Z+2, r24	; 0x02

   //set up mythread so that later can wake up this thread
   mythread = *current_thread;
   148e4:	8d 91       	ld	r24, X+
   148e6:	9c 91       	ld	r25, X
   148e8:	90 93 7c 0a 	sts	0x0A7C, r25
   148ec:	80 93 7b 0a 	sts	0x0A7B, r24
   148f0:	0f bf       	out	0x3f, r16	; 63


   //open the interrupt
   _atomic_end(currentatomic);

    yield();
   148f2:	0e 94 6f a3 	call	0x146de
	    radioSend(20, 0, 16, msg);
//			redToggle(); 
			 
           
      }
    else 
 	  {
			    radioReceive(90, 16, msg); 
		      incomingnode = (uint16_t)msg[0]+ (((uint16_t)msg[1]) *256); 
   148f6:	20 91 5a 0a 	lds	r18, 0x0A5A
   148fa:	80 91 5b 0a 	lds	r24, 0x0A5B
   148fe:	99 27       	eor	r25, r25
   14900:	98 2f       	mov	r25, r24
   14902:	88 27       	eor	r24, r24
   14904:	82 0f       	add	r24, r18
   14906:	91 1d       	adc	r25, r1
   14908:	90 93 75 0a 	sts	0x0A75, r25
   1490c:	80 93 74 0a 	sts	0x0A74, r24
			  
			    if (incomingnode%3==0)						  
   14910:	63 e0       	ldi	r22, 0x03	; 3
   14912:	70 e0       	ldi	r23, 0x00	; 0
   14914:	0e 94 b6 a4 	call	0x1496c
   14918:	00 97       	sbiw	r24, 0x00	; 0
   1491a:	21 f4       	brne	.+8      	; 0x14924
void yellowToggle()
{
                          
  void (*yellowfp)() = (void (*)(void))YELLOW_TOGGLE_FUNCTION; 
  yellowfp();    
   1491c:	e0 e7       	ldi	r30, 0x70	; 112
   1491e:	fa ee       	ldi	r31, 0xEA	; 234
   14920:	09 95       	icall
   14922:	09 c0       	rjmp	.+18     	; 0x14936
 				yellowToggle();
				else if (incomingnode%3==1)		
   14924:	01 97       	sbiw	r24, 0x01	; 1
   14926:	21 f4       	brne	.+8      	; 0x14930
   14928:	e8 e0       	ldi	r30, 0x08	; 8
   1492a:	fa ee       	ldi	r31, 0xEA	; 234
   1492c:	09 95       	icall
   1492e:	03 c0       	rjmp	.+6      	; 0x14936
   14930:	e4 e0       	ldi	r30, 0x04	; 4
   14932:	fa ee       	ldi	r31, 0xEA	; 234
   14934:	09 95       	icall
					redToggle();
				else
					greenToggle(); 
				
				
	  }
	sleepThread(2000);
   14936:	80 ed       	ldi	r24, 0xD0	; 208
   14938:	97 e0       	ldi	r25, 0x07	; 7
   1493a:	0e 94 73 a3 	call	0x146e6
   1493e:	04 cf       	rjmp	.-504    	; 0x14748

00014940 <syscall_postThreadTask.1400>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
   14940:	e8 e6       	ldi	r30, 0x68	; 104
   14942:	fa ee       	ldi	r31, 0xEA	; 234
   14944:	09 95       	icall
   14946:	08 95       	ret

00014948 <wakeupMe.3156>:
   14948:	e0 91 7b 0a 	lds	r30, 0x0A7B
   1494c:	f0 91 7c 0a 	lds	r31, 0x0A7C
   14950:	82 e0       	ldi	r24, 0x02	; 2
   14952:	82 83       	std	Z+2, r24	; 0x02
   14954:	0e 94 a0 a4 	call	0x14940
   14958:	08 95       	ret

0001495a <wakeupMeSerial.3443>:
//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE;
   1495a:	e0 91 7d 0a 	lds	r30, 0x0A7D
   1495e:	f0 91 7e 0a 	lds	r31, 0x0A7E
   14962:	82 e0       	ldi	r24, 0x02	; 2
   14964:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14966:	0e 94 a0 a4 	call	0x14940
   1496a:	08 95       	ret

0001496c <__udivmodhi4>:
   1496c:	aa 1b       	sub	r26, r26
   1496e:	bb 1b       	sub	r27, r27
   14970:	51 e1       	ldi	r21, 0x11	; 17
   14972:	07 c0       	rjmp	.+14     	; 0x14982

00014974 <__udivmodhi4_loop>:
   14974:	aa 1f       	adc	r26, r26
   14976:	bb 1f       	adc	r27, r27
   14978:	a6 17       	cp	r26, r22
   1497a:	b7 07       	cpc	r27, r23
   1497c:	10 f0       	brcs	.+4      	; 0x14982
   1497e:	a6 1b       	sub	r26, r22
   14980:	b7 0b       	sbc	r27, r23

00014982 <__udivmodhi4_ep>:
   14982:	88 1f       	adc	r24, r24
   14984:	99 1f       	adc	r25, r25
   14986:	5a 95       	dec	r21
   14988:	a9 f7       	brne	.-22     	; 0x14974
   1498a:	80 95       	com	r24
   1498c:	90 95       	com	r25
   1498e:	bc 01       	movw	r22, r24
   14990:	cd 01       	movw	r24, r26
   14992:	08 95       	ret
