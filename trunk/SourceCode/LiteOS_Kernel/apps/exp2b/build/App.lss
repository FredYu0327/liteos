
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800c12  00017a66  000002fa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000266  00017800  00017800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000004  00800c20  00800c20  00000308  2**0
                  ALLOC
  3 .stab         00000408  00000000  00000000  00000308  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000084  00000000  00000000  00000710  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  00000794  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000001b  00000000  00000000  000007b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001999  00000000  00000000  000007cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000248  00000000  00000000  00002168  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000344  00000000  00000000  000023b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000070  00000000  00000000  000026f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000427  00000000  00000000  00002764  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000060  00000000  00000000  00002b8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  00002beb  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00017800 <__vectors>:
   17800:	0c 94 46 bc 	jmp	0x1788c
   17804:	0c 94 63 bc 	jmp	0x178c6
   17808:	0c 94 63 bc 	jmp	0x178c6
   1780c:	0c 94 63 bc 	jmp	0x178c6
   17810:	0c 94 63 bc 	jmp	0x178c6
   17814:	0c 94 63 bc 	jmp	0x178c6
   17818:	0c 94 63 bc 	jmp	0x178c6
   1781c:	0c 94 63 bc 	jmp	0x178c6
   17820:	0c 94 63 bc 	jmp	0x178c6
   17824:	0c 94 63 bc 	jmp	0x178c6
   17828:	0c 94 63 bc 	jmp	0x178c6
   1782c:	0c 94 63 bc 	jmp	0x178c6
   17830:	0c 94 63 bc 	jmp	0x178c6
   17834:	0c 94 63 bc 	jmp	0x178c6
   17838:	0c 94 63 bc 	jmp	0x178c6
   1783c:	0c 94 63 bc 	jmp	0x178c6
   17840:	0c 94 63 bc 	jmp	0x178c6
   17844:	0c 94 63 bc 	jmp	0x178c6
   17848:	0c 94 63 bc 	jmp	0x178c6
   1784c:	0c 94 63 bc 	jmp	0x178c6
   17850:	0c 94 63 bc 	jmp	0x178c6
   17854:	0c 94 63 bc 	jmp	0x178c6
   17858:	0c 94 63 bc 	jmp	0x178c6
   1785c:	0c 94 63 bc 	jmp	0x178c6
   17860:	0c 94 63 bc 	jmp	0x178c6
   17864:	0c 94 63 bc 	jmp	0x178c6
   17868:	0c 94 63 bc 	jmp	0x178c6
   1786c:	0c 94 63 bc 	jmp	0x178c6
   17870:	0c 94 63 bc 	jmp	0x178c6
   17874:	0c 94 63 bc 	jmp	0x178c6
   17878:	0c 94 63 bc 	jmp	0x178c6
   1787c:	0c 94 63 bc 	jmp	0x178c6
   17880:	0c 94 63 bc 	jmp	0x178c6
   17884:	0c 94 63 bc 	jmp	0x178c6
   17888:	0c 94 63 bc 	jmp	0x178c6

0001788c <__ctors_end>:
   1788c:	11 24       	eor	r1, r1
   1788e:	1f be       	out	0x3f, r1	; 63
   17890:	c8 ea       	ldi	r28, 0xA8	; 168
   17892:	dc e0       	ldi	r29, 0x0C	; 12
   17894:	de bf       	out	0x3e, r29	; 62
   17896:	cd bf       	out	0x3d, r28	; 61

00017898 <__do_copy_data>:
   17898:	1c e0       	ldi	r17, 0x0C	; 12
   1789a:	a2 e1       	ldi	r26, 0x12	; 18
   1789c:	bc e0       	ldi	r27, 0x0C	; 12
   1789e:	e6 e6       	ldi	r30, 0x66	; 102
   178a0:	fa e7       	ldi	r31, 0x7A	; 122
   178a2:	01 e0       	ldi	r16, 0x01	; 1
   178a4:	0b bf       	out	0x3b, r16	; 59
   178a6:	02 c0       	rjmp	.+4      	; 0x178ac
   178a8:	07 90       	elpm	r0, Z+
   178aa:	0d 92       	st	X+, r0
   178ac:	a0 32       	cpi	r26, 0x20	; 32
   178ae:	b1 07       	cpc	r27, r17
   178b0:	d9 f7       	brne	.-10     	; 0x178a8

000178b2 <__do_clear_bss>:
   178b2:	1c e0       	ldi	r17, 0x0C	; 12
   178b4:	a0 e2       	ldi	r26, 0x20	; 32
   178b6:	bc e0       	ldi	r27, 0x0C	; 12
   178b8:	01 c0       	rjmp	.+2      	; 0x178bc

000178ba <.do_clear_bss_loop>:
   178ba:	1d 92       	st	X+, r1

000178bc <.do_clear_bss_start>:
   178bc:	a4 32       	cpi	r26, 0x24	; 36
   178be:	b1 07       	cpc	r27, r17
   178c0:	e1 f7       	brne	.-8      	; 0x178ba
   178c2:	0c 94 80 bc 	jmp	0x17900

000178c6 <__bad_interrupt>:
   178c6:	0c 94 00 bc 	jmp	0x17800

000178ca <getCurrentThread.1404>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   178ca:	4f 93       	push	r20
   178cc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   178ce:	ec e0       	ldi	r30, 0x0C	; 12
   178d0:	fa ee       	ldi	r31, 0xEA	; 234
   178d2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   178d4:	84 2f       	mov	r24, r20
   178d6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   178d8:	5f 91       	pop	r21
   178da:	4f 91       	pop	r20
   178dc:	08 95       	ret

000178de <yield.1403>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}


void **getKernelStackPtr()
	{
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
}







uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
   178de:	e0 e0       	ldi	r30, 0x00	; 0
   178e0:	fa ee       	ldi	r31, 0xEA	; 234
   178e2:	09 95       	icall
   178e4:	08 95       	ret

000178e6 <syscall_postThreadTask.1410>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
   178e6:	e8 e6       	ldi	r30, 0x68	; 104
   178e8:	fa ee       	ldi	r31, 0xEA	; 234
   178ea:	09 95       	icall
   178ec:	08 95       	ret

000178ee <wakeupMe.3684>:
//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
   178ee:	e0 91 20 0c 	lds	r30, 0x0C20
   178f2:	f0 91 21 0c 	lds	r31, 0x0C21
   178f6:	82 e0       	ldi	r24, 0x02	; 2
   178f8:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   178fa:	0e 94 73 bc 	call	0x178e6
   178fe:	08 95       	ret

00017900 <main>:
#define PRG_RDB(addr) pgm_read_byte(addr)
#endif

int main()
{
   17900:	bf 92       	push	r11
   17902:	cf 92       	push	r12
   17904:	df 92       	push	r13
   17906:	ef 92       	push	r14
   17908:	ff 92       	push	r15
   1790a:	0f 93       	push	r16
   1790c:	1f 93       	push	r17
   1790e:	cf 93       	push	r28
   17910:	df 93       	push	r29
 uint16_t index;
 uint8_t index2; 
  thread** current_thread;
 
 __asm__ __volatile__("sei" ::); 
   17912:	78 94       	sei
 

	  
    current_thread = getCurrentThread();  
   17914:	0e 94 65 bc 	call	0x178ca
   17918:	dc 01       	movw	r26, r24
    
 (*current_thread)->ecbptr->share = 700; 
   1791a:	ed 91       	ld	r30, X+
   1791c:	fc 91       	ld	r31, X
   1791e:	11 97       	sbiw	r26, 0x01	; 1
   17920:	05 a0       	ldd	r0, Z+37	; 0x25
   17922:	f6 a1       	ldd	r31, Z+38	; 0x26
   17924:	e0 2d       	mov	r30, r0
   17926:	8c eb       	ldi	r24, 0xBC	; 188
   17928:	81 83       	std	Z+1, r24	; 0x01
   (*current_thread)->ecbptr->totalenergy =  1120000; 
   1792a:	ed 91       	ld	r30, X+
   1792c:	fc 91       	ld	r31, X
   1792e:	05 a0       	ldd	r0, Z+37	; 0x25
   17930:	f6 a1       	ldd	r31, Z+38	; 0x26
   17932:	e0 2d       	mov	r30, r0
   17934:	80 e0       	ldi	r24, 0x00	; 0
   17936:	97 e1       	ldi	r25, 0x17	; 23
   17938:	a1 e1       	ldi	r26, 0x11	; 17
   1793a:	b0 e0       	ldi	r27, 0x00	; 0
   1793c:	83 83       	std	Z+3, r24	; 0x03
   1793e:	94 83       	std	Z+4, r25	; 0x04
   17940:	a5 83       	std	Z+5, r26	; 0x05
   17942:	b6 83       	std	Z+6, r27	; 0x06
   (*current_thread)->ecbptr->remainenergy = 1120000; 
   17944:	87 83       	std	Z+7, r24	; 0x07
   17946:	90 87       	std	Z+8, r25	; 0x08
   17948:	a1 87       	std	Z+9, r26	; 0x09
   1794a:	b2 87       	std	Z+10, r27	; 0x0a
     
   sbi(MCUCR, SM0);
   1794c:	85 b7       	in	r24, 0x35	; 53
   1794e:	88 60       	ori	r24, 0x08	; 8
   17950:	85 bf       	out	0x35, r24	; 53

   sbi(MCUCR, SM1);
   17952:	85 b7       	in	r24, 0x35	; 53
   17954:	80 61       	ori	r24, 0x10	; 16
   17956:	85 bf       	out	0x35, r24	; 53
   cbi(MCUCR, SM2); 
   17958:	85 b7       	in	r24, 0x35	; 53
   1795a:	8b 7f       	andi	r24, 0xFB	; 251
   1795c:	85 bf       	out	0x35, r24	; 53
   sbi(MCUCR, SE);
   1795e:	85 b7       	in	r24, 0x35	; 53
   17960:	80 62       	ori	r24, 0x20	; 32
   17962:	85 bf       	out	0x35, r24	; 53
	  
	    thread** current_thread;
	   _atomic_t currentatomic;
	   
      current_thread = getCurrentThread();      
   17964:	0e 94 65 bc 	call	0x178ca
   17968:	fc 01       	movw	r30, r24

  		 (*current_thread)->ecbptr->remainenergy -= (uint16_t)SERIAL_SEND * (uint16_t)length;           
   1796a:	01 90       	ld	r0, Z+
   1796c:	f0 81       	ld	r31, Z
   1796e:	e0 2d       	mov	r30, r0
   17970:	05 a0       	ldd	r0, Z+37	; 0x25
   17972:	f6 a1       	ldd	r31, Z+38	; 0x26
   17974:	e0 2d       	mov	r30, r0
   17976:	87 81       	ldd	r24, Z+7	; 0x07
   17978:	90 85       	ldd	r25, Z+8	; 0x08
   1797a:	a1 85       	ldd	r26, Z+9	; 0x09
   1797c:	b2 85       	ldd	r27, Z+10	; 0x0a
   1797e:	8e 5b       	subi	r24, 0xBE	; 190
   17980:	94 41       	sbci	r25, 0x14	; 20
   17982:	a0 40       	sbci	r26, 0x00	; 0
   17984:	b0 40       	sbci	r27, 0x00	; 0
   17986:	87 83       	std	Z+7, r24	; 0x07
   17988:	90 87       	std	Z+8, r25	; 0x08
   1798a:	a1 87       	std	Z+9, r26	; 0x09
   1798c:	b2 87       	std	Z+10, r27	; 0x0a
   mutex *msend;   

   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_MUTEX_ADDRESS_FUNCTION;
   
   asm volatile("push r20" "\n\t"
   1798e:	4f 93       	push	r20
   17990:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   17992:	e0 e9       	ldi	r30, 0x90	; 144
   17994:	fa ee       	ldi	r31, 0xEA	; 234
   17996:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17998:	c4 2f       	mov	r28, r20
   1799a:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
   asm volatile("pop r21" "\n\t"
   1799c:	5f 91       	pop	r21
   1799e:	4f 91       	pop	r20
      
      /*		 
   		 
	     currentatomic = _atomic_start();
	     
	     printStringN(msg, length); 
	     
	     _atomic_end(currentatomic); 
	     
	     
	      sleepThread(50);
	     
   		  */      		 
      serialSend(length, msg); 
      
}




void serialSend_uint16(uint16_t value)
{
  uint8_t temp1,temp2;
  temp1 = (uint8_t) (value >> 8);
  temp2 = (uint8_t) (value & 0x00ff);

  serial_buffer[0] = temp1;
  serial_buffer[1] = temp2;
  serial_buffer[2] = serial_buffer[3] = 0xee;

  return serialSend(16, serial_buffer);

}




serialhandletype *getCurrentSerialHandleAddr()
{
   serialhandletype *currentserialhandle;

   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_RECEIVE_HANDLE;

   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentserialhandle)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return currentserialhandle;
}






serialinfotype* getCurrentSerialInfo()
{
   serialinfotype *currentserialinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_SERIAL_SEND_STRUCTURE_ADDRESS;
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentserialinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return currentserialinfo;
}



void serialSend(uint8_t length, uint8_t *msg)
{


   mutex* mserialsend;
   thread** current_thread;
   serialinfotype *serialinfoaddr;



   mserialsend = getSerialMutexAddress();
   current_thread = getCurrentThread();
   179a0:	0e 94 65 bc 	call	0x178ca
   179a4:	4f 93       	push	r20
   179a6:	5f 93       	push	r21
   179a8:	e4 e9       	ldi	r30, 0x94	; 148
   179aa:	fa ee       	ldi	r31, 0xEA	; 234
   179ac:	09 95       	icall
   179ae:	c4 2e       	mov	r12, r20
   179b0:	d5 2e       	mov	r13, r21
   179b2:	5f 91       	pop	r21
   179b4:	4f 91       	pop	r20
   179b6:	0e 94 65 bc 	call	0x178ca
   179ba:	8c 01       	movw	r16, r24
   179bc:	4f 93       	push	r20
   179be:	5f 93       	push	r21
   179c0:	ec e1       	ldi	r30, 0x1C	; 28
   179c2:	fa ee       	ldi	r31, 0xEA	; 234
   179c4:	09 95       	icall
   179c6:	e4 2e       	mov	r14, r20
   179c8:	f5 2e       	mov	r15, r21
   179ca:	5f 91       	pop	r21
   179cc:	4f 91       	pop	r20


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
   179ce:	bf b6       	in	r11, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
   179d0:	f8 94       	cli
   179d2:	88 81       	ld	r24, Y
   179d4:	88 23       	and	r24, r24
   179d6:	91 f0       	breq	.+36     	; 0x179fc
   179d8:	d8 01       	movw	r26, r16
   179da:	ed 91       	ld	r30, X+
   179dc:	fc 91       	ld	r31, X
   179de:	11 97       	sbiw	r26, 0x01	; 1
   179e0:	83 e0       	ldi	r24, 0x03	; 3
   179e2:	82 83       	std	Z+2, r24	; 0x02
   179e4:	ed 91       	ld	r30, X+
   179e6:	fc 91       	ld	r31, X
   179e8:	d4 8f       	std	Z+28, r29	; 0x1c
   179ea:	c3 8f       	std	Z+27, r28	; 0x1b
   179ec:	89 81       	ldd	r24, Y+1	; 0x01
   179ee:	8f 5f       	subi	r24, 0xFF	; 255
   179f0:	89 83       	std	Y+1, r24	; 0x01
   179f2:	0e 94 6f bc 	call	0x178de
   179f6:	89 81       	ldd	r24, Y+1	; 0x01
   179f8:	81 50       	subi	r24, 0x01	; 1
   179fa:	89 83       	std	Y+1, r24	; 0x01
   179fc:	81 e0       	ldi	r24, 0x01	; 1
   179fe:	88 83       	st	Y, r24
   17a00:	8e 2d       	mov	r24, r14
   17a02:	99 27       	eor	r25, r25
   17a04:	8a 83       	std	Y+2, r24	; 0x02
   17a06:	8b 2d       	mov	r24, r11
   17a08:	99 27       	eor	r25, r25
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
   17a0a:	8f bf       	out	0x3f, r24	; 63
   serialinfoaddr = getCurrentSerialInfo();

   Mutex_lock(mserialsend);

   serialinfoaddr->socket_msg_len = length;
   17a0c:	8a e0       	ldi	r24, 0x0A	; 10
   17a0e:	f6 01       	movw	r30, r12
   17a10:	80 83       	st	Z, r24
   serialinfoaddr->socket_msg = msg;
   17a12:	82 e1       	ldi	r24, 0x12	; 18
   17a14:	9c e0       	ldi	r25, 0x0C	; 12
   17a16:	92 83       	std	Z+2, r25	; 0x02
   17a18:	81 83       	std	Z+1, r24	; 0x01
   17a1a:	e8 e9       	ldi	r30, 0x98	; 152
   17a1c:	fa ee       	ldi	r31, 0xEA	; 234
   17a1e:	09 95       	icall
   17a20:	0e 94 65 bc 	call	0x178ca
   17a24:	dc 01       	movw	r26, r24
   17a26:	ed 91       	ld	r30, X+
   17a28:	fc 91       	ld	r31, X
   17a2a:	11 97       	sbiw	r26, 0x01	; 1
   17a2c:	84 e0       	ldi	r24, 0x04	; 4
   17a2e:	82 83       	std	Z+2, r24	; 0x02
   17a30:	ed 91       	ld	r30, X+
   17a32:	fc 91       	ld	r31, X
   17a34:	84 e1       	ldi	r24, 0x14	; 20
   17a36:	90 e0       	ldi	r25, 0x00	; 0
   17a38:	94 8f       	std	Z+28, r25	; 0x1c
   17a3a:	83 8f       	std	Z+27, r24	; 0x1b
   17a3c:	0e 94 6f bc 	call	0x178de
   17a40:	4f 93       	push	r20
   17a42:	5f 93       	push	r21
   17a44:	4c 2f       	mov	r20, r28
   17a46:	5d 2f       	mov	r21, r29
   17a48:	e8 e1       	ldi	r30, 0x18	; 24
   17a4a:	fa ee       	ldi	r31, 0xEA	; 234
   17a4c:	09 95       	icall
   17a4e:	5f 91       	pop	r21
   17a50:	4f 91       	pop	r20
   17a52:	88 cf       	rjmp	.-240    	; 0x17964

00017a54 <wakeupMeSerial.4079>:


   sendSerialMsg();

   sleepThread(20);


   Mutex_unlock(mserialsend);

   return;
}



//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE;
   17a54:	e0 91 22 0c 	lds	r30, 0x0C22
   17a58:	f0 91 23 0c 	lds	r31, 0x0C23
   17a5c:	82 e0       	ldi	r24, 0x02	; 2
   17a5e:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   17a60:	0e 94 73 bc 	call	0x178e6
   17a64:	08 95       	ret
