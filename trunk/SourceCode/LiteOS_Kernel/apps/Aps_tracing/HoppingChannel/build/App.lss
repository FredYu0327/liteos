
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800a5a  0001488c  00000320  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000028c  00014600  00014600  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000004  00800a6a  00800a6a  00000330  2**0
                  ALLOC
  3 .stab         00000408  00000000  00000000  00000330  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000084  00000000  00000000  00000738  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  000007bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000001b  00000000  00000000  000007dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001434  00000000  00000000  000007f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000027d  00000000  00000000  00001c2b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000003a4  00000000  00000000  00001ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000090  00000000  00000000  0000224c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000433  00000000  00000000  000022dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000006b  00000000  00000000  0000270f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  0000277a  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00014600 <__vectors>:
   14600:	0c 94 46 a3 	jmp	0x1468c
   14604:	0c 94 63 a3 	jmp	0x146c6
   14608:	0c 94 63 a3 	jmp	0x146c6
   1460c:	0c 94 63 a3 	jmp	0x146c6
   14610:	0c 94 63 a3 	jmp	0x146c6
   14614:	0c 94 63 a3 	jmp	0x146c6
   14618:	0c 94 63 a3 	jmp	0x146c6
   1461c:	0c 94 63 a3 	jmp	0x146c6
   14620:	0c 94 63 a3 	jmp	0x146c6
   14624:	0c 94 63 a3 	jmp	0x146c6
   14628:	0c 94 63 a3 	jmp	0x146c6
   1462c:	0c 94 63 a3 	jmp	0x146c6
   14630:	0c 94 63 a3 	jmp	0x146c6
   14634:	0c 94 63 a3 	jmp	0x146c6
   14638:	0c 94 63 a3 	jmp	0x146c6
   1463c:	0c 94 63 a3 	jmp	0x146c6
   14640:	0c 94 63 a3 	jmp	0x146c6
   14644:	0c 94 63 a3 	jmp	0x146c6
   14648:	0c 94 63 a3 	jmp	0x146c6
   1464c:	0c 94 63 a3 	jmp	0x146c6
   14650:	0c 94 63 a3 	jmp	0x146c6
   14654:	0c 94 63 a3 	jmp	0x146c6
   14658:	0c 94 63 a3 	jmp	0x146c6
   1465c:	0c 94 63 a3 	jmp	0x146c6
   14660:	0c 94 63 a3 	jmp	0x146c6
   14664:	0c 94 63 a3 	jmp	0x146c6
   14668:	0c 94 63 a3 	jmp	0x146c6
   1466c:	0c 94 63 a3 	jmp	0x146c6
   14670:	0c 94 63 a3 	jmp	0x146c6
   14674:	0c 94 63 a3 	jmp	0x146c6
   14678:	0c 94 63 a3 	jmp	0x146c6
   1467c:	0c 94 63 a3 	jmp	0x146c6
   14680:	0c 94 63 a3 	jmp	0x146c6
   14684:	0c 94 63 a3 	jmp	0x146c6
   14688:	0c 94 63 a3 	jmp	0x146c6

0001468c <__ctors_end>:
   1468c:	11 24       	eor	r1, r1
   1468e:	1f be       	out	0x3f, r1	; 63
   14690:	ca e5       	ldi	r28, 0x5A	; 90
   14692:	db e0       	ldi	r29, 0x0B	; 11
   14694:	de bf       	out	0x3e, r29	; 62
   14696:	cd bf       	out	0x3d, r28	; 61

00014698 <__do_copy_data>:
   14698:	1a e0       	ldi	r17, 0x0A	; 10
   1469a:	aa e5       	ldi	r26, 0x5A	; 90
   1469c:	ba e0       	ldi	r27, 0x0A	; 10
   1469e:	ec e8       	ldi	r30, 0x8C	; 140
   146a0:	f8 e4       	ldi	r31, 0x48	; 72
   146a2:	01 e0       	ldi	r16, 0x01	; 1
   146a4:	0b bf       	out	0x3b, r16	; 59
   146a6:	02 c0       	rjmp	.+4      	; 0x146ac
   146a8:	07 90       	elpm	r0, Z+
   146aa:	0d 92       	st	X+, r0
   146ac:	aa 36       	cpi	r26, 0x6A	; 106
   146ae:	b1 07       	cpc	r27, r17
   146b0:	d9 f7       	brne	.-10     	; 0x146a8

000146b2 <__do_clear_bss>:
   146b2:	1a e0       	ldi	r17, 0x0A	; 10
   146b4:	aa e6       	ldi	r26, 0x6A	; 106
   146b6:	ba e0       	ldi	r27, 0x0A	; 10
   146b8:	01 c0       	rjmp	.+2      	; 0x146bc

000146ba <.do_clear_bss_loop>:
   146ba:	1d 92       	st	X+, r1

000146bc <.do_clear_bss_start>:
   146bc:	ae 36       	cpi	r26, 0x6E	; 110
   146be:	b1 07       	cpc	r27, r17
   146c0:	e1 f7       	brne	.-8      	; 0x146ba
   146c2:	0c 94 92 a3 	jmp	0x14724

000146c6 <__bad_interrupt>:
   146c6:	0c 94 00 a3 	jmp	0x14600

000146ca <setRadioChannel.1469>:
  uint16_t maskchannel = channel;

  void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_CHANNEL_FUNCTION;

  asm volatile("push r20" "\n\t"
   146ca:	4f 93       	push	r20
   146cc:	5f 93       	push	r21
               "push r21" "\n\t"
               ::);

  asm volatile(" mov r20, %A0" "\n\t"
   146ce:	99 27       	eor	r25, r25
   146d0:	48 2f       	mov	r20, r24
   146d2:	59 2f       	mov	r21, r25
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp();
   146d4:	e4 ec       	ldi	r30, 0xC4	; 196
   146d6:	fa ee       	ldi	r31, 0xEA	; 234
   146d8:	09 95       	icall
   asm volatile("pop r21" "\n\t"
   146da:	5f 91       	pop	r21
   146dc:	4f 91       	pop	r20
   146de:	08 95       	ret

000146e0 <getCurrentThread.1403>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   146e0:	4f 93       	push	r20
   146e2:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   146e4:	ec e0       	ldi	r30, 0x0C	; 12
   146e6:	fa ee       	ldi	r31, 0xEA	; 234
   146e8:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   146ea:	84 2f       	mov	r24, r20
   146ec:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   146ee:	5f 91       	pop	r21
   146f0:	4f 91       	pop	r20
   146f2:	08 95       	ret

000146f4 <yield.1402>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
   146f4:	e0 e0       	ldi	r30, 0x00	; 0
   146f6:	fa ee       	ldi	r31, 0xEA	; 234
   146f8:	09 95       	icall
   146fa:	08 95       	ret

000146fc <sleepThread.1401>:
   146fc:	0f 93       	push	r16
   146fe:	1f 93       	push	r17
   14700:	8c 01       	movw	r16, r24
   14702:	0e 94 70 a3 	call	0x146e0
   14706:	dc 01       	movw	r26, r24
   14708:	ed 91       	ld	r30, X+
   1470a:	fc 91       	ld	r31, X
   1470c:	11 97       	sbiw	r26, 0x01	; 1
   1470e:	84 e0       	ldi	r24, 0x04	; 4
   14710:	82 83       	std	Z+2, r24	; 0x02
   14712:	ed 91       	ld	r30, X+
   14714:	fc 91       	ld	r31, X
   14716:	14 8f       	std	Z+28, r17	; 0x1c
   14718:	03 8f       	std	Z+27, r16	; 0x1b
   1471a:	0e 94 7a a3 	call	0x146f4
   1471e:	1f 91       	pop	r17
   14720:	0f 91       	pop	r16
   14722:	08 95       	ret

00014724 <main>:



int main()
{ 
   14724:	6f 92       	push	r6
   14726:	7f 92       	push	r7
   14728:	8f 92       	push	r8
   1472a:	9f 92       	push	r9
   1472c:	af 92       	push	r10
   1472e:	bf 92       	push	r11
   14730:	cf 92       	push	r12
   14732:	df 92       	push	r13
   14734:	ef 92       	push	r14
   14736:	ff 92       	push	r15
   14738:	0f 93       	push	r16
   1473a:	1f 93       	push	r17
   1473c:	cf 93       	push	r28
   1473e:	df 93       	push	r29
   14740:	9b e0       	ldi	r25, 0x0B	; 11
   14742:	a9 2e       	mov	r10, r25

 uint8_t channel;
 
 for (channel = 11;channel <25;channel++)
 { setRadioChannel(channel); 
   14744:	8a 2d       	mov	r24, r10
   14746:	0e 94 65 a3 	call	0x146ca
  
 radioSend_string("Hello, world!\n"); 
   1474a:	8a e5       	ldi	r24, 0x5A	; 90
   1474c:	68 2e       	mov	r6, r24
   1474e:	8a e0       	ldi	r24, 0x0A	; 10
   14750:	78 2e       	mov	r7, r24
   14752:	f3 01       	movw	r30, r6
   14754:	01 c0       	rjmp	.+2      	; 0x14758
   14756:	31 96       	adiw	r30, 0x01	; 1


int String_length(char* s) {
	int count=0;
	while(s[count] != '\0')
   14758:	80 81       	ld	r24, Z
   1475a:	88 23       	and	r24, r24
   1475c:	e1 f7       	brne	.-8      	; 0x14756
   1475e:	ea 55       	subi	r30, 0x5A	; 90
   14760:	fa 40       	sbci	r31, 0x0A	; 10
   14762:	4f 01       	movw	r8, r30
mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GET_RADIO_MUTEX_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   14764:	4f 93       	push	r20
   14766:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   14768:	e0 e1       	ldi	r30, 0x10	; 16
   1476a:	fa ee       	ldi	r31, 0xEA	; 234
   1476c:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   1476e:	c4 2f       	mov	r28, r20
   14770:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   14772:	5f 91       	pop	r21
   14774:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return;
}

void setRadioPower(uint8_t power)
{

  uint16_t maskchannel = power;

  void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_POWER_FUNCTION;

  asm volatile("push r20" "\n\t"
               "push r21" "\n\t"
               ::);

  asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp();
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return;
}



radioinfotype *getCurrentRadioInfoAddr()
{
   radioinfotype *currentradioinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_INFO_ADDR;
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo;
}


void disableRadioState()
{

   void (*disableradiofp)(void) = (void (*)(void))RESTORE_RADIO_STATE;

   disableradiofp();

   return;
}


void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{


   mutex* msend;
   thread** current_thread;
   radioinfotype *radioinfoaddr;



   msend = getRadioMutexAddress();
   current_thread = getCurrentThread();
   14776:	0e 94 70 a3 	call	0x146e0
   1477a:	4f 93       	push	r20
   1477c:	5f 93       	push	r21
   1477e:	ec e5       	ldi	r30, 0x5C	; 92
   14780:	fa ee       	ldi	r31, 0xEA	; 234
   14782:	09 95       	icall
   14784:	04 2f       	mov	r16, r20
   14786:	15 2f       	mov	r17, r21
   14788:	5f 91       	pop	r21
   1478a:	4f 91       	pop	r20
   1478c:	0e 94 70 a3 	call	0x146e0
   14790:	7c 01       	movw	r14, r24
   14792:	4f 93       	push	r20
   14794:	5f 93       	push	r21
   14796:	ec e1       	ldi	r30, 0x1C	; 28
   14798:	fa ee       	ldi	r31, 0xEA	; 234
   1479a:	09 95       	icall
   1479c:	c4 2e       	mov	r12, r20
   1479e:	d5 2e       	mov	r13, r21
   147a0:	5f 91       	pop	r21
   147a2:	4f 91       	pop	r20


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
   147a4:	bf b6       	in	r11, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
   147a6:	f8 94       	cli
   147a8:	88 81       	ld	r24, Y
   147aa:	88 23       	and	r24, r24
   147ac:	91 f0       	breq	.+36     	; 0x147d2
   147ae:	d7 01       	movw	r26, r14
   147b0:	ed 91       	ld	r30, X+
   147b2:	fc 91       	ld	r31, X
   147b4:	11 97       	sbiw	r26, 0x01	; 1
   147b6:	83 e0       	ldi	r24, 0x03	; 3
   147b8:	82 83       	std	Z+2, r24	; 0x02
   147ba:	ed 91       	ld	r30, X+
   147bc:	fc 91       	ld	r31, X
   147be:	d4 8f       	std	Z+28, r29	; 0x1c
   147c0:	c3 8f       	std	Z+27, r28	; 0x1b
   147c2:	89 81       	ldd	r24, Y+1	; 0x01
   147c4:	8f 5f       	subi	r24, 0xFF	; 255
   147c6:	89 83       	std	Y+1, r24	; 0x01
   147c8:	0e 94 7a a3 	call	0x146f4
   147cc:	89 81       	ldd	r24, Y+1	; 0x01
   147ce:	81 50       	subi	r24, 0x01	; 1
   147d0:	89 83       	std	Y+1, r24	; 0x01
   147d2:	81 e0       	ldi	r24, 0x01	; 1
   147d4:	88 83       	st	Y, r24
   147d6:	8c 2d       	mov	r24, r12
   147d8:	99 27       	eor	r25, r25
   147da:	8a 83       	std	Y+2, r24	; 0x02
   147dc:	8b 2d       	mov	r24, r11
   147de:	99 27       	eor	r25, r25
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
   147e0:	8f bf       	out	0x3f, r24	; 63
   radioinfoaddr = getCurrentRadioInfoAddr();

   Mutex_lock(msend);

   radioinfoaddr-> socket_port = port;
   147e2:	81 e0       	ldi	r24, 0x01	; 1
   147e4:	90 e0       	ldi	r25, 0x00	; 0
   147e6:	f8 01       	movw	r30, r16
   147e8:	91 83       	std	Z+1, r25	; 0x01
   147ea:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address;
   147ec:	8f ef       	ldi	r24, 0xFF	; 255
   147ee:	9f ef       	ldi	r25, 0xFF	; 255
   147f0:	93 83       	std	Z+3, r25	; 0x03
   147f2:	82 83       	std	Z+2, r24	; 0x02
   radioinfoaddr->socket_msg_len  = length;
   147f4:	84 82       	std	Z+4, r8	; 0x04
   radioinfoaddr->socket_msg  = msg;
   147f6:	76 82       	std	Z+6, r7	; 0x06
   147f8:	65 82       	std	Z+5, r6	; 0x05
   147fa:	e4 e1       	ldi	r30, 0x14	; 20
   147fc:	fa ee       	ldi	r31, 0xEA	; 234
   147fe:	09 95       	icall

   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg();

   sleepThread(30);
   14800:	8e e1       	ldi	r24, 0x1E	; 30
   14802:	90 e0       	ldi	r25, 0x00	; 0
   14804:	0e 94 7e a3 	call	0x146fc
   14808:	e8 eb       	ldi	r30, 0xB8	; 184
   1480a:	fa ee       	ldi	r31, 0xEA	; 234
   1480c:	09 95       	icall
   1480e:	4f 93       	push	r20
   14810:	5f 93       	push	r21
   14812:	4c 2f       	mov	r20, r28
   14814:	5d 2f       	mov	r21, r29
   14816:	e8 e1       	ldi	r30, 0x18	; 24
   14818:	fa ee       	ldi	r31, 0xEA	; 234
   1481a:	09 95       	icall
   1481c:	5f 91       	pop	r21
   1481e:	4f 91       	pop	r20

void greenToggle()
{
 void (*greenfp)() = (void (*)(void))GREEN_LED_TOGGLE_FUNCTION; 
 greenfp();                              
   14820:	e4 e0       	ldi	r30, 0x04	; 4
   14822:	fa ee       	ldi	r31, 0xEA	; 234
   14824:	09 95       	icall
 greenToggle();
 sleepThread(1000);
   14826:	88 ee       	ldi	r24, 0xE8	; 232
   14828:	93 e0       	ldi	r25, 0x03	; 3
   1482a:	0e 94 7e a3 	call	0x146fc
   1482e:	a3 94       	inc	r10
   14830:	f9 e1       	ldi	r31, 0x19	; 25
   14832:	af 16       	cp	r10, r31
   14834:	09 f0       	breq	.+2      	; 0x14838
   14836:	86 cf       	rjmp	.-244    	; 0x14744

 }
 
 channel = 15; 
 setRadioChannel(channel); 
   14838:	8f e0       	ldi	r24, 0x0F	; 15
   1483a:	0e 94 65 a3 	call	0x146ca
 return 0; 

}
   1483e:	80 e0       	ldi	r24, 0x00	; 0
   14840:	90 e0       	ldi	r25, 0x00	; 0
   14842:	df 91       	pop	r29
   14844:	cf 91       	pop	r28
   14846:	1f 91       	pop	r17
   14848:	0f 91       	pop	r16
   1484a:	ff 90       	pop	r15
   1484c:	ef 90       	pop	r14
   1484e:	df 90       	pop	r13
   14850:	cf 90       	pop	r12
   14852:	bf 90       	pop	r11
   14854:	af 90       	pop	r10
   14856:	9f 90       	pop	r9
   14858:	8f 90       	pop	r8
   1485a:	7f 90       	pop	r7
   1485c:	6f 90       	pop	r6
   1485e:	08 95       	ret

00014860 <syscall_postThreadTask.1409>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
   14860:	e8 e6       	ldi	r30, 0x68	; 104
   14862:	fa ee       	ldi	r31, 0xEA	; 234
   14864:	09 95       	icall
   14866:	08 95       	ret

00014868 <wakeupMe.3112>:

   disableRadioState();


   Mutex_unlock(msend);

   return;
}



//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
   14868:	e0 91 6a 0a 	lds	r30, 0x0A6A
   1486c:	f0 91 6b 0a 	lds	r31, 0x0A6B
   14870:	82 e0       	ldi	r24, 0x02	; 2
   14872:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14874:	0e 94 30 a4 	call	0x14860
   14878:	08 95       	ret

0001487a <wakeupMeSerial.3399>:
//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE;
   1487a:	e0 91 6c 0a 	lds	r30, 0x0A6C
   1487e:	f0 91 6d 0a 	lds	r31, 0x0A6D
   14882:	82 e0       	ldi	r24, 0x02	; 2
   14884:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14886:	0e 94 30 a4 	call	0x14860
   1488a:	08 95       	ret
