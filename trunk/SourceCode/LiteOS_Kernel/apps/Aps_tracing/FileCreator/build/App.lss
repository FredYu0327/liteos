
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000018  00800a5a  00014a88  0000051c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000488  00014600  00014600  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000a  00800a72  00800a72  00000534  2**0
                  ALLOC
  3 .stab         00000408  00000000  00000000  00000534  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000084  00000000  00000000  0000093c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  000009c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000001b  00000000  00000000  000009e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001aa9  00000000  00000000  000009fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000002cc  00000000  00000000  000024a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000005b9  00000000  00000000  00002770  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000f0  00000000  00000000  00002d29  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000004aa  00000000  00000000  00002e19  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000027c  00000000  00000000  000032c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  0000353f  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00014600 <__vectors>:
   14600:	0c 94 46 a3 	jmp	0x1468c
   14604:	0c 94 63 a3 	jmp	0x146c6
   14608:	0c 94 63 a3 	jmp	0x146c6
   1460c:	0c 94 63 a3 	jmp	0x146c6
   14610:	0c 94 63 a3 	jmp	0x146c6
   14614:	0c 94 63 a3 	jmp	0x146c6
   14618:	0c 94 63 a3 	jmp	0x146c6
   1461c:	0c 94 63 a3 	jmp	0x146c6
   14620:	0c 94 63 a3 	jmp	0x146c6
   14624:	0c 94 63 a3 	jmp	0x146c6
   14628:	0c 94 63 a3 	jmp	0x146c6
   1462c:	0c 94 63 a3 	jmp	0x146c6
   14630:	0c 94 63 a3 	jmp	0x146c6
   14634:	0c 94 63 a3 	jmp	0x146c6
   14638:	0c 94 63 a3 	jmp	0x146c6
   1463c:	0c 94 63 a3 	jmp	0x146c6
   14640:	0c 94 63 a3 	jmp	0x146c6
   14644:	0c 94 63 a3 	jmp	0x146c6
   14648:	0c 94 63 a3 	jmp	0x146c6
   1464c:	0c 94 63 a3 	jmp	0x146c6
   14650:	0c 94 63 a3 	jmp	0x146c6
   14654:	0c 94 63 a3 	jmp	0x146c6
   14658:	0c 94 63 a3 	jmp	0x146c6
   1465c:	0c 94 63 a3 	jmp	0x146c6
   14660:	0c 94 63 a3 	jmp	0x146c6
   14664:	0c 94 63 a3 	jmp	0x146c6
   14668:	0c 94 63 a3 	jmp	0x146c6
   1466c:	0c 94 63 a3 	jmp	0x146c6
   14670:	0c 94 63 a3 	jmp	0x146c6
   14674:	0c 94 63 a3 	jmp	0x146c6
   14678:	0c 94 63 a3 	jmp	0x146c6
   1467c:	0c 94 63 a3 	jmp	0x146c6
   14680:	0c 94 63 a3 	jmp	0x146c6
   14684:	0c 94 63 a3 	jmp	0x146c6
   14688:	0c 94 63 a3 	jmp	0x146c6

0001468c <__ctors_end>:
   1468c:	11 24       	eor	r1, r1
   1468e:	1f be       	out	0x3f, r1	; 63
   14690:	ca e5       	ldi	r28, 0x5A	; 90
   14692:	db e0       	ldi	r29, 0x0B	; 11
   14694:	de bf       	out	0x3e, r29	; 62
   14696:	cd bf       	out	0x3d, r28	; 61

00014698 <__do_copy_data>:
   14698:	1a e0       	ldi	r17, 0x0A	; 10
   1469a:	aa e5       	ldi	r26, 0x5A	; 90
   1469c:	ba e0       	ldi	r27, 0x0A	; 10
   1469e:	e8 e8       	ldi	r30, 0x88	; 136
   146a0:	fa e4       	ldi	r31, 0x4A	; 74
   146a2:	01 e0       	ldi	r16, 0x01	; 1
   146a4:	0b bf       	out	0x3b, r16	; 59
   146a6:	02 c0       	rjmp	.+4      	; 0x146ac
   146a8:	07 90       	elpm	r0, Z+
   146aa:	0d 92       	st	X+, r0
   146ac:	a2 37       	cpi	r26, 0x72	; 114
   146ae:	b1 07       	cpc	r27, r17
   146b0:	d9 f7       	brne	.-10     	; 0x146a8

000146b2 <__do_clear_bss>:
   146b2:	1a e0       	ldi	r17, 0x0A	; 10
   146b4:	a2 e7       	ldi	r26, 0x72	; 114
   146b6:	ba e0       	ldi	r27, 0x0A	; 10
   146b8:	01 c0       	rjmp	.+2      	; 0x146bc

000146ba <.do_clear_bss_loop>:
   146ba:	1d 92       	st	X+, r1

000146bc <.do_clear_bss_start>:
   146bc:	ac 37       	cpi	r26, 0x7C	; 124
   146be:	b1 07       	cpc	r27, r17
   146c0:	e1 f7       	brne	.-8      	; 0x146ba
   146c2:	0c 94 27 a4 	jmp	0x1484e

000146c6 <__bad_interrupt>:
   146c6:	0c 94 00 a3 	jmp	0x14600

000146ca <String_length.1432>:

}


int String_length(char* s) {
   146ca:	20 e0       	ldi	r18, 0x00	; 0
   146cc:	30 e0       	ldi	r19, 0x00	; 0
   146ce:	fc 01       	movw	r30, r24
   146d0:	03 c0       	rjmp	.+6      	; 0x146d8
	int count=0;
	while(s[count] != '\0')
		count++;
   146d2:	2f 5f       	subi	r18, 0xFF	; 255
   146d4:	3f 4f       	sbci	r19, 0xFF	; 255
   146d6:	31 96       	adiw	r30, 0x01	; 1
   146d8:	80 81       	ld	r24, Z
   146da:	88 23       	and	r24, r24
   146dc:	d1 f7       	brne	.-12     	; 0x146d2
	return count;
}
   146de:	c9 01       	movw	r24, r18
   146e0:	08 95       	ret

000146e2 <String_append.1442>:




void mystrncpy(char *dest, const char *src, uint16_t n)
{
	uint16_t i;
	for (i=0;i<n;i++)
		dest[i] = src[i];
}


void mystrcpy(char *dest, const char *src)
{
	int i;
	i = 0;
	while (src[i]!='\0')
	{ dest[i] = src[i];
	i++;
	}
	dest[i] = '\0';
}


char dec2char(uint8_t value) {

	if (/*value >= 0) &&*/(value <=9))
		return (char) (value + 0x30);
	else
		return 0;
}


char *String_intToString(int num)
{
	static char temp[7];
	int internal;
	uint8_t length;
	uint8_t i;
	uint8_t offset = 5;
	uint8_t remainder;

	if (num <0)
		internal = -num;
	else
		internal = num;

	temp[6] = '\0';

	do
	{
		remainder = internal%10;
		temp[offset]= dec2char(remainder);
		internal = internal/10;
		offset--;
	}
	while (internal!=0);

	if (num<0)
	{temp[offset] = '-';
	 if (offset ==0)
		 return temp;
	 else
		 offset--;

	}




	{
		length = 7-offset-1;
		for (i=0;i<length;i++)
			temp[i] = temp[i+offset+1];
	}
	return temp;
}



void String_append(char *base, char *string)
{
   146e2:	ef 92       	push	r14
   146e4:	ff 92       	push	r15
   146e6:	0f 93       	push	r16
   146e8:	1f 93       	push	r17
   146ea:	cf 93       	push	r28
   146ec:	df 93       	push	r29
   146ee:	8c 01       	movw	r16, r24
   146f0:	7b 01       	movw	r14, r22

	int length1, length2;
	uint8_t i;
	length1 = String_length(base);
   146f2:	0e 94 65 a3 	call	0x146ca
   146f6:	ec 01       	movw	r28, r24
	length2 = String_length(string);
   146f8:	c7 01       	movw	r24, r14
   146fa:	0e 94 65 a3 	call	0x146ca
   146fe:	ac 01       	movw	r20, r24
   14700:	20 e0       	ldi	r18, 0x00	; 0
   14702:	30 e0       	ldi	r19, 0x00	; 0
   14704:	09 c0       	rjmp	.+18     	; 0x14718
	for (i=0;i<length2;i++)
	{
		base[i+length1] = string[i];
   14706:	fd 01       	movw	r30, r26
   14708:	e0 0f       	add	r30, r16
   1470a:	f1 1f       	adc	r31, r17
   1470c:	ec 0f       	add	r30, r28
   1470e:	fd 1f       	adc	r31, r29
   14710:	ae 0d       	add	r26, r14
   14712:	bf 1d       	adc	r27, r15
   14714:	8c 91       	ld	r24, X
   14716:	80 83       	st	Z, r24
   14718:	a2 2f       	mov	r26, r18
   1471a:	bb 27       	eor	r27, r27
   1471c:	2f 5f       	subi	r18, 0xFF	; 255
   1471e:	3f 4f       	sbci	r19, 0xFF	; 255
   14720:	a4 17       	cp	r26, r20
   14722:	b5 07       	cpc	r27, r21
   14724:	84 f3       	brlt	.-32     	; 0x14706

	}
	base[length1+length2] = '\0';
   14726:	c0 0f       	add	r28, r16
   14728:	d1 1f       	adc	r29, r17
   1472a:	c4 0f       	add	r28, r20
   1472c:	d5 1f       	adc	r29, r21
   1472e:	18 82       	st	Y, r1
   14730:	df 91       	pop	r29
   14732:	cf 91       	pop	r28
   14734:	1f 91       	pop	r17
   14736:	0f 91       	pop	r16
   14738:	ff 90       	pop	r15
   1473a:	ef 90       	pop	r14
   1473c:	08 95       	ret

0001473e <getCurrentThread.1403>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   1473e:	4f 93       	push	r20
   14740:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   14742:	ec e0       	ldi	r30, 0x0C	; 12
   14744:	fa ee       	ldi	r31, 0xEA	; 234
   14746:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   14748:	84 2f       	mov	r24, r20
   1474a:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   1474c:	5f 91       	pop	r21
   1474e:	4f 91       	pop	r20
   14750:	08 95       	ret

00014752 <getCurrentThreadIndex.1404>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
   14752:	4f 93       	push	r20
   14754:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   14756:	ec e1       	ldi	r30, 0x1C	; 28
   14758:	fa ee       	ldi	r31, 0xEA	; 234
   1475a:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   1475c:	84 2f       	mov	r24, r20
   1475e:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
   14760:	5f 91       	pop	r21
   14762:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}
   14764:	99 27       	eor	r25, r25
   14766:	08 95       	ret

00014768 <getFileMutexAddress.1430>:
mutex *getFileMutexAddress()
{
   mutex *mfile;   
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_MUTEX_ADDRESS; 
   asm volatile("push r20" "\n\t"
   14768:	4f 93       	push	r20
   1476a:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   1476c:	e8 e2       	ldi	r30, 0x28	; 40
   1476e:	fa ee       	ldi	r31, 0xEA	; 234
   14770:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   14772:	84 2f       	mov	r24, r20
   14774:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (mfile)
				 :
                );
    asm volatile("pop r21" "\n\t"
   14776:	5f 91       	pop	r21
   14778:	4f 91       	pop	r20
   1477a:	08 95       	ret

0001477c <Mutex_unlock.1424>:
   1477c:	4f 93       	push	r20
   1477e:	5f 93       	push	r21
   14780:	48 2f       	mov	r20, r24
   14782:	59 2f       	mov	r21, r25
   14784:	e8 e1       	ldi	r30, 0x18	; 24
   14786:	fa ee       	ldi	r31, 0xEA	; 234
   14788:	09 95       	icall
   1478a:	5f 91       	pop	r21
   1478c:	4f 91       	pop	r20
   1478e:	08 95       	ret

00014790 <mystrcpy.1439>:
   14790:	dc 01       	movw	r26, r24
   14792:	fb 01       	movw	r30, r22
   14794:	02 c0       	rjmp	.+4      	; 0x1479a
   14796:	8d 93       	st	X+, r24
   14798:	31 96       	adiw	r30, 0x01	; 1
   1479a:	80 81       	ld	r24, Z
   1479c:	88 23       	and	r24, r24
   1479e:	d9 f7       	brne	.-10     	; 0x14796
   147a0:	1c 92       	st	X, r1
   147a2:	08 95       	ret

000147a4 <yield.1402>:


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
   147a4:	e0 e0       	ldi	r30, 0x00	; 0
   147a6:	fa ee       	ldi	r31, 0xEA	; 234
   147a8:	09 95       	icall
   147aa:	08 95       	ret

000147ac <Barrier_block.1429>:
   147ac:	ef 92       	push	r14
   147ae:	ff 92       	push	r15
   147b0:	0f 93       	push	r16
   147b2:	1f 93       	push	r17
   147b4:	f8 2e       	mov	r15, r24
   147b6:	e6 2e       	mov	r14, r22
   147b8:	0e 94 9f a3 	call	0x1473e
   147bc:	dc 01       	movw	r26, r24


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
   147be:	0f b7       	in	r16, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
   147c0:	f8 94       	cli
   147c2:	11 27       	eor	r17, r17
   147c4:	ed 91       	ld	r30, X+
   147c6:	fc 91       	ld	r31, X
   147c8:	11 97       	sbiw	r26, 0x01	; 1
   147ca:	86 e0       	ldi	r24, 0x06	; 6
   147cc:	82 83       	std	Z+2, r24	; 0x02
   147ce:	ed 91       	ld	r30, X+
   147d0:	fc 91       	ld	r31, X
   147d2:	11 97       	sbiw	r26, 0x01	; 1
   147d4:	f3 8e       	std	Z+27, r15	; 0x1b
   147d6:	ed 91       	ld	r30, X+
   147d8:	fc 91       	ld	r31, X
   147da:	e4 8e       	std	Z+28, r14	; 0x1c
   147dc:	0e 94 d2 a3 	call	0x147a4
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
   147e0:	0f bf       	out	0x3f, r16	; 63
   147e2:	1f 91       	pop	r17
   147e4:	0f 91       	pop	r16
   147e6:	ff 90       	pop	r15
   147e8:	ef 90       	pop	r14
   147ea:	08 95       	ret

000147ec <Mutex_lock.1422>:
   147ec:	ef 92       	push	r14
   147ee:	ff 92       	push	r15
   147f0:	0f 93       	push	r16
   147f2:	1f 93       	push	r17
   147f4:	cf 93       	push	r28
   147f6:	df 93       	push	r29
   147f8:	ec 01       	movw	r28, r24
   147fa:	0e 94 9f a3 	call	0x1473e
   147fe:	8c 01       	movw	r16, r24
   14800:	0e 94 a9 a3 	call	0x14752
   14804:	e8 2e       	mov	r14, r24
   14806:	ff b6       	in	r15, 0x3f	; 63
   14808:	f8 94       	cli
   1480a:	88 81       	ld	r24, Y
   1480c:	88 23       	and	r24, r24
   1480e:	91 f0       	breq	.+36     	; 0x14834
   14810:	d8 01       	movw	r26, r16
   14812:	ed 91       	ld	r30, X+
   14814:	fc 91       	ld	r31, X
   14816:	11 97       	sbiw	r26, 0x01	; 1
   14818:	83 e0       	ldi	r24, 0x03	; 3
   1481a:	82 83       	std	Z+2, r24	; 0x02
   1481c:	ed 91       	ld	r30, X+
   1481e:	fc 91       	ld	r31, X
   14820:	d4 8f       	std	Z+28, r29	; 0x1c
   14822:	c3 8f       	std	Z+27, r28	; 0x1b
   14824:	89 81       	ldd	r24, Y+1	; 0x01
   14826:	8f 5f       	subi	r24, 0xFF	; 255
   14828:	89 83       	std	Y+1, r24	; 0x01
   1482a:	0e 94 d2 a3 	call	0x147a4
   1482e:	89 81       	ldd	r24, Y+1	; 0x01
   14830:	81 50       	subi	r24, 0x01	; 1
   14832:	89 83       	std	Y+1, r24	; 0x01
   14834:	81 e0       	ldi	r24, 0x01	; 1
   14836:	88 83       	st	Y, r24
   14838:	ea 82       	std	Y+2, r14	; 0x02
   1483a:	8f 2d       	mov	r24, r15
   1483c:	99 27       	eor	r25, r25
   1483e:	8f bf       	out	0x3f, r24	; 63
   14840:	df 91       	pop	r29
   14842:	cf 91       	pop	r28
   14844:	1f 91       	pop	r17
   14846:	0f 91       	pop	r16
   14848:	ff 90       	pop	r15
   1484a:	ef 90       	pop	r14
   1484c:	08 95       	ret

0001484e <main>:



int main()
{ 
   1484e:	8f 92       	push	r8
   14850:	9f 92       	push	r9
   14852:	af 92       	push	r10
   14854:	bf 92       	push	r11
   14856:	cf 92       	push	r12
   14858:	df 92       	push	r13
   1485a:	ef 92       	push	r14
   1485c:	ff 92       	push	r15
   1485e:	0f 93       	push	r16
   14860:	1f 93       	push	r17
   14862:	cf 93       	push	r28
   14864:	df 93       	push	r29
   14866:	cd b7       	in	r28, 0x3d	; 61
   14868:	de b7       	in	r29, 0x3e	; 62
   1486a:	a0 97       	sbiw	r28, 0x20	; 32
   1486c:	0f b6       	in	r0, 0x3f	; 63
   1486e:	f8 94       	cli
   14870:	de bf       	out	0x3e, r29	; 62
   14872:	0f be       	out	0x3f, r0	; 63
   14874:	cd bf       	out	0x3d, r28	; 61

 __asm__ __volatile__("sei" ::); 
   14876:	78 94       	sei
   thread** current_thread;

   mutex *mfile;

   current_thread = getCurrentThread();
   14878:	0e 94 9f a3 	call	0x1473e
   1487c:	5c 01       	movw	r10, r24

   currentthreadindex = getCurrentThreadIndex();
   1487e:	0e 94 a9 a3 	call	0x14752
   14882:	4f 93       	push	r20
   14884:	5f 93       	push	r21
   14886:	e0 e2       	ldi	r30, 0x20	; 32
   14888:	fa ee       	ldi	r31, 0xEA	; 234
   1488a:	09 95       	icall
   1488c:	c4 2e       	mov	r12, r20
   1488e:	d5 2e       	mov	r13, r21
   14890:	5f 91       	pop	r21
   14892:	4f 91       	pop	r20
   14894:	4f 93       	push	r20
   14896:	5f 93       	push	r21
   14898:	e4 e2       	ldi	r30, 0x24	; 36
   1489a:	fa ee       	ldi	r31, 0xEA	; 234
   1489c:	09 95       	icall
   1489e:	e4 2e       	mov	r14, r20
   148a0:	f5 2e       	mov	r15, r21
   148a2:	5f 91       	pop	r21
   148a4:	4f 91       	pop	r20

   commonpathnameaddr =  getFilePathAddress();

   commonmodeaddr = getFileModeAddress();

   mfile = getFileMutexAddress();
   148a6:	0e 94 b4 a3 	call	0x14768
   148aa:	8c 01       	movw	r16, r24


   Mutex_lock(mfile);
   148ac:	0e 94 f6 a3 	call	0x147ec

   mystrcpy(commonpathnameaddr, pathname);
   148b0:	6a e5       	ldi	r22, 0x5A	; 90
   148b2:	7a e0       	ldi	r23, 0x0A	; 10
   148b4:	c6 01       	movw	r24, r12
   148b6:	0e 94 c8 a3 	call	0x14790
   mystrcpy(commonmodeaddr, mode);
   148ba:	61 e6       	ldi	r22, 0x61	; 97
   148bc:	7a e0       	ldi	r23, 0x0A	; 10
   148be:	c7 01       	movw	r24, r14
   148c0:	0e 94 c8 a3 	call	0x14790
   148c4:	ec e2       	ldi	r30, 0x2C	; 44
   148c6:	fa ee       	ldi	r31, 0xEA	; 234
   148c8:	09 95       	icall

   openFileSysCall();

   Barrier_block(7, 1);
   148ca:	61 e0       	ldi	r22, 0x01	; 1
   148cc:	87 e0       	ldi	r24, 0x07	; 7
   148ce:	0e 94 d6 a3 	call	0x147ac
   Mutex_unlock(mfile);
   148d2:	c8 01       	movw	r24, r16
   148d4:	0e 94 be a3 	call	0x1477c

   return (MYFILE *)((*current_thread)->filedata.filestate.fileptr);
   148d8:	d5 01       	movw	r26, r10
   148da:	ed 91       	ld	r30, X+
   148dc:	fc 91       	ld	r31, X
   148de:	87 8d       	ldd	r24, Z+31	; 0x1f
   148e0:	90 a1       	ldd	r25, Z+32	; 0x20
 fileptr = mfopen("/file1", "w");
   148e2:	90 93 73 0a 	sts	0x0A73, r25
   148e6:	80 93 72 0a 	sts	0x0A72, r24
 samples = 50; 
   148ea:	82 e3       	ldi	r24, 0x32	; 50
   148ec:	90 e0       	ldi	r25, 0x00	; 0
   148ee:	90 93 75 0a 	sts	0x0A75, r25
   148f2:	80 93 74 0a 	sts	0x0A74, r24
 sleeptime = 100; 
   148f6:	84 e6       	ldi	r24, 0x64	; 100
   148f8:	90 e0       	ldi	r25, 0x00	; 0
   148fa:	90 93 77 0a 	sts	0x0A77, r25
   148fe:	80 93 76 0a 	sts	0x0A76, r24
   14902:	82 e3       	ldi	r24, 0x32	; 50
   14904:	90 e0       	ldi	r25, 0x00	; 0

 while (1)
 {
  if (samples >0)
   samples--; 
   14906:	01 97       	sbiw	r24, 0x01	; 1
   14908:	90 93 75 0a 	sts	0x0A75, r25
   1490c:	80 93 74 0a 	sts	0x0A74, r24
   else
   break; 
    
   sleepThread(sleeptime);
   14910:	00 91 76 0a 	lds	r16, 0x0A76
   14914:	10 91 77 0a 	lds	r17, 0x0A77
   14918:	0e 94 9f a3 	call	0x1473e
   1491c:	dc 01       	movw	r26, r24
   1491e:	ed 91       	ld	r30, X+
   14920:	fc 91       	ld	r31, X
   14922:	11 97       	sbiw	r26, 0x01	; 1
   14924:	84 e0       	ldi	r24, 0x04	; 4
   14926:	82 83       	std	Z+2, r24	; 0x02
   14928:	ed 91       	ld	r30, X+
   1492a:	fc 91       	ld	r31, X
   1492c:	14 8f       	std	Z+28, r17	; 0x1c
   1492e:	03 8f       	std	Z+27, r16	; 0x1b
   14930:	0e 94 d2 a3 	call	0x147a4
void redToggle()
{
                          
  void (*redfp)() = (void (*)(void))RED_LED_TOGGLE_FUNCTION; 
  redfp();    
   14934:	e8 e0       	ldi	r30, 0x08	; 8
   14936:	fa ee       	ldi	r31, 0xEA	; 234
   14938:	09 95       	icall

   redToggle(); 

   {{

    char _tempbuffer[32];
    char *_temp1 = "Hello ";
    char *_temp3 = "World\n";
	  uint8_t lengthstring;
    
    _tempbuffer[0] = '\0';
   1493a:	19 82       	std	Y+1, r1	; 0x01
    String_append(_tempbuffer, _temp1);
   1493c:	63 e6       	ldi	r22, 0x63	; 99
   1493e:	7a e0       	ldi	r23, 0x0A	; 10
   14940:	7e 01       	movw	r14, r28
   14942:	08 94       	sec
   14944:	e1 1c       	adc	r14, r1
   14946:	f1 1c       	adc	r15, r1
   14948:	c7 01       	movw	r24, r14
   1494a:	0e 94 71 a3 	call	0x146e2
    String_append(_tempbuffer, _temp3);
   1494e:	6a e6       	ldi	r22, 0x6A	; 106
   14950:	7a e0       	ldi	r23, 0x0A	; 10
   14952:	c7 01       	movw	r24, r14
   14954:	0e 94 71 a3 	call	0x146e2

    lengthstring = String_length(_tempbuffer); 
   14958:	c7 01       	movw	r24, r14
   1495a:	0e 94 65 a3 	call	0x146ca

    mfwrite(fileptr, _tempbuffer, lengthstring);
   1495e:	88 2e       	mov	r8, r24
   14960:	99 24       	eor	r9, r9
   14962:	a0 90 72 0a 	lds	r10, 0x0A72
   14966:	b0 90 73 0a 	lds	r11, 0x0A73
}



void mfclose(MYFILE *fp)
{
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   currentthreadindex = getCurrentThreadIndex();
   mfile = getFileMutexAddress();

   Mutex_lock(mfile);

   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   closeFileSysCall();

   Barrier_block(7, 2);
   Mutex_unlock(mfile);

   return;

}

void mfread(MYFILE *fp, void *buffer, int nBytes)
{
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   currentthreadindex = getCurrentThreadIndex();
   mfile = getFileMutexAddress();


   Mutex_lock(mfile);
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   (*current_thread)->filedata.filestate.bytes = nBytes;

   readFileSysCall();

   Barrier_block(7, 3);
   Mutex_unlock(mfile);

   return;

}



void mfwrite(MYFILE *fp, void *buffer, int nBytes)
{
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   1496a:	0e 94 9f a3 	call	0x1473e
   1496e:	8c 01       	movw	r16, r24
   currentthreadindex = getCurrentThreadIndex();
   14970:	0e 94 a9 a3 	call	0x14752
   mfile = getFileMutexAddress();
   14974:	0e 94 b4 a3 	call	0x14768
   14978:	6c 01       	movw	r12, r24


   Mutex_lock(mfile);
   1497a:	0e 94 f6 a3 	call	0x147ec
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   1497e:	d8 01       	movw	r26, r16
   14980:	ed 91       	ld	r30, X+
   14982:	fc 91       	ld	r31, X
   14984:	11 97       	sbiw	r26, 0x01	; 1
   14986:	b0 a2       	std	Z+32, r11	; 0x20
   14988:	a7 8e       	std	Z+31, r10	; 0x1f
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   1498a:	ed 91       	ld	r30, X+
   1498c:	fc 91       	ld	r31, X
   1498e:	11 97       	sbiw	r26, 0x01	; 1
   14990:	f2 a2       	std	Z+34, r15	; 0x22
   14992:	e1 a2       	std	Z+33, r14	; 0x21
   (*current_thread)->filedata.filestate.bytes = nBytes;
   14994:	ed 91       	ld	r30, X+
   14996:	fc 91       	ld	r31, X
   14998:	94 a2       	std	Z+36, r9	; 0x24
   1499a:	83 a2       	std	Z+35, r8	; 0x23
   1499c:	e8 e3       	ldi	r30, 0x38	; 56
   1499e:	fa ee       	ldi	r31, 0xEA	; 234
   149a0:	09 95       	icall

   writeFileSysCall();

   Barrier_block(7, 4);
   149a2:	64 e0       	ldi	r22, 0x04	; 4
   149a4:	87 e0       	ldi	r24, 0x07	; 7
   149a6:	0e 94 d6 a3 	call	0x147ac
   Mutex_unlock(mfile);
   149aa:	c6 01       	movw	r24, r12
   149ac:	0e 94 be a3 	call	0x1477c
  	mfseek(fileptr, lengthstring, 1);
   149b0:	e0 90 72 0a 	lds	r14, 0x0A72
   149b4:	f0 90 73 0a 	lds	r15, 0x0A73

   return;
}


void mfwrite_withoutlength(MYFILE *fp, void *buffer)
{


   uint8_t length;

   length = (uint8_t)String_length((char*)buffer);

   mfwrite(fp, buffer, length);

   return;
}






void mfseek(MYFILE *fp, int offset, int position)
{
   uint8_t currentthreadindex;
   thread** current_thread;

   current_thread = getCurrentThread();
   149b8:	0e 94 9f a3 	call	0x1473e
   149bc:	8c 01       	movw	r16, r24
   currentthreadindex = getCurrentThreadIndex();
   149be:	0e 94 a9 a3 	call	0x14752

   (*current_thread)->filedata.fileseekstate.fileptr = (uint8_t*)fp;
   149c2:	d8 01       	movw	r26, r16
   149c4:	ed 91       	ld	r30, X+
   149c6:	fc 91       	ld	r31, X
   149c8:	11 97       	sbiw	r26, 0x01	; 1
   149ca:	f0 a2       	std	Z+32, r15	; 0x20
   149cc:	e7 8e       	std	Z+31, r14	; 0x1f
   (*current_thread)->filedata.fileseekstate.offset = offset;
   149ce:	ed 91       	ld	r30, X+
   149d0:	fc 91       	ld	r31, X
   149d2:	11 97       	sbiw	r26, 0x01	; 1
   149d4:	92 a2       	std	Z+34, r9	; 0x22
   149d6:	81 a2       	std	Z+33, r8	; 0x21
   (*current_thread)->filedata.fileseekstate.position = position;
   149d8:	ed 91       	ld	r30, X+
   149da:	fc 91       	ld	r31, X
   149dc:	81 e0       	ldi	r24, 0x01	; 1
   149de:	90 e0       	ldi	r25, 0x00	; 0
   149e0:	94 a3       	std	Z+36, r25	; 0x24
   149e2:	83 a3       	std	Z+35, r24	; 0x23
   149e4:	ec e3       	ldi	r30, 0x3C	; 60
   149e6:	fa ee       	ldi	r31, 0xEA	; 234
   149e8:	09 95       	icall
   149ea:	80 91 74 0a 	lds	r24, 0x0A74
   149ee:	90 91 75 0a 	lds	r25, 0x0A75
   149f2:	00 97       	sbiw	r24, 0x00	; 0
   149f4:	09 f0       	breq	.+2      	; 0x149f8
   149f6:	87 cf       	rjmp	.-242    	; 0x14906

    }}
   
}


mfclose(fileptr);
   149f8:	c0 90 72 0a 	lds	r12, 0x0A72
   149fc:	d0 90 73 0a 	lds	r13, 0x0A73
   14a00:	0e 94 9f a3 	call	0x1473e
   14a04:	8c 01       	movw	r16, r24
   14a06:	0e 94 a9 a3 	call	0x14752
   14a0a:	0e 94 b4 a3 	call	0x14768
   14a0e:	7c 01       	movw	r14, r24
   14a10:	0e 94 f6 a3 	call	0x147ec
   14a14:	d8 01       	movw	r26, r16
   14a16:	ed 91       	ld	r30, X+
   14a18:	fc 91       	ld	r31, X
   14a1a:	d0 a2       	std	Z+32, r13	; 0x20
   14a1c:	c7 8e       	std	Z+31, r12	; 0x1f
   14a1e:	e0 e3       	ldi	r30, 0x30	; 48
   14a20:	fa ee       	ldi	r31, 0xEA	; 234
   14a22:	09 95       	icall
   14a24:	62 e0       	ldi	r22, 0x02	; 2
   14a26:	87 e0       	ldi	r24, 0x07	; 7
   14a28:	0e 94 d6 a3 	call	0x147ac
   14a2c:	c7 01       	movw	r24, r14
   14a2e:	0e 94 be a3 	call	0x1477c

return 0; 

}
   14a32:	80 e0       	ldi	r24, 0x00	; 0
   14a34:	90 e0       	ldi	r25, 0x00	; 0
   14a36:	a0 96       	adiw	r28, 0x20	; 32
   14a38:	0f b6       	in	r0, 0x3f	; 63
   14a3a:	f8 94       	cli
   14a3c:	de bf       	out	0x3e, r29	; 62
   14a3e:	0f be       	out	0x3f, r0	; 63
   14a40:	cd bf       	out	0x3d, r28	; 61
   14a42:	df 91       	pop	r29
   14a44:	cf 91       	pop	r28
   14a46:	1f 91       	pop	r17
   14a48:	0f 91       	pop	r16
   14a4a:	ff 90       	pop	r15
   14a4c:	ef 90       	pop	r14
   14a4e:	df 90       	pop	r13
   14a50:	cf 90       	pop	r12
   14a52:	bf 90       	pop	r11
   14a54:	af 90       	pop	r10
   14a56:	9f 90       	pop	r9
   14a58:	8f 90       	pop	r8
   14a5a:	08 95       	ret

00014a5c <syscall_postThreadTask.1409>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
   14a5c:	e8 e6       	ldi	r30, 0x68	; 104
   14a5e:	fa ee       	ldi	r31, 0xEA	; 234
   14a60:	09 95       	icall
   14a62:	08 95       	ret

00014a64 <wakeupMe.3128>:
//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
   14a64:	e0 91 78 0a 	lds	r30, 0x0A78
   14a68:	f0 91 79 0a 	lds	r31, 0x0A79
   14a6c:	82 e0       	ldi	r24, 0x02	; 2
   14a6e:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14a70:	0e 94 2e a5 	call	0x14a5c
   14a74:	08 95       	ret

00014a76 <wakeupMeSerial.3415>:
//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE;
   14a76:	e0 91 7a 0a 	lds	r30, 0x0A7A
   14a7a:	f0 91 7b 0a 	lds	r31, 0x0A7B
   14a7e:	82 e0       	ldi	r24, 0x02	; 2
   14a80:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14a82:	0e 94 2e a5 	call	0x14a5c
   14a86:	08 95       	ret
