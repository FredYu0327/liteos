
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004e8  00014600  00014600  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000064  00800a5a  00800a5a  0000055c  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  0000055c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  00000964  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  000009e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  00000a08  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001a82  00000000  00000000  00000a23  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002e3  00000000  00000000  000024a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000569  00000000  00000000  00002788  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000d0  00000000  00000000  00002cf1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000059f  00000000  00000000  00002dc1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000001f1  00000000  00000000  00003360  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00014600 <__vectors>:
   14600:	0c 94 46 a3 	jmp	0x1468c
   14604:	0c 94 63 a3 	jmp	0x146c6
   14608:	0c 94 63 a3 	jmp	0x146c6
   1460c:	0c 94 63 a3 	jmp	0x146c6
   14610:	0c 94 63 a3 	jmp	0x146c6
   14614:	0c 94 63 a3 	jmp	0x146c6
   14618:	0c 94 63 a3 	jmp	0x146c6
   1461c:	0c 94 63 a3 	jmp	0x146c6
   14620:	0c 94 63 a3 	jmp	0x146c6
   14624:	0c 94 63 a3 	jmp	0x146c6
   14628:	0c 94 63 a3 	jmp	0x146c6
   1462c:	0c 94 63 a3 	jmp	0x146c6
   14630:	0c 94 63 a3 	jmp	0x146c6
   14634:	0c 94 63 a3 	jmp	0x146c6
   14638:	0c 94 63 a3 	jmp	0x146c6
   1463c:	0c 94 63 a3 	jmp	0x146c6
   14640:	0c 94 63 a3 	jmp	0x146c6
   14644:	0c 94 63 a3 	jmp	0x146c6
   14648:	0c 94 63 a3 	jmp	0x146c6
   1464c:	0c 94 63 a3 	jmp	0x146c6
   14650:	0c 94 63 a3 	jmp	0x146c6
   14654:	0c 94 63 a3 	jmp	0x146c6
   14658:	0c 94 63 a3 	jmp	0x146c6
   1465c:	0c 94 63 a3 	jmp	0x146c6
   14660:	0c 94 63 a3 	jmp	0x146c6
   14664:	0c 94 63 a3 	jmp	0x146c6
   14668:	0c 94 63 a3 	jmp	0x146c6
   1466c:	0c 94 63 a3 	jmp	0x146c6
   14670:	0c 94 63 a3 	jmp	0x146c6
   14674:	0c 94 63 a3 	jmp	0x146c6
   14678:	0c 94 63 a3 	jmp	0x146c6
   1467c:	0c 94 63 a3 	jmp	0x146c6
   14680:	0c 94 63 a3 	jmp	0x146c6
   14684:	0c 94 63 a3 	jmp	0x146c6
   14688:	0c 94 63 a3 	jmp	0x146c6

0001468c <__ctors_end>:
   1468c:	11 24       	eor	r1, r1
   1468e:	1f be       	out	0x3f, r1	; 63
   14690:	ca e5       	ldi	r28, 0x5A	; 90
   14692:	db e0       	ldi	r29, 0x0B	; 11
   14694:	de bf       	out	0x3e, r29	; 62
   14696:	cd bf       	out	0x3d, r28	; 61

00014698 <__do_copy_data>:
   14698:	1a e0       	ldi	r17, 0x0A	; 10
   1469a:	aa e5       	ldi	r26, 0x5A	; 90
   1469c:	ba e0       	ldi	r27, 0x0A	; 10
   1469e:	e8 ee       	ldi	r30, 0xE8	; 232
   146a0:	fa e4       	ldi	r31, 0x4A	; 74
   146a2:	01 e0       	ldi	r16, 0x01	; 1
   146a4:	0b bf       	out	0x3b, r16	; 59
   146a6:	02 c0       	rjmp	.+4      	; 0x146ac
   146a8:	07 90       	elpm	r0, Z+
   146aa:	0d 92       	st	X+, r0
   146ac:	aa 35       	cpi	r26, 0x5A	; 90
   146ae:	b1 07       	cpc	r27, r17
   146b0:	d9 f7       	brne	.-10     	; 0x146a8

000146b2 <__do_clear_bss>:
   146b2:	1a e0       	ldi	r17, 0x0A	; 10
   146b4:	aa e5       	ldi	r26, 0x5A	; 90
   146b6:	ba e0       	ldi	r27, 0x0A	; 10
   146b8:	01 c0       	rjmp	.+2      	; 0x146bc

000146ba <.do_clear_bss_loop>:
   146ba:	1d 92       	st	X+, r1

000146bc <.do_clear_bss_start>:
   146bc:	ae 3b       	cpi	r26, 0xBE	; 190
   146be:	b1 07       	cpc	r27, r17
   146c0:	e1 f7       	brne	.-8      	; 0x146ba
   146c2:	0c 94 53 a4 	jmp	0x148a6

000146c6 <__bad_interrupt>:
   146c6:	0c 94 00 a3 	jmp	0x14600

000146ca <historycheck.1530>:
}


uint8_t historycheck(uint16_t nodeid, uint16_t randomid)
{
   146ca:	9c 01       	movw	r18, r24
   146cc:	ea e5       	ldi	r30, 0x5A	; 90
   146ce:	fa e0       	ldi	r31, 0x0A	; 10
   uint8_t i; 
   for (i=0; i < HISTORYBUFFERSIZE; i++) {
   	 if (historypackettable[i].valid == 0)
   146d0:	84 81       	ldd	r24, Z+4	; 0x04
   146d2:	88 23       	and	r24, r24
   146d4:	69 f0       	breq	.+26     	; 0x146f0
	 	continue;
	 if ((historypackettable[i].randomsig == randomid ) && (historypackettable[i].nodeid == nodeid))
   146d6:	80 81       	ld	r24, Z
   146d8:	91 81       	ldd	r25, Z+1	; 0x01
   146da:	86 17       	cp	r24, r22
   146dc:	97 07       	cpc	r25, r23
   146de:	41 f4       	brne	.+16     	; 0x146f0
   146e0:	82 81       	ldd	r24, Z+2	; 0x02
   146e2:	93 81       	ldd	r25, Z+3	; 0x03
   146e4:	82 17       	cp	r24, r18
   146e6:	93 07       	cpc	r25, r19
   146e8:	19 f4       	brne	.+6      	; 0x146f0
   146ea:	81 e0       	ldi	r24, 0x01	; 1
   146ec:	90 e0       	ldi	r25, 0x00	; 0
   146ee:	08 95       	ret
   146f0:	35 96       	adiw	r30, 0x05	; 5
   146f2:	8a e0       	ldi	r24, 0x0A	; 10
   146f4:	ec 38       	cpi	r30, 0x8C	; 140
   146f6:	f8 07       	cpc	r31, r24
   146f8:	59 f7       	brne	.-42     	; 0x146d0
   146fa:	80 e0       	ldi	r24, 0x00	; 0
   146fc:	90 e0       	ldi	r25, 0x00	; 0
	 	return 1; 
   	}
   return 0; 
}
   146fe:	08 95       	ret

00014700 <inserthistorytable.1544>:


void inserthistorytable(uint16_t nodeid, uint16_t randomid)
{

   historypackettable[indexOfPackets].valid = 1; 
   14700:	20 91 b9 0a 	lds	r18, 0x0AB9
   14704:	33 27       	eor	r19, r19
   14706:	f9 01       	movw	r30, r18
   14708:	ee 0f       	add	r30, r30
   1470a:	ff 1f       	adc	r31, r31
   1470c:	ee 0f       	add	r30, r30
   1470e:	ff 1f       	adc	r31, r31
   14710:	e2 0f       	add	r30, r18
   14712:	f3 1f       	adc	r31, r19
   14714:	e6 5a       	subi	r30, 0xA6	; 166
   14716:	f5 4f       	sbci	r31, 0xF5	; 245
   14718:	41 e0       	ldi	r20, 0x01	; 1
   1471a:	44 83       	std	Z+4, r20	; 0x04
   historypackettable[indexOfPackets].nodeid = nodeid; 
   1471c:	93 83       	std	Z+3, r25	; 0x03
   1471e:	82 83       	std	Z+2, r24	; 0x02
   historypackettable[indexOfPackets].randomsig = randomid; 
   14720:	71 83       	std	Z+1, r23	; 0x01
   14722:	60 83       	st	Z, r22
   indexOfPackets = (indexOfPackets + 1)%HISTORYBUFFERSIZE;
   14724:	c9 01       	movw	r24, r18
   14726:	01 96       	adiw	r24, 0x01	; 1
   14728:	6a e0       	ldi	r22, 0x0A	; 10
   1472a:	70 e0       	ldi	r23, 0x00	; 0
   1472c:	0e 94 4d a5 	call	0x14a9a
   14730:	80 93 b9 0a 	sts	0x0AB9, r24
   14734:	08 95       	ret

00014736 <getCurrentThread.1394>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   14736:	4f 93       	push	r20
   14738:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   1473a:	ec e0       	ldi	r30, 0x0C	; 12
   1473c:	fa ee       	ldi	r31, 0xEA	; 234
   1473e:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   14740:	84 2f       	mov	r24, r20
   14742:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   14744:	5f 91       	pop	r21
   14746:	4f 91       	pop	r20
   14748:	08 95       	ret

0001474a <rnd.1423>:
{

	 int ret;
   void (*getrandomfp)(void) = (void (*)(void))GET_RANDOM_NUMBER_FUNCTION;
   asm volatile("push r20" "\n\t"
   1474a:	4f 93       	push	r20
   1474c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getrandomfp();
   1474e:	ec eb       	ldi	r30, 0xBC	; 188
   14750:	fa ee       	ldi	r31, 0xEA	; 234
   14752:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   14754:	84 2f       	mov	r24, r20
   14756:	95 2f       	mov	r25, r21
	              "mov %B0, r21" "\n\t"
				 :"=r" (ret)
				 :
                );
   asm volatile("pop r21" "\n\t"
   14758:	5f 91       	pop	r21
   1475a:	4f 91       	pop	r20
   1475c:	08 95       	ret

0001475e <syscall_postThreadTask.1400>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
   1475e:	e8 e6       	ldi	r30, 0x68	; 104
   14760:	fa ee       	ldi	r31, 0xEA	; 234
   14762:	09 95       	icall
   14764:	08 95       	ret

00014766 <wakeupMeOnDataMsg.1554>:
   return;  
}



//-------------------------------------------------------------------------
static uint8_t incomingMsg[ 32 ];
static uint8_t incomingDataLength;
static uint8_t incomingPacketInfo[ 4 ];


//Handles incoming data msg. This usually wakesup the current thread 
void wakeupMeOnDataMsg() {

   thisthread->state = STATE_ACTIVE;
   14766:	e0 91 b7 0a 	lds	r30, 0x0AB7
   1476a:	f0 91 b8 0a 	lds	r31, 0x0AB8
   1476e:	82 e0       	ldi	r24, 0x02	; 2
   14770:	82 83       	std	Z+2, r24	; 0x02
   syscall_postThreadTask();    
   14772:	0e 94 af a3 	call	0x1475e
   14776:	08 95       	ret

00014778 <yield.1393>:
   14778:	e0 e0       	ldi	r30, 0x00	; 0
   1477a:	fa ee       	ldi	r31, 0xEA	; 234
   1477c:	09 95       	icall
   1477e:	08 95       	ret

00014780 <sleepThread.1392>:
   14780:	0f 93       	push	r16
   14782:	1f 93       	push	r17
   14784:	8c 01       	movw	r16, r24
   14786:	0e 94 9b a3 	call	0x14736
   1478a:	dc 01       	movw	r26, r24
   1478c:	ed 91       	ld	r30, X+
   1478e:	fc 91       	ld	r31, X
   14790:	11 97       	sbiw	r26, 0x01	; 1
   14792:	84 e0       	ldi	r24, 0x04	; 4
   14794:	82 83       	std	Z+2, r24	; 0x02
   14796:	ed 91       	ld	r30, X+
   14798:	fc 91       	ld	r31, X
   1479a:	14 8f       	std	Z+28, r17	; 0x1c
   1479c:	03 8f       	std	Z+27, r16	; 0x1b
   1479e:	0e 94 bc a3 	call	0x14778
   147a2:	1f 91       	pop	r17
   147a4:	0f 91       	pop	r16
   147a6:	08 95       	ret

000147a8 <radioSend.1458>:
}


void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
   147a8:	4f 92       	push	r4
   147aa:	5f 92       	push	r5
   147ac:	6f 92       	push	r6
   147ae:	7f 92       	push	r7
   147b0:	8f 92       	push	r8
   147b2:	9f 92       	push	r9
   147b4:	af 92       	push	r10
   147b6:	bf 92       	push	r11
   147b8:	cf 92       	push	r12
   147ba:	df 92       	push	r13
   147bc:	ef 92       	push	r14
   147be:	ff 92       	push	r15
   147c0:	0f 93       	push	r16
   147c2:	1f 93       	push	r17
   147c4:	cf 93       	push	r28
   147c6:	df 93       	push	r29
   147c8:	5c 01       	movw	r10, r24
   147ca:	4b 01       	movw	r8, r22
   147cc:	44 2e       	mov	r4, r20
   147ce:	39 01       	movw	r6, r18
mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GET_RADIO_MUTEX_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   147d0:	4f 93       	push	r20
   147d2:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   147d4:	e0 e1       	ldi	r30, 0x10	; 16
   147d6:	fa ee       	ldi	r31, 0xEA	; 234
   147d8:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   147da:	c4 2f       	mov	r28, r20
   147dc:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   147de:	5f 91       	pop	r21
   147e0:	4f 91       	pop	r20


   mutex* msend;
   thread** current_thread;
   radioinfotype *radioinfoaddr;



   msend = getRadioMutexAddress();
   current_thread = getCurrentThread();
   147e2:	0e 94 9b a3 	call	0x14736
   147e6:	4f 93       	push	r20
   147e8:	5f 93       	push	r21
   147ea:	ec e5       	ldi	r30, 0x5C	; 92
   147ec:	fa ee       	ldi	r31, 0xEA	; 234
   147ee:	09 95       	icall
   147f0:	04 2f       	mov	r16, r20
   147f2:	15 2f       	mov	r17, r21
   147f4:	5f 91       	pop	r21
   147f6:	4f 91       	pop	r20
   147f8:	0e 94 9b a3 	call	0x14736
   147fc:	7c 01       	movw	r14, r24
   147fe:	4f 93       	push	r20
   14800:	5f 93       	push	r21
   14802:	ec e1       	ldi	r30, 0x1C	; 28
   14804:	fa ee       	ldi	r31, 0xEA	; 234
   14806:	09 95       	icall
   14808:	c4 2e       	mov	r12, r20
   1480a:	d5 2e       	mov	r13, r21
   1480c:	5f 91       	pop	r21
   1480e:	4f 91       	pop	r20
   14810:	5f b6       	in	r5, 0x3f	; 63
   14812:	f8 94       	cli
   14814:	88 81       	ld	r24, Y
   14816:	88 23       	and	r24, r24
   14818:	91 f0       	breq	.+36     	; 0x1483e
   1481a:	d7 01       	movw	r26, r14
   1481c:	ed 91       	ld	r30, X+
   1481e:	fc 91       	ld	r31, X
   14820:	11 97       	sbiw	r26, 0x01	; 1
   14822:	83 e0       	ldi	r24, 0x03	; 3
   14824:	82 83       	std	Z+2, r24	; 0x02
   14826:	ed 91       	ld	r30, X+
   14828:	fc 91       	ld	r31, X
   1482a:	d4 8f       	std	Z+28, r29	; 0x1c
   1482c:	c3 8f       	std	Z+27, r28	; 0x1b
   1482e:	89 81       	ldd	r24, Y+1	; 0x01
   14830:	8f 5f       	subi	r24, 0xFF	; 255
   14832:	89 83       	std	Y+1, r24	; 0x01
   14834:	0e 94 bc a3 	call	0x14778
   14838:	89 81       	ldd	r24, Y+1	; 0x01
   1483a:	81 50       	subi	r24, 0x01	; 1
   1483c:	89 83       	std	Y+1, r24	; 0x01
   1483e:	81 e0       	ldi	r24, 0x01	; 1
   14840:	88 83       	st	Y, r24
   14842:	8c 2d       	mov	r24, r12
   14844:	99 27       	eor	r25, r25
   14846:	8a 83       	std	Y+2, r24	; 0x02
   14848:	85 2d       	mov	r24, r5
   1484a:	99 27       	eor	r25, r25
   1484c:	8f bf       	out	0x3f, r24	; 63
   radioinfoaddr = getCurrentRadioInfoAddr();

   Mutex_lock(msend);

   radioinfoaddr-> socket_port = port;
   1484e:	f8 01       	movw	r30, r16
   14850:	b1 82       	std	Z+1, r11	; 0x01
   14852:	a0 82       	st	Z, r10
   radioinfoaddr->socket_addr = address;
   14854:	93 82       	std	Z+3, r9	; 0x03
   14856:	82 82       	std	Z+2, r8	; 0x02
   radioinfoaddr->socket_msg_len  = length;
   14858:	44 82       	std	Z+4, r4	; 0x04
   radioinfoaddr->socket_msg  = msg;
   1485a:	76 82       	std	Z+6, r7	; 0x06
   1485c:	65 82       	std	Z+5, r6	; 0x05
   1485e:	e4 e1       	ldi	r30, 0x14	; 20
   14860:	fa ee       	ldi	r31, 0xEA	; 234
   14862:	09 95       	icall

   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg();

   sleepThread(30);
   14864:	8e e1       	ldi	r24, 0x1E	; 30
   14866:	90 e0       	ldi	r25, 0x00	; 0
   14868:	0e 94 c0 a3 	call	0x14780
   1486c:	e8 eb       	ldi	r30, 0xB8	; 184
   1486e:	fa ee       	ldi	r31, 0xEA	; 234
   14870:	09 95       	icall
   14872:	4f 93       	push	r20
   14874:	5f 93       	push	r21
   14876:	4c 2f       	mov	r20, r28
   14878:	5d 2f       	mov	r21, r29
   1487a:	e8 e1       	ldi	r30, 0x18	; 24
   1487c:	fa ee       	ldi	r31, 0xEA	; 234
   1487e:	09 95       	icall
   14880:	5f 91       	pop	r21
   14882:	4f 91       	pop	r20
   14884:	df 91       	pop	r29
   14886:	cf 91       	pop	r28
   14888:	1f 91       	pop	r17
   1488a:	0f 91       	pop	r16
   1488c:	ff 90       	pop	r15
   1488e:	ef 90       	pop	r14
   14890:	df 90       	pop	r13
   14892:	cf 90       	pop	r12
   14894:	bf 90       	pop	r11
   14896:	af 90       	pop	r10
   14898:	9f 90       	pop	r9
   1489a:	8f 90       	pop	r8
   1489c:	7f 90       	pop	r7
   1489e:	6f 90       	pop	r6
   148a0:	5f 90       	pop	r5
   148a2:	4f 90       	pop	r4
   148a4:	08 95       	ret

000148a6 <main>:
}


//Registers the data packet for receving incoming packets. This enables receving both remote and local data packets

void registerDataPacket() {

   _atomic_t currentatomic;
   radiohandletype *radiohandleaddr;
   
   void (*getaddrfp)(void) = (void (*)(void))REGISTER_RADIO_RECEIVE_EVENT; 

   //Finds the radio handle, so that when this code is ported to be externally used, it will be obtained via a system call 
   radiohandleaddr =  getCurrentRadioHandleAddr();

   incomingDataLength = 0;
   
   //set up the radiohandleaddr data structures
   radiohandleaddr->port = 20;
   radiohandleaddr->maxLength = 32;
   radiohandleaddr->dataReady = &incomingDataLength;
   radiohandleaddr->data = incomingMsg;
   radiohandleaddr->packetinfo = incomingPacketInfo;
   radiohandleaddr->handlefunc = wakeupMeOnDataMsg;

   //close the interrupt     
   currentatomic = _atomic_start();
   
   //call the radio handle set to store the data structure into the handle vectors 
   getaddrfp();     
   //syscall_registerEvent();
   
   //open the interrupt 
   _atomic_end( currentatomic );
   return ;
}




//This is the entry point. It broadcasts neighbor exchanges perodically, or handles incoming packets (non-update neighbor)

int main() {
   148a6:	df 92       	push	r13
   148a8:	ef 92       	push	r14
   148aa:	ff 92       	push	r15
   148ac:	0f 93       	push	r16
   148ae:	1f 93       	push	r17
   148b0:	cf 93       	push	r28
   148b2:	df 93       	push	r29
   148b4:	ee e5       	ldi	r30, 0x5E	; 94
   148b6:	fa e0       	ldi	r31, 0x0A	; 10
   148b8:	10 82       	st	Z, r1
   148ba:	35 96       	adiw	r30, 0x05	; 5
   148bc:	8a e0       	ldi	r24, 0x0A	; 10
   148be:	e0 39       	cpi	r30, 0x90	; 144
   148c0:	f8 07       	cpc	r31, r24
   148c2:	d1 f7       	brne	.-12     	; 0x148b8
   148c4:	10 92 b9 0a 	sts	0x0AB9, r1
	             "pop r20" "\n\t"
	              ::);
   return ret;

}



uint16_t getnodeID()
	{

	   int ret;
	   void (*fp)(void) = (void (*)(void))GET_NODE_ID_FUNCTION;
	   asm volatile("push r20" "\n\t"
   148c8:	4f 93       	push	r20
   148ca:	5f 93       	push	r21
					"push r21" "\n\t"
					::);
	   fp();
   148cc:	ec ec       	ldi	r30, 0xCC	; 204
   148ce:	fa ee       	ldi	r31, 0xEA	; 234
   148d0:	09 95       	icall
	   asm volatile(" mov %A0, r20" "\n\t"
   148d2:	e4 2e       	mov	r14, r20
   148d4:	f5 2e       	mov	r15, r21
					  "mov %B0, r21" "\n\t"
					 :"=r" (ret)
					 :
					);
	   asm volatile("pop r21" "\n\t"
   148d6:	5f 91       	pop	r21
   148d8:	4f 91       	pop	r20

   uint8_t portnum;
   uint16_t nodeid; 

   uint16_t randomsig;
   uint16_t incomingnodeid; 

   uint8_t temp;
   uint8_t jitter; 
   uint16_t comingnodeid; 
  

   initTable();
   nodeid = getnodeID();
   
   //register both the negibhorhood update and the message incoming 

   thiscurrentthread = getCurrentThread(); 
   148da:	0e 94 9b a3 	call	0x14736
   148de:	fc 01       	movw	r30, r24
   148e0:	90 93 b6 0a 	sts	0x0AB6, r25
   148e4:	80 93 b5 0a 	sts	0x0AB5, r24
   thisthread = *thiscurrentthread; 
   148e8:	80 81       	ld	r24, Z
   148ea:	91 81       	ldd	r25, Z+1	; 0x01
   148ec:	90 93 b8 0a 	sts	0x0AB8, r25
   148f0:	80 93 b7 0a 	sts	0x0AB7, r24
   148f4:	4f 93       	push	r20
   148f6:	5f 93       	push	r21
   148f8:	e0 e6       	ldi	r30, 0x60	; 96
   148fa:	fa ee       	ldi	r31, 0xEA	; 234
   148fc:	09 95       	icall
   148fe:	e4 2f       	mov	r30, r20
   14900:	f5 2f       	mov	r31, r21
   14902:	5f 91       	pop	r21
   14904:	4f 91       	pop	r20
   14906:	10 92 ac 0a 	sts	0x0AAC, r1
   1490a:	84 e1       	ldi	r24, 0x14	; 20
   1490c:	90 e0       	ldi	r25, 0x00	; 0
   1490e:	91 83       	std	Z+1, r25	; 0x01
   14910:	80 83       	st	Z, r24
   14912:	80 e2       	ldi	r24, 0x20	; 32
   14914:	82 83       	std	Z+2, r24	; 0x02
   14916:	8c ea       	ldi	r24, 0xAC	; 172
   14918:	9a e0       	ldi	r25, 0x0A	; 10
   1491a:	94 83       	std	Z+4, r25	; 0x04
   1491c:	83 83       	std	Z+3, r24	; 0x03
   1491e:	8c e8       	ldi	r24, 0x8C	; 140
   14920:	9a e0       	ldi	r25, 0x0A	; 10
   14922:	96 83       	std	Z+6, r25	; 0x06
   14924:	85 83       	std	Z+5, r24	; 0x05
   14926:	8d ea       	ldi	r24, 0xAD	; 173
   14928:	9a e0       	ldi	r25, 0x0A	; 10
   1492a:	90 87       	std	Z+8, r25	; 0x08
   1492c:	87 83       	std	Z+7, r24	; 0x07
   1492e:	83 eb       	ldi	r24, 0xB3	; 179
   14930:	93 ea       	ldi	r25, 0xA3	; 163
   14932:	93 87       	std	Z+11, r25	; 0x0b
   14934:	82 87       	std	Z+10, r24	; 0x0a
   14936:	0f b7       	in	r16, 0x3f	; 63
   14938:	f8 94       	cli
   1493a:	11 27       	eor	r17, r17
   1493c:	e4 e6       	ldi	r30, 0x64	; 100
   1493e:	fa ee       	ldi	r31, 0xEA	; 234
   14940:	09 95       	icall
   14942:	0f bf       	out	0x3f, r16	; 63
      
   registerDataPacket();

   packetsreceived = packetsdelivered = 0; 
   14944:	10 92 b4 0a 	sts	0x0AB4, r1
   14948:	10 92 b3 0a 	sts	0x0AB3, r1
   1494c:	10 92 b2 0a 	sts	0x0AB2, r1
   14950:	10 92 b1 0a 	sts	0x0AB1, r1
   14954:	0e 94 9b a3 	call	0x14736
   14958:	fc 01       	movw	r30, r24
   1495a:	01 90       	ld	r0, Z+
   1495c:	f0 81       	ld	r31, Z
   1495e:	e0 2d       	mov	r30, r0
   14960:	85 e0       	ldi	r24, 0x05	; 5
   14962:	82 83       	std	Z+2, r24	; 0x02
   14964:	0e 94 bc a3 	call	0x14778


   while ( 1 ) {

         hibernateThread();
		 incomingnodeid = 0; 
         //handles the data message by restructing it and broadcast it  
         //If the packet is new, send it both locally and remotely

		 temp  = incomingMsg[ 0 ];
		 
		 incomingnodeid += ((uint16_t)temp); 
		 temp = incomingMsg[ 1 ];
		 incomingnodeid += ((uint16_t)temp) * 256;
   14968:	20 91 8c 0a 	lds	r18, 0x0A8C
   1496c:	80 91 8d 0a 	lds	r24, 0x0A8D
   14970:	99 27       	eor	r25, r25
   14972:	18 2f       	mov	r17, r24
   14974:	00 27       	eor	r16, r16
   14976:	02 0f       	add	r16, r18
   14978:	11 1d       	adc	r17, r1

         randomsig = 0; 
		 temp = incomingMsg[ 2 ];
		 randomsig += ((uint16_t)temp);

   	     temp = incomingMsg[ 3 ];
		 randomsig += ((uint16_t)temp) * 256;
   1497a:	20 91 8e 0a 	lds	r18, 0x0A8E
   1497e:	80 91 8f 0a 	lds	r24, 0x0A8F
   14982:	99 27       	eor	r25, r25
   14984:	d8 2f       	mov	r29, r24
   14986:	cc 27       	eor	r28, r28
   14988:	c2 0f       	add	r28, r18
   1498a:	d1 1d       	adc	r29, r1

		 portnum = incomingMsg[4]; 
   1498c:	d0 90 90 0a 	lds	r13, 0x0A90

		 if ((nodeid == incomingnodeid)&&(historycheck(incomingnodeid, randomsig) == 0))
   14990:	e0 16       	cp	r14, r16
   14992:	f1 06       	cpc	r15, r17
   14994:	69 f5       	brne	.+90     	; 0x149f0
   14996:	be 01       	movw	r22, r28
   14998:	c7 01       	movw	r24, r14
   1499a:	0e 94 65 a3 	call	0x146ca
   1499e:	88 23       	and	r24, r24
   149a0:	39 f5       	brne	.+78     	; 0x149f0
		 	{
    		 	inserthistorytable(incomingnodeid, randomsig); 
   149a2:	be 01       	movw	r22, r28
   149a4:	c7 01       	movw	r24, r14
   149a6:	0e 94 80 a3 	call	0x14700
				incomingMsg[5] = nodeid%256; 
   149aa:	e0 92 91 0a 	sts	0x0A91, r14
				incomingMsg[6] = nodeid/256; 
   149ae:	8f 2d       	mov	r24, r15
   149b0:	99 27       	eor	r25, r25
   149b2:	80 93 92 0a 	sts	0x0A92, r24
				
				jitter = rnd()%20;
   149b6:	0e 94 a5 a3 	call	0x1474a
				sleepThread(jitter); 
   149ba:	64 e1       	ldi	r22, 0x14	; 20
   149bc:	70 e0       	ldi	r23, 0x00	; 0
   149be:	0e 94 4d a5 	call	0x14a9a
   149c2:	99 27       	eor	r25, r25
   149c4:	0e 94 c0 a3 	call	0x14780
				radioSend(20, 0xffff, incomingDataLength, incomingMsg);
   149c8:	2c e8       	ldi	r18, 0x8C	; 140
   149ca:	3a e0       	ldi	r19, 0x0A	; 10
   149cc:	40 91 ac 0a 	lds	r20, 0x0AAC
   149d0:	6f ef       	ldi	r22, 0xFF	; 255
   149d2:	7f ef       	ldi	r23, 0xFF	; 255
   149d4:	84 e1       	ldi	r24, 0x14	; 20
   149d6:	90 e0       	ldi	r25, 0x00	; 0
   149d8:	0e 94 d4 a3 	call	0x147a8
				packetsreceived ++; 
   149dc:	80 91 b1 0a 	lds	r24, 0x0AB1
   149e0:	90 91 b2 0a 	lds	r25, 0x0AB2
   149e4:	01 96       	adiw	r24, 0x01	; 1
   149e6:	90 93 b2 0a 	sts	0x0AB2, r25
   149ea:	80 93 b1 0a 	sts	0x0AB1, r24
   149ee:	b2 cf       	rjmp	.-156    	; 0x14954
		    }
		 

		 else if (historycheck(incomingnodeid, randomsig) == 0)
   149f0:	be 01       	movw	r22, r28
   149f2:	c8 01       	movw	r24, r16
   149f4:	0e 94 65 a3 	call	0x146ca
   149f8:	88 23       	and	r24, r24
   149fa:	09 f0       	breq	.+2      	; 0x149fe
   149fc:	ab cf       	rjmp	.-170    	; 0x14954
		 	{
             
				comingnodeid = incomingMsg[5];
   149fe:	80 91 91 0a 	lds	r24, 0x0A91
   14a02:	28 2f       	mov	r18, r24
   14a04:	33 27       	eor	r19, r19
				if ((comingnodeid != nodeid -1 )&&( comingnodeid!=nodeid+1))
   14a06:	c7 01       	movw	r24, r14
   14a08:	01 97       	sbiw	r24, 0x01	; 1
   14a0a:	28 17       	cp	r18, r24
   14a0c:	39 07       	cpc	r19, r25
   14a0e:	31 f0       	breq	.+12     	; 0x14a1c
   14a10:	c7 01       	movw	r24, r14
   14a12:	01 96       	adiw	r24, 0x01	; 1
   14a14:	28 17       	cp	r18, r24
   14a16:	39 07       	cpc	r19, r25
   14a18:	09 f0       	breq	.+2      	; 0x14a1c
   14a1a:	9c cf       	rjmp	.-200    	; 0x14954
					{
					}
				else
					{
                radioSend(portnum, 0, incomingDataLength, incomingMsg); 
   14a1c:	2c e8       	ldi	r18, 0x8C	; 140
   14a1e:	3a e0       	ldi	r19, 0x0A	; 10
   14a20:	40 91 ac 0a 	lds	r20, 0x0AAC
   14a24:	60 e0       	ldi	r22, 0x00	; 0
   14a26:	70 e0       	ldi	r23, 0x00	; 0
   14a28:	8d 2d       	mov	r24, r13
   14a2a:	99 27       	eor	r25, r25
   14a2c:	0e 94 d4 a3 	call	0x147a8
				
				inserthistorytable(incomingnodeid, randomsig); 
   14a30:	be 01       	movw	r22, r28
   14a32:	c8 01       	movw	r24, r16
   14a34:	0e 94 80 a3 	call	0x14700

				incomingMsg[5] = nodeid%256;
   14a38:	e0 92 91 0a 	sts	0x0A91, r14
				
				jitter = rnd()%20;
   14a3c:	0e 94 a5 a3 	call	0x1474a
				sleepThread(jitter); 
   14a40:	64 e1       	ldi	r22, 0x14	; 20
   14a42:	70 e0       	ldi	r23, 0x00	; 0
   14a44:	0e 94 4d a5 	call	0x14a9a
   14a48:	99 27       	eor	r25, r25
   14a4a:	0e 94 c0 a3 	call	0x14780
				radioSend(20, 0xffff, incomingDataLength, incomingMsg);
   14a4e:	2c e8       	ldi	r18, 0x8C	; 140
   14a50:	3a e0       	ldi	r19, 0x0A	; 10
   14a52:	40 91 ac 0a 	lds	r20, 0x0AAC
   14a56:	6f ef       	ldi	r22, 0xFF	; 255
   14a58:	7f ef       	ldi	r23, 0xFF	; 255
   14a5a:	84 e1       	ldi	r24, 0x14	; 20
   14a5c:	90 e0       	ldi	r25, 0x00	; 0
   14a5e:	0e 94 d4 a3 	call	0x147a8
				packetsdelivered++; 
   14a62:	80 91 b3 0a 	lds	r24, 0x0AB3
   14a66:	90 91 b4 0a 	lds	r25, 0x0AB4
   14a6a:	01 96       	adiw	r24, 0x01	; 1
   14a6c:	90 93 b4 0a 	sts	0x0AB4, r25
   14a70:	80 93 b3 0a 	sts	0x0AB3, r24
   14a74:	6f cf       	rjmp	.-290    	; 0x14954

00014a76 <wakeupMe.3227>:

   disableRadioState();


   Mutex_unlock(msend);

   return;
}



//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
   14a76:	e0 91 ba 0a 	lds	r30, 0x0ABA
   14a7a:	f0 91 bb 0a 	lds	r31, 0x0ABB
   14a7e:	82 e0       	ldi	r24, 0x02	; 2
   14a80:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14a82:	0e 94 af a3 	call	0x1475e
   14a86:	08 95       	ret

00014a88 <wakeupMeSerial.3514>:
//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE;
   14a88:	e0 91 bc 0a 	lds	r30, 0x0ABC
   14a8c:	f0 91 bd 0a 	lds	r31, 0x0ABD
   14a90:	82 e0       	ldi	r24, 0x02	; 2
   14a92:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14a94:	0e 94 af a3 	call	0x1475e
   14a98:	08 95       	ret

00014a9a <__divmodhi4>:
   14a9a:	97 fb       	bst	r25, 7
   14a9c:	09 2e       	mov	r0, r25
   14a9e:	07 26       	eor	r0, r23
   14aa0:	0a d0       	rcall	.+20     	; 0x14ab6
   14aa2:	77 fd       	sbrc	r23, 7
   14aa4:	04 d0       	rcall	.+8      	; 0x14aae
   14aa6:	0c d0       	rcall	.+24     	; 0x14ac0
   14aa8:	06 d0       	rcall	.+12     	; 0x14ab6
   14aaa:	00 20       	and	r0, r0
   14aac:	1a f4       	brpl	.+6      	; 0x14ab4

00014aae <__divmodhi4_neg2>:
   14aae:	70 95       	com	r23
   14ab0:	61 95       	neg	r22
   14ab2:	7f 4f       	sbci	r23, 0xFF	; 255

00014ab4 <__divmodhi4_exit>:
   14ab4:	08 95       	ret

00014ab6 <__divmodhi4_neg1>:
   14ab6:	f6 f7       	brtc	.-4      	; 0x14ab4
   14ab8:	90 95       	com	r25
   14aba:	81 95       	neg	r24
   14abc:	9f 4f       	sbci	r25, 0xFF	; 255
   14abe:	08 95       	ret

00014ac0 <__udivmodhi4>:
   14ac0:	aa 1b       	sub	r26, r26
   14ac2:	bb 1b       	sub	r27, r27
   14ac4:	51 e1       	ldi	r21, 0x11	; 17
   14ac6:	07 c0       	rjmp	.+14     	; 0x14ad6

00014ac8 <__udivmodhi4_loop>:
   14ac8:	aa 1f       	adc	r26, r26
   14aca:	bb 1f       	adc	r27, r27
   14acc:	a6 17       	cp	r26, r22
   14ace:	b7 07       	cpc	r27, r23
   14ad0:	10 f0       	brcs	.+4      	; 0x14ad6
   14ad2:	a6 1b       	sub	r26, r22
   14ad4:	b7 0b       	sbc	r27, r23

00014ad6 <__udivmodhi4_ep>:
   14ad6:	88 1f       	adc	r24, r24
   14ad8:	99 1f       	adc	r25, r25
   14ada:	5a 95       	dec	r21
   14adc:	a9 f7       	brne	.-22     	; 0x14ac8
   14ade:	80 95       	com	r24
   14ae0:	90 95       	com	r25
   14ae2:	bc 01       	movw	r22, r24
   14ae4:	cd 01       	movw	r24, r26
   14ae6:	08 95       	ret
