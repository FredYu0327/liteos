
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002d8  00014a00  00014a00  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000040  00800a8c  00800a8c  0000034c  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  0000034c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  00000754  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  000007d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  000007f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001700  00000000  00000000  00000813  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000293  00000000  00000000  00001f13  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000003d0  00000000  00000000  000021a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000080  00000000  00000000  00002576  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000042e  00000000  00000000  000025f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000098  00000000  00000000  00002a24  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  00002abc  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00014a00 <__vectors>:
   14a00:	0c 94 46 a5 	jmp	0x14a8c
   14a04:	0c 94 63 a5 	jmp	0x14ac6
   14a08:	0c 94 63 a5 	jmp	0x14ac6
   14a0c:	0c 94 63 a5 	jmp	0x14ac6
   14a10:	0c 94 63 a5 	jmp	0x14ac6
   14a14:	0c 94 63 a5 	jmp	0x14ac6
   14a18:	0c 94 63 a5 	jmp	0x14ac6
   14a1c:	0c 94 63 a5 	jmp	0x14ac6
   14a20:	0c 94 63 a5 	jmp	0x14ac6
   14a24:	0c 94 63 a5 	jmp	0x14ac6
   14a28:	0c 94 63 a5 	jmp	0x14ac6
   14a2c:	0c 94 63 a5 	jmp	0x14ac6
   14a30:	0c 94 63 a5 	jmp	0x14ac6
   14a34:	0c 94 63 a5 	jmp	0x14ac6
   14a38:	0c 94 63 a5 	jmp	0x14ac6
   14a3c:	0c 94 63 a5 	jmp	0x14ac6
   14a40:	0c 94 63 a5 	jmp	0x14ac6
   14a44:	0c 94 63 a5 	jmp	0x14ac6
   14a48:	0c 94 63 a5 	jmp	0x14ac6
   14a4c:	0c 94 63 a5 	jmp	0x14ac6
   14a50:	0c 94 63 a5 	jmp	0x14ac6
   14a54:	0c 94 63 a5 	jmp	0x14ac6
   14a58:	0c 94 63 a5 	jmp	0x14ac6
   14a5c:	0c 94 63 a5 	jmp	0x14ac6
   14a60:	0c 94 63 a5 	jmp	0x14ac6
   14a64:	0c 94 63 a5 	jmp	0x14ac6
   14a68:	0c 94 63 a5 	jmp	0x14ac6
   14a6c:	0c 94 63 a5 	jmp	0x14ac6
   14a70:	0c 94 63 a5 	jmp	0x14ac6
   14a74:	0c 94 63 a5 	jmp	0x14ac6
   14a78:	0c 94 63 a5 	jmp	0x14ac6
   14a7c:	0c 94 63 a5 	jmp	0x14ac6
   14a80:	0c 94 63 a5 	jmp	0x14ac6
   14a84:	0c 94 63 a5 	jmp	0x14ac6
   14a88:	0c 94 63 a5 	jmp	0x14ac6

00014a8c <__ctors_end>:
   14a8c:	11 24       	eor	r1, r1
   14a8e:	1f be       	out	0x3f, r1	; 63
   14a90:	c8 eb       	ldi	r28, 0xB8	; 184
   14a92:	db e0       	ldi	r29, 0x0B	; 11
   14a94:	de bf       	out	0x3e, r29	; 62
   14a96:	cd bf       	out	0x3d, r28	; 61

00014a98 <__do_copy_data>:
   14a98:	1a e0       	ldi	r17, 0x0A	; 10
   14a9a:	ac e8       	ldi	r26, 0x8C	; 140
   14a9c:	ba e0       	ldi	r27, 0x0A	; 10
   14a9e:	e8 ed       	ldi	r30, 0xD8	; 216
   14aa0:	fc e4       	ldi	r31, 0x4C	; 76
   14aa2:	01 e0       	ldi	r16, 0x01	; 1
   14aa4:	0b bf       	out	0x3b, r16	; 59
   14aa6:	02 c0       	rjmp	.+4      	; 0x14aac
   14aa8:	07 90       	elpm	r0, Z+
   14aaa:	0d 92       	st	X+, r0
   14aac:	ac 38       	cpi	r26, 0x8C	; 140
   14aae:	b1 07       	cpc	r27, r17
   14ab0:	d9 f7       	brne	.-10     	; 0x14aa8

00014ab2 <__do_clear_bss>:
   14ab2:	1a e0       	ldi	r17, 0x0A	; 10
   14ab4:	ac e8       	ldi	r26, 0x8C	; 140
   14ab6:	ba e0       	ldi	r27, 0x0A	; 10
   14ab8:	01 c0       	rjmp	.+2      	; 0x14abc

00014aba <.do_clear_bss_loop>:
   14aba:	1d 92       	st	X+, r1

00014abc <.do_clear_bss_start>:
   14abc:	ac 3c       	cpi	r26, 0xCC	; 204
   14abe:	b1 07       	cpc	r27, r17
   14ac0:	e1 f7       	brne	.-8      	; 0x14aba
   14ac2:	0c 94 87 a5 	jmp	0x14b0e

00014ac6 <__bad_interrupt>:
   14ac6:	0c 94 00 a5 	jmp	0x14a00

00014aca <getCurrentThread.1387>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 
   asm volatile("push r20" "\n\t"
   14aca:	4f 93       	push	r20
   14acc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   14ace:	ec e0       	ldi	r30, 0x0C	; 12
   14ad0:	fa ee       	ldi	r31, 0xEA	; 234
   14ad2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   14ad4:	84 2f       	mov	r24, r20
   14ad6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   14ad8:	5f 91       	pop	r21
   14ada:	4f 91       	pop	r20
   14adc:	08 95       	ret

00014ade <yield.1386>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}



uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADINDEXFUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))CURRENTTHREADFUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELDFUNCTION; 
 yieldfp();                              
   14ade:	e0 e0       	ldi	r30, 0x00	; 0
   14ae0:	fa ee       	ldi	r31, 0xEA	; 234
   14ae2:	09 95       	icall
   14ae4:	08 95       	ret

00014ae6 <sleepThread.1385>:
   14ae6:	0f 93       	push	r16
   14ae8:	1f 93       	push	r17
   14aea:	8c 01       	movw	r16, r24
   14aec:	0e 94 65 a5 	call	0x14aca
   14af0:	dc 01       	movw	r26, r24
   14af2:	ed 91       	ld	r30, X+
   14af4:	fc 91       	ld	r31, X
   14af6:	11 97       	sbiw	r26, 0x01	; 1
   14af8:	84 e0       	ldi	r24, 0x04	; 4
   14afa:	82 83       	std	Z+2, r24	; 0x02
   14afc:	ed 91       	ld	r30, X+
   14afe:	fc 91       	ld	r31, X
   14b00:	14 8f       	std	Z+28, r17	; 0x1c
   14b02:	03 8f       	std	Z+27, r16	; 0x1b
   14b04:	0e 94 6f a5 	call	0x14ade
   14b08:	1f 91       	pop	r17
   14b0a:	0f 91       	pop	r16
   14b0c:	08 95       	ret

00014b0e <main>:
int reading; 
int array[10];

int main()
{
   14b0e:	bf 92       	push	r11
   14b10:	cf 92       	push	r12
   14b12:	df 92       	push	r13
   14b14:	ef 92       	push	r14
   14b16:	ff 92       	push	r15
   14b18:	0f 93       	push	r16
   14b1a:	1f 93       	push	r17
   14b1c:	cf 93       	push	r28
   14b1e:	df 93       	push	r29
 __asm__ __volatile__("sei" ::); 
   14b20:	78 94       	sei
 	for (msn=0;msn<=10;msn++)
   14b22:	10 92 8d 0a 	sts	0x0A8D, r1
   14b26:	10 92 8c 0a 	sts	0x0A8C, r1
   14b2a:	e4 e9       	ldi	r30, 0x94	; 148
   14b2c:	fa e0       	ldi	r31, 0x0A	; 10
 	  array[msn] = 0; 
   14b2e:	11 92       	st	Z+, r1
   14b30:	11 92       	st	Z+, r1
   14b32:	2a e0       	ldi	r18, 0x0A	; 10
   14b34:	ea 3a       	cpi	r30, 0xAA	; 170
   14b36:	f2 07       	cpc	r31, r18
   14b38:	d1 f7       	brne	.-12     	; 0x14b2e
 	  
	for (msn=0;msn<300;msn++)
   14b3a:	10 92 8d 0a 	sts	0x0A8D, r1
   14b3e:	10 92 8c 0a 	sts	0x0A8C, r1

void greenToggle()
{
 void (*greenfp)() = (void (*)(void))GREENTOGGLEFUNCTION; 
 greenfp();                              
   14b42:	e4 e0       	ldi	r30, 0x04	; 4
   14b44:	fa ee       	ldi	r31, 0xEA	; 234
   14b46:	09 95       	icall
	{
  greenToggle();
  cde.a = 1 ;
   14b48:	81 e0       	ldi	r24, 0x01	; 1
   14b4a:	90 e0       	ldi	r25, 0x00	; 0
   14b4c:	90 93 8f 0a 	sts	0x0A8F, r25
   14b50:	80 93 8e 0a 	sts	0x0A8E, r24
  cde.b = 2; 
   14b54:	82 e0       	ldi	r24, 0x02	; 2
   14b56:	90 e0       	ldi	r25, 0x00	; 0
   14b58:	90 93 91 0a 	sts	0x0A91, r25
   14b5c:	80 93 90 0a 	sts	0x0A90, r24



}

void redToggle()
{
                          
  void (*redfp)() = (void (*)(void))REDTOGGLEFUNCTION; 
  redfp();    
}


void yellowToggle()
{
                          
  void (*yellowfp)() = (void (*)(void))YELLOWTOGGLEFUNCTION; 
  yellowfp();    
   14b60:	e0 e7       	ldi	r30, 0x70	; 112
   14b62:	fa ee       	ldi	r31, 0xEA	; 234
   14b64:	09 95       	icall
int get_light()
{
   thread** current_thread; 
   void (*fp)() = (void (*)(void))ADCLIGHT;
   current_thread = getCurrentThread();    
   14b66:	0e 94 65 a5 	call	0x14aca
   14b6a:	8c 01       	movw	r16, r24
   fp(); 
   14b6c:	e0 e4       	ldi	r30, 0x40	; 64
   14b6e:	fa ee       	ldi	r31, 0xEA	; 234
   14b70:	09 95       	icall
   return (*current_thread)->data.adcstate.adcreading;  
   14b72:	d8 01       	movw	r26, r16
   14b74:	ed 91       	ld	r30, X+
   14b76:	fc 91       	ld	r31, X
   14b78:	83 8d       	ldd	r24, Z+27	; 0x1b
   14b7a:	94 8d       	ldd	r25, Z+28	; 0x1c
	yellowToggle(); 
	reading = get_light();
   14b7c:	90 93 93 0a 	sts	0x0A93, r25
   14b80:	80 93 92 0a 	sts	0x0A92, r24
  uint8_t temp1,temp2; 
  temp1 = (uint8_t) (value >> 8);
  temp2 = (uint8_t) (value & 0x00ff);

  buffer[0] = temp1; 
   14b84:	29 2f       	mov	r18, r25
   14b86:	33 27       	eor	r19, r19
   14b88:	20 93 a8 0a 	sts	0x0AA8, r18
  buffer[1] = temp2; 
   14b8c:	80 93 a9 0a 	sts	0x0AA9, r24
  buffer[2] = buffer[3] = 0xee; 
   14b90:	8e ee       	ldi	r24, 0xEE	; 238
   14b92:	80 93 ab 0a 	sts	0x0AAB, r24
   14b96:	80 93 aa 0a 	sts	0x0AAA, r24
mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GETRADIOMUTEXFUNCTION; 
   asm volatile("push r20" "\n\t"
   14b9a:	4f 93       	push	r20
   14b9c:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   14b9e:	e0 e1       	ldi	r30, 0x10	; 16
   14ba0:	fa ee       	ldi	r31, 0xEA	; 234
   14ba2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   14ba4:	c4 2f       	mov	r28, r20
   14ba6:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
   14ba8:	5f 91       	pop	r21
   14baa:	4f 91       	pop	r20
   
  return radioSend(12, 0xffff, 16, buffer); 

}




radiohandletype *getCurrentRadioHandleAddr()
{
   radiohandletype *currentradioinfo; 

   void (*getaddrfp)(void) = (void (*)(void))GETCURRENTRADIOHANDLE; 

   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo; 
}


void setRadioFreq(uint16_t freq)
{
  
   void (*getaddrfp)(void) = (void (*)(void))SETRADIOFREQFUNCTION; 

   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
      
   asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (freq)
                );
   getaddrfp(); 
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return; 
}

void setRadioChannel(uint8_t channel)
{
  
  uint16_t maskchannel = channel; 
  
  void (*getaddrfp)(void) = (void (*)(void))SETRADIOCHANNELFUNCTION; 

  asm volatile("push r20" "\n\t"
               "push r21" "\n\t"
               ::);
      
  asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp(); 
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return; 
}

void setRadioPower(uint8_t power)
{
  
  uint16_t maskchannel = power; 
  
  void (*getaddrfp)(void) = (void (*)(void))SETRADIOPOWERFUNCTION; 

  asm volatile("push r20" "\n\t"
               "push r21" "\n\t"
               ::);
      
  asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp(); 
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return; 
}



radioinfotype *getCurrentRadioInfo()
{
   radioinfotype *currentradioinfo; 
   void (*getaddrfp)(void) = (void (*)(void))GETCURRENTRADIOINFO; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo; 
}


void disableRadioState()
{
  
   void (*disableradiofp)(void) = (void (*)(void))DISABLERADIOSTATE; 
   
   disableradiofp();     

   return;	
}


void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{
 
 
   mutex* msend; 
   thread** current_thread; 
   radioinfotype *radioinfoaddr; 

  
   
   msend = getRadioMutexAddress();   
   current_thread = getCurrentThread(); 
   14bac:	0e 94 65 a5 	call	0x14aca
   14bb0:	4f 93       	push	r20
   14bb2:	5f 93       	push	r21
   14bb4:	ec e5       	ldi	r30, 0x5C	; 92
   14bb6:	fa ee       	ldi	r31, 0xEA	; 234
   14bb8:	09 95       	icall
   14bba:	04 2f       	mov	r16, r20
   14bbc:	15 2f       	mov	r17, r21
   14bbe:	5f 91       	pop	r21
   14bc0:	4f 91       	pop	r20
   14bc2:	0e 94 65 a5 	call	0x14aca
   14bc6:	7c 01       	movw	r14, r24
   14bc8:	4f 93       	push	r20
   14bca:	5f 93       	push	r21
   14bcc:	ec e1       	ldi	r30, 0x1C	; 28
   14bce:	fa ee       	ldi	r31, 0xEA	; 234
   14bd0:	09 95       	icall
   14bd2:	c4 2e       	mov	r12, r20
   14bd4:	d5 2e       	mov	r13, r21
   14bd6:	5f 91       	pop	r21
   14bd8:	4f 91       	pop	r20


_atomic_t _atomic_start(void) 
{
  _atomic_t result = SREG;
   14bda:	bf b6       	in	r11, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
   14bdc:	f8 94       	cli
   14bde:	88 81       	ld	r24, Y
   14be0:	88 23       	and	r24, r24
   14be2:	91 f0       	breq	.+36     	; 0x14c08
   14be4:	d7 01       	movw	r26, r14
   14be6:	ed 91       	ld	r30, X+
   14be8:	fc 91       	ld	r31, X
   14bea:	11 97       	sbiw	r26, 0x01	; 1
   14bec:	83 e0       	ldi	r24, 0x03	; 3
   14bee:	82 83       	std	Z+2, r24	; 0x02
   14bf0:	ed 91       	ld	r30, X+
   14bf2:	fc 91       	ld	r31, X
   14bf4:	d4 8f       	std	Z+28, r29	; 0x1c
   14bf6:	c3 8f       	std	Z+27, r28	; 0x1b
   14bf8:	89 81       	ldd	r24, Y+1	; 0x01
   14bfa:	8f 5f       	subi	r24, 0xFF	; 255
   14bfc:	89 83       	std	Y+1, r24	; 0x01
   14bfe:	0e 94 6f a5 	call	0x14ade
   14c02:	89 81       	ldd	r24, Y+1	; 0x01
   14c04:	81 50       	subi	r24, 0x01	; 1
   14c06:	89 83       	std	Y+1, r24	; 0x01
   14c08:	81 e0       	ldi	r24, 0x01	; 1
   14c0a:	88 83       	st	Y, r24
   14c0c:	8c 2d       	mov	r24, r12
   14c0e:	99 27       	eor	r25, r25
   14c10:	8a 83       	std	Y+2, r24	; 0x02
   14c12:	8b 2d       	mov	r24, r11
   14c14:	99 27       	eor	r25, r25
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg; 
   14c16:	8f bf       	out	0x3f, r24	; 63
   radioinfoaddr = getCurrentRadioInfo();

   Mutex_lock(msend);
     
   radioinfoaddr-> socket_port = port; 
   14c18:	8c e0       	ldi	r24, 0x0C	; 12
   14c1a:	90 e0       	ldi	r25, 0x00	; 0
   14c1c:	f8 01       	movw	r30, r16
   14c1e:	91 83       	std	Z+1, r25	; 0x01
   14c20:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address; 
   14c22:	8f ef       	ldi	r24, 0xFF	; 255
   14c24:	9f ef       	ldi	r25, 0xFF	; 255
   14c26:	93 83       	std	Z+3, r25	; 0x03
   14c28:	82 83       	std	Z+2, r24	; 0x02
   radioinfoaddr->socket_msg_len  = length; 
   14c2a:	80 e1       	ldi	r24, 0x10	; 16
   14c2c:	84 83       	std	Z+4, r24	; 0x04
   radioinfoaddr->socket_msg  = msg;
   14c2e:	88 ea       	ldi	r24, 0xA8	; 168
   14c30:	9a e0       	ldi	r25, 0x0A	; 10
   14c32:	96 83       	std	Z+6, r25	; 0x06
   14c34:	85 83       	std	Z+5, r24	; 0x05
   14c36:	e4 e1       	ldi	r30, 0x14	; 20
   14c38:	fa ee       	ldi	r31, 0xEA	; 234
   14c3a:	09 95       	icall
    
   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg(); 

   sleepThread(30); 
   14c3c:	8e e1       	ldi	r24, 0x1E	; 30
   14c3e:	90 e0       	ldi	r25, 0x00	; 0
   14c40:	0e 94 73 a5 	call	0x14ae6
   14c44:	e8 eb       	ldi	r30, 0xB8	; 184
   14c46:	fa ee       	ldi	r31, 0xEA	; 234
   14c48:	09 95       	icall
   14c4a:	4f 93       	push	r20
   14c4c:	5f 93       	push	r21
   14c4e:	4c 2f       	mov	r20, r28
   14c50:	5d 2f       	mov	r21, r29
   14c52:	e8 e1       	ldi	r30, 0x18	; 24
   14c54:	fa ee       	ldi	r31, 0xEA	; 234
   14c56:	09 95       	icall
   14c58:	5f 91       	pop	r21
   14c5a:	4f 91       	pop	r20
	radioSend_uint16(reading); 	
	sleepThread(1000);
   14c5c:	88 ee       	ldi	r24, 0xE8	; 232
   14c5e:	93 e0       	ldi	r25, 0x03	; 3
   14c60:	0e 94 73 a5 	call	0x14ae6
	if (msn==299)
   14c64:	80 91 8c 0a 	lds	r24, 0x0A8C
   14c68:	90 91 8d 0a 	lds	r25, 0x0A8D
   14c6c:	f1 e0       	ldi	r31, 0x01	; 1
   14c6e:	8b 32       	cpi	r24, 0x2B	; 43
   14c70:	9f 07       	cpc	r25, r31
   14c72:	39 f4       	brne	.+14     	; 0x14c82
   14c74:	82 e0       	ldi	r24, 0x02	; 2
   14c76:	90 e0       	ldi	r25, 0x00	; 0
   14c78:	90 93 8d 0a 	sts	0x0A8D, r25
   14c7c:	80 93 8c 0a 	sts	0x0A8C, r24
   14c80:	60 cf       	rjmp	.-320    	; 0x14b42
   14c82:	01 96       	adiw	r24, 0x01	; 1
   14c84:	90 93 8d 0a 	sts	0x0A8D, r25
   14c88:	80 93 8c 0a 	sts	0x0A8C, r24
   14c8c:	8c 52       	subi	r24, 0x2C	; 44
   14c8e:	91 40       	sbci	r25, 0x01	; 1
   14c90:	0c f4       	brge	.+2      	; 0x14c94
   14c92:	57 cf       	rjmp	.-338    	; 0x14b42
		msn = 1; 
	}
	return 0; 
}
   14c94:	80 e0       	ldi	r24, 0x00	; 0
   14c96:	90 e0       	ldi	r25, 0x00	; 0
   14c98:	df 91       	pop	r29
   14c9a:	cf 91       	pop	r28
   14c9c:	1f 91       	pop	r17
   14c9e:	0f 91       	pop	r16
   14ca0:	ff 90       	pop	r15
   14ca2:	ef 90       	pop	r14
   14ca4:	df 90       	pop	r13
   14ca6:	cf 90       	pop	r12
   14ca8:	bf 90       	pop	r11
   14caa:	08 95       	ret

00014cac <syscall_postThreadTask.1393>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POSTTHREADTASK; 
 postthreadfp();                              
   14cac:	e8 e6       	ldi	r30, 0x68	; 104
   14cae:	fa ee       	ldi	r31, 0xEA	; 234
   14cb0:	09 95       	icall
   14cb2:	08 95       	ret

00014cb4 <wakeupMe.3001>:
   
   disableRadioState();

  
   Mutex_unlock(msend); 

   return; 
}



//wakeup the current thread once an incoming packet arrives 

void wakeupMe()
{
  mythread->state = STATE_ACTIVE; 
   14cb4:	e0 91 c8 0a 	lds	r30, 0x0AC8
   14cb8:	f0 91 c9 0a 	lds	r31, 0x0AC9
   14cbc:	82 e0       	ldi	r24, 0x02	; 2
   14cbe:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14cc0:	0e 94 56 a6 	call	0x14cac
   14cc4:	08 95       	ret

00014cc6 <wakeupMeSerial.3257>:
//wakeup the current thread once an incoming packet arrives 

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE; 
   14cc6:	e0 91 ca 0a 	lds	r30, 0x0ACA
   14cca:	f0 91 cb 0a 	lds	r31, 0x0ACB
   14cce:	82 e0       	ldi	r24, 0x02	; 2
   14cd0:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   14cd2:	0e 94 56 a6 	call	0x14cac
   14cd6:	08 95       	ret
