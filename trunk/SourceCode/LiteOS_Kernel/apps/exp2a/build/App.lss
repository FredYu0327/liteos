
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800b54  0000ca8a  0000031e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000028a  0000c800  0000c800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800b64  00800b64  0000032e  2**0
                  ALLOC
  3 .stab         00000408  00000000  00000000  00000330  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000084  00000000  00000000  00000738  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  000007bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000001b  00000000  00000000  000007dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000017c4  00000000  00000000  000007f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000273  00000000  00000000  00001fbb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000370  00000000  00000000  0000222e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000060  00000000  00000000  0000259e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000047d  00000000  00000000  000025fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000088  00000000  00000000  00002a7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  00002b03  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

0000c800 <__vectors>:
    c800:	0c 94 46 64 	jmp	0xc88c	; 0xc88c <__ctors_end>
    c804:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c808:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c80c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c810:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c814:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c818:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c81c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c820:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c824:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c828:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c82c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c830:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c834:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c838:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c83c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c840:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c844:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c848:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c84c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c850:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c854:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c858:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c85c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c860:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c864:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c868:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c86c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c870:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c874:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c878:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c87c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c880:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c884:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c888:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>

0000c88c <__ctors_end>:
    c88c:	11 24       	eor	r1, r1
    c88e:	1f be       	out	0x3f, r1	; 63
    c890:	cc e1       	ldi	r28, 0x1C	; 28
    c892:	dc e0       	ldi	r29, 0x0C	; 12
    c894:	de bf       	out	0x3e, r29	; 62
    c896:	cd bf       	out	0x3d, r28	; 61

0000c898 <__do_copy_data>:
    c898:	1b e0       	ldi	r17, 0x0B	; 11
    c89a:	a4 e5       	ldi	r26, 0x54	; 84
    c89c:	bb e0       	ldi	r27, 0x0B	; 11
    c89e:	ea e8       	ldi	r30, 0x8A	; 138
    c8a0:	fa ec       	ldi	r31, 0xCA	; 202
    c8a2:	00 e0       	ldi	r16, 0x00	; 0
    c8a4:	0b bf       	out	0x3b, r16	; 59
    c8a6:	02 c0       	rjmp	.+4      	; 0xc8ac <__do_copy_data+0x14>
    c8a8:	07 90       	elpm	r0, Z+
    c8aa:	0d 92       	st	X+, r0
    c8ac:	a4 36       	cpi	r26, 0x64	; 100
    c8ae:	b1 07       	cpc	r27, r17
    c8b0:	d9 f7       	brne	.-10     	; 0xc8a8 <__do_copy_data+0x10>

0000c8b2 <__do_clear_bss>:
    c8b2:	1b e0       	ldi	r17, 0x0B	; 11
    c8b4:	a4 e6       	ldi	r26, 0x64	; 100
    c8b6:	bb e0       	ldi	r27, 0x0B	; 11
    c8b8:	01 c0       	rjmp	.+2      	; 0xc8bc <.do_clear_bss_start>

0000c8ba <.do_clear_bss_loop>:
    c8ba:	1d 92       	st	X+, r1

0000c8bc <.do_clear_bss_start>:
    c8bc:	a6 36       	cpi	r26, 0x66	; 102
    c8be:	b1 07       	cpc	r27, r17
    c8c0:	e1 f7       	brne	.-8      	; 0xc8ba <.do_clear_bss_loop>
    c8c2:	0c 94 87 64 	jmp	0xc90e	; 0xc90e <main>

0000c8c6 <__bad_interrupt>:
    c8c6:	0c 94 00 64 	jmp	0xc800	; 0xc800 <__vectors>

0000c8ca <getCurrentThread.1404>:

//Warning: this returns the address of the currentthread pointer. 

thread **getCurrentThread()
{
    c8ca:	4f 93       	push	r20
    c8cc:	5f 93       	push	r21
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    c8ce:	ec e0       	ldi	r30, 0x0C	; 12
    c8d0:	fa ee       	ldi	r31, 0xEA	; 234
    c8d2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    c8d4:	84 2f       	mov	r24, r20
    c8d6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
    c8d8:	5f 91       	pop	r21
    c8da:	4f 91       	pop	r20
    c8dc:	08 95       	ret

0000c8de <yield.1403>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}


void **getKernelStackPtr()
	{
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
}







uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
    c8de:	e0 e0       	ldi	r30, 0x00	; 0
    c8e0:	fa ee       	ldi	r31, 0xEA	; 234
    c8e2:	09 95       	icall
    c8e4:	08 95       	ret

0000c8e6 <sleepThread.1402>:
    c8e6:	0f 93       	push	r16
    c8e8:	1f 93       	push	r17
    c8ea:	8c 01       	movw	r16, r24
    c8ec:	0e 94 65 64 	call	0xc8ca	; 0xc8ca <getCurrentThread.1404>
    c8f0:	dc 01       	movw	r26, r24
    c8f2:	ed 91       	ld	r30, X+
    c8f4:	fc 91       	ld	r31, X
    c8f6:	11 97       	sbiw	r26, 0x01	; 1
    c8f8:	84 e0       	ldi	r24, 0x04	; 4
    c8fa:	82 83       	std	Z+2, r24	; 0x02
    c8fc:	ed 91       	ld	r30, X+
    c8fe:	fc 91       	ld	r31, X
    c900:	14 8f       	std	Z+28, r17	; 0x1c
    c902:	03 8f       	std	Z+27, r16	; 0x1b
    c904:	0e 94 6f 64 	call	0xc8de	; 0xc8de <yield.1403>
    c908:	1f 91       	pop	r17
    c90a:	0f 91       	pop	r16
    c90c:	08 95       	ret

0000c90e <main>:
#define PRG_RDB(addr) pgm_read_byte(addr)
#endif

int main()
{
    c90e:	8f 92       	push	r8
    c910:	9f 92       	push	r9
    c912:	af 92       	push	r10
    c914:	bf 92       	push	r11
    c916:	cf 92       	push	r12
    c918:	df 92       	push	r13
    c91a:	ef 92       	push	r14
    c91c:	ff 92       	push	r15
    c91e:	0f 93       	push	r16
    c920:	1f 93       	push	r17
    c922:	cf 93       	push	r28
    c924:	df 93       	push	r29
 uint16_t index;
 uint8_t index2; 
  thread** current_thread;
 
 __asm__ __volatile__("sei" ::); 
    c926:	78 94       	sei
 

	  
    current_thread = getCurrentThread();  
    c928:	0e 94 65 64 	call	0xc8ca	; 0xc8ca <getCurrentThread.1404>
    c92c:	dc 01       	movw	r26, r24
    
   (*current_thread)->ecbptr->share = 300; 
    c92e:	ed 91       	ld	r30, X+
    c930:	fc 91       	ld	r31, X
    c932:	11 97       	sbiw	r26, 0x01	; 1
    c934:	05 a0       	ldd	r0, Z+37	; 0x25
    c936:	f6 a1       	ldd	r31, Z+38	; 0x26
    c938:	e0 2d       	mov	r30, r0
    c93a:	8c e2       	ldi	r24, 0x2C	; 44
    c93c:	81 83       	std	Z+1, r24	; 0x01
   (*current_thread)->ecbptr->totalenergy =  480000; 
    c93e:	ed 91       	ld	r30, X+
    c940:	fc 91       	ld	r31, X
    c942:	05 a0       	ldd	r0, Z+37	; 0x25
    c944:	f6 a1       	ldd	r31, Z+38	; 0x26
    c946:	e0 2d       	mov	r30, r0
    c948:	80 e0       	ldi	r24, 0x00	; 0
    c94a:	93 e5       	ldi	r25, 0x53	; 83
    c94c:	a7 e0       	ldi	r26, 0x07	; 7
    c94e:	b0 e0       	ldi	r27, 0x00	; 0
    c950:	83 83       	std	Z+3, r24	; 0x03
    c952:	94 83       	std	Z+4, r25	; 0x04
    c954:	a5 83       	std	Z+5, r26	; 0x05
    c956:	b6 83       	std	Z+6, r27	; 0x06
   (*current_thread)->ecbptr->remainenergy = 480000; 
    c958:	87 83       	std	Z+7, r24	; 0x07
    c95a:	90 87       	std	Z+8, r25	; 0x08
    c95c:	a1 87       	std	Z+9, r26	; 0x09
    c95e:	b2 87       	std	Z+10, r27	; 0x0a
     
   //sbi(MCUCR, SM0);

   //sbi(MCUCR, SM1);
   //cbi(MCUCR, SM2); 
   //sbi(MCUCR, SE);
   
   //printfstring("before send\n");
   while(1)
   	{
	   
	   radioSend_string("hello, world!\n"); 
    c960:	84 e5       	ldi	r24, 0x54	; 84
    c962:	88 2e       	mov	r8, r24
    c964:	8b e0       	ldi	r24, 0x0B	; 11
    c966:	98 2e       	mov	r9, r24
    c968:	f4 01       	movw	r30, r8
    c96a:	01 c0       	rjmp	.+2      	; 0xc96e <main+0x60>
    c96c:	31 96       	adiw	r30, 0x01	; 1


int String_length(char* s) {
	int count=0;
	while(s[count] != '\0')
    c96e:	80 81       	ld	r24, Z
    c970:	88 23       	and	r24, r24
    c972:	e1 f7       	brne	.-8      	; 0xc96c <main+0x5e>
//This function sends out a string

void radioSend_string(uint8_t *msg)
{
    uint8_t temp = (uint8_t)String_length((char *)msg);
    c974:	e4 55       	subi	r30, 0x54	; 84
    c976:	fb 40       	sbci	r31, 0x0B	; 11
    c978:	ae 2e       	mov	r10, r30
 #ifdef ENERGY_INSTRUMENTATION
 return radioSend_energywrapper(1, 0xffff, temp, msg);
 #else
	return radioSend(1, 0xffff, temp, msg);
 #endif
}

void radioSend_uint16(uint16_t value)
{
  uint8_t temp1,temp2;
  temp1 = (uint8_t) (value >> 8);
  temp2 = (uint8_t) (value & 0x00ff);

  buffer[0] = temp1;
  buffer[1] = temp2;
  buffer[2] = buffer[3] = 0xee;

  return radioSend(12, 0xffff, 16, buffer);
}

radiohandletype *getCurrentRadioHandleAddr()
{
   radiohandletype *currentradioinfo;

   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_HANDLE_ADDR;

   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo;
}


void setRadioFreq(uint16_t freq)
{

   void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_FREQ_FUNCTION;

   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);

   asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (freq)
                );
   getaddrfp();
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return;
}

void setRadioChannel(uint8_t channel)
{

  uint16_t maskchannel = channel;

  void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_CHANNEL_FUNCTION;

  asm volatile("push r20" "\n\t"
               "push r21" "\n\t"
               ::);

  asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp();
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return;
}

void setRadioPower(uint8_t power)
{

  uint16_t maskchannel = power;

  void (*getaddrfp)(void) = (void (*)(void))SET_RADIO_POWER_FUNCTION;

  asm volatile("push r20" "\n\t"
               "push r21" "\n\t"
               ::);

  asm volatile(" mov r20, %A0" "\n\t"
	              "mov r21, %B0" "\n\t"
				 :
				 :"r" (maskchannel)
                );
   getaddrfp();
   asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return;
}



radioinfotype *getCurrentRadioInfoAddr()
{
   radioinfotype *currentradioinfo;
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_RADIO_INFO_ADDR;
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (currentradioinfo)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return currentradioinfo;
}


void disableRadioState()
{

   void (*disableradiofp)(void) = (void (*)(void))RESTORE_RADIO_STATE;

   disableradiofp();

   return;
}

 
void radioSend_energywrapper(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg){
	 
	  
	    thread** current_thread;
	  
      current_thread = getCurrentThread();      
    c97a:	0e 94 65 64 	call	0xc8ca	; 0xc8ca <getCurrentThread.1404>
    c97e:	fc 01       	movw	r30, r24
      
     // if ((*current_thread)->ecbptr->remainenergy > (uint16_t)RADIO_ENERGY_CONSUMPTION_PER_BIT * (uint16_t)length)
      	//{
      		 (*current_thread)->ecbptr->remainenergy -= (uint16_t)RADIO_SEND * (uint16_t)length;           
    c980:	01 90       	ld	r0, Z+
    c982:	f0 81       	ld	r31, Z
    c984:	e0 2d       	mov	r30, r0
    c986:	05 a0       	ldd	r0, Z+37	; 0x25
    c988:	f6 a1       	ldd	r31, Z+38	; 0x26
    c98a:	e0 2d       	mov	r30, r0
    c98c:	27 ea       	ldi	r18, 0xA7	; 167
    c98e:	a2 9e       	mul	r10, r18
    c990:	90 01       	movw	r18, r0
    c992:	11 24       	eor	r1, r1
    c994:	44 27       	eor	r20, r20
    c996:	55 27       	eor	r21, r21
    c998:	87 81       	ldd	r24, Z+7	; 0x07
    c99a:	90 85       	ldd	r25, Z+8	; 0x08
    c99c:	a1 85       	ldd	r26, Z+9	; 0x09
    c99e:	b2 85       	ldd	r27, Z+10	; 0x0a
    c9a0:	82 1b       	sub	r24, r18
    c9a2:	93 0b       	sbc	r25, r19
    c9a4:	a4 0b       	sbc	r26, r20
    c9a6:	b5 0b       	sbc	r27, r21
    c9a8:	87 83       	std	Z+7, r24	; 0x07
    c9aa:	90 87       	std	Z+8, r25	; 0x08
    c9ac:	a1 87       	std	Z+9, r26	; 0x09
    c9ae:	b2 87       	std	Z+10, r27	; 0x0a
mutex *getRadioMutexAddress()
{
   mutex *msend;   
   void (*getaddrfp)(void) = (void (*)(void))GET_RADIO_MUTEX_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
    c9b0:	4f 93       	push	r20
    c9b2:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    c9b4:	e0 e1       	ldi	r30, 0x10	; 16
    c9b6:	fa ee       	ldi	r31, 0xEA	; 234
    c9b8:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    c9ba:	c4 2f       	mov	r28, r20
    c9bc:	d5 2f       	mov	r29, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (msend)
				 :
                );
    asm volatile("pop r21" "\n\t"
    c9be:	5f 91       	pop	r21
    c9c0:	4f 91       	pop	r20
      		 
      		 radioSend(port, address, length, msg);       		 
       // }
      
     // else
     // {	
      //  (*current_thread)->ecbptr->remainenergy = 0;  
     // 	(*current_thread)->state = STATE_SUSPEND;   	
     // }
      
    
    
    // radioSend(port, address, length, msg); 
}

 




void radioSend(uint16_t port, uint16_t address, uint8_t length, uint8_t *msg)
{


   mutex* msend;
   thread** current_thread;
   radioinfotype *radioinfoaddr;



   msend = getRadioMutexAddress();
   current_thread = getCurrentThread();
    c9c2:	0e 94 65 64 	call	0xc8ca	; 0xc8ca <getCurrentThread.1404>
    c9c6:	4f 93       	push	r20
    c9c8:	5f 93       	push	r21
    c9ca:	ec e5       	ldi	r30, 0x5C	; 92
    c9cc:	fa ee       	ldi	r31, 0xEA	; 234
    c9ce:	09 95       	icall
    c9d0:	04 2f       	mov	r16, r20
    c9d2:	15 2f       	mov	r17, r21
    c9d4:	5f 91       	pop	r21
    c9d6:	4f 91       	pop	r20
    c9d8:	0e 94 65 64 	call	0xc8ca	; 0xc8ca <getCurrentThread.1404>
    c9dc:	7c 01       	movw	r14, r24
    c9de:	4f 93       	push	r20
    c9e0:	5f 93       	push	r21
    c9e2:	ec e1       	ldi	r30, 0x1C	; 28
    c9e4:	fa ee       	ldi	r31, 0xEA	; 234
    c9e6:	09 95       	icall
    c9e8:	c4 2e       	mov	r12, r20
    c9ea:	d5 2e       	mov	r13, r21
    c9ec:	5f 91       	pop	r21
    c9ee:	4f 91       	pop	r20


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
    c9f0:	bf b6       	in	r11, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
    c9f2:	f8 94       	cli
    c9f4:	88 81       	ld	r24, Y
    c9f6:	88 23       	and	r24, r24
    c9f8:	91 f0       	breq	.+36     	; 0xca1e <main+0x110>
    c9fa:	d7 01       	movw	r26, r14
    c9fc:	ed 91       	ld	r30, X+
    c9fe:	fc 91       	ld	r31, X
    ca00:	11 97       	sbiw	r26, 0x01	; 1
    ca02:	83 e0       	ldi	r24, 0x03	; 3
    ca04:	82 83       	std	Z+2, r24	; 0x02
    ca06:	ed 91       	ld	r30, X+
    ca08:	fc 91       	ld	r31, X
    ca0a:	d4 8f       	std	Z+28, r29	; 0x1c
    ca0c:	c3 8f       	std	Z+27, r28	; 0x1b
    ca0e:	89 81       	ldd	r24, Y+1	; 0x01
    ca10:	8f 5f       	subi	r24, 0xFF	; 255
    ca12:	89 83       	std	Y+1, r24	; 0x01
    ca14:	0e 94 6f 64 	call	0xc8de	; 0xc8de <yield.1403>
    ca18:	89 81       	ldd	r24, Y+1	; 0x01
    ca1a:	81 50       	subi	r24, 0x01	; 1
    ca1c:	89 83       	std	Y+1, r24	; 0x01
    ca1e:	81 e0       	ldi	r24, 0x01	; 1
    ca20:	88 83       	st	Y, r24
    ca22:	8c 2d       	mov	r24, r12
    ca24:	99 27       	eor	r25, r25
    ca26:	8a 83       	std	Y+2, r24	; 0x02
    ca28:	8b 2d       	mov	r24, r11
    ca2a:	99 27       	eor	r25, r25
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
    ca2c:	8f bf       	out	0x3f, r24	; 63
   radioinfoaddr = getCurrentRadioInfoAddr();

   Mutex_lock(msend);

   radioinfoaddr-> socket_port = port;
    ca2e:	81 e0       	ldi	r24, 0x01	; 1
    ca30:	90 e0       	ldi	r25, 0x00	; 0
    ca32:	f8 01       	movw	r30, r16
    ca34:	91 83       	std	Z+1, r25	; 0x01
    ca36:	80 83       	st	Z, r24
   radioinfoaddr->socket_addr = address;
    ca38:	8f ef       	ldi	r24, 0xFF	; 255
    ca3a:	9f ef       	ldi	r25, 0xFF	; 255
    ca3c:	93 83       	std	Z+3, r25	; 0x03
    ca3e:	82 83       	std	Z+2, r24	; 0x02
   radioinfoaddr->socket_msg_len  = length;
    ca40:	a4 82       	std	Z+4, r10	; 0x04
   radioinfoaddr->socket_msg  = msg;
    ca42:	96 82       	std	Z+6, r9	; 0x06
    ca44:	85 82       	std	Z+5, r8	; 0x05
    ca46:	e4 e1       	ldi	r30, 0x14	; 20
    ca48:	fa ee       	ldi	r31, 0xEA	; 234
    ca4a:	09 95       	icall

   //pending_id = id;
   //pending_address = address;
   //pending_length = length;
   //pending_msg = msg;

   sendRadioMsg();

   sleepThread(20);
    ca4c:	84 e1       	ldi	r24, 0x14	; 20
    ca4e:	90 e0       	ldi	r25, 0x00	; 0
    ca50:	0e 94 73 64 	call	0xc8e6	; 0xc8e6 <sleepThread.1402>
    ca54:	e8 eb       	ldi	r30, 0xB8	; 184
    ca56:	fa ee       	ldi	r31, 0xEA	; 234
    ca58:	09 95       	icall
    ca5a:	4f 93       	push	r20
    ca5c:	5f 93       	push	r21
    ca5e:	4c 2f       	mov	r20, r28
    ca60:	5d 2f       	mov	r21, r29
    ca62:	e8 e1       	ldi	r30, 0x18	; 24
    ca64:	fa ee       	ldi	r31, 0xEA	; 234
    ca66:	09 95       	icall
    ca68:	5f 91       	pop	r21
    ca6a:	4f 91       	pop	r20
	   sleepThread(100);
    ca6c:	84 e6       	ldi	r24, 0x64	; 100
    ca6e:	90 e0       	ldi	r25, 0x00	; 0
    ca70:	0e 94 73 64 	call	0xc8e6	; 0xc8e6 <sleepThread.1402>
    ca74:	75 cf       	rjmp	.-278    	; 0xc960 <main+0x52>

0000ca76 <wakeupMe.3678>:

   disableRadioState();

   Mutex_unlock(msend);

   return;
}

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
    ca76:	e0 91 64 0b 	lds	r30, 0x0B64
    ca7a:	f0 91 65 0b 	lds	r31, 0x0B65
    ca7e:	82 e0       	ldi	r24, 0x02	; 2
    ca80:	82 83       	std	Z+2, r24	; 0x02
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    ca82:	e8 e6       	ldi	r30, 0x68	; 104
    ca84:	fa ee       	ldi	r31, 0xEA	; 234
    ca86:	09 95       	icall
    ca88:	08 95       	ret
