
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800cb2  00017fd4  00000468  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000003d4  00017c00  00017c00  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000006c  00800cbc  00800cbc  00000472  2**0
                  ALLOC
  3 .stab         00000408  00000000  00000000  00000474  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000084  00000000  00000000  0000087c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  00000900  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000001b  00000000  00000000  00000920  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001f8b  00000000  00000000  0000093b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000028f  00000000  00000000  000028c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000050f  00000000  00000000  00002b55  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000d0  00000000  00000000  00003064  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000046f  00000000  00000000  00003134  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000001d4  00000000  00000000  000035a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  00003777  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00017c00 <__vectors>:
   17c00:	0c 94 46 be 	jmp	0x17c8c
   17c04:	0c 94 63 be 	jmp	0x17cc6
   17c08:	0c 94 63 be 	jmp	0x17cc6
   17c0c:	0c 94 63 be 	jmp	0x17cc6
   17c10:	0c 94 63 be 	jmp	0x17cc6
   17c14:	0c 94 63 be 	jmp	0x17cc6
   17c18:	0c 94 63 be 	jmp	0x17cc6
   17c1c:	0c 94 63 be 	jmp	0x17cc6
   17c20:	0c 94 63 be 	jmp	0x17cc6
   17c24:	0c 94 63 be 	jmp	0x17cc6
   17c28:	0c 94 63 be 	jmp	0x17cc6
   17c2c:	0c 94 63 be 	jmp	0x17cc6
   17c30:	0c 94 63 be 	jmp	0x17cc6
   17c34:	0c 94 63 be 	jmp	0x17cc6
   17c38:	0c 94 63 be 	jmp	0x17cc6
   17c3c:	0c 94 63 be 	jmp	0x17cc6
   17c40:	0c 94 63 be 	jmp	0x17cc6
   17c44:	0c 94 63 be 	jmp	0x17cc6
   17c48:	0c 94 63 be 	jmp	0x17cc6
   17c4c:	0c 94 63 be 	jmp	0x17cc6
   17c50:	0c 94 63 be 	jmp	0x17cc6
   17c54:	0c 94 63 be 	jmp	0x17cc6
   17c58:	0c 94 63 be 	jmp	0x17cc6
   17c5c:	0c 94 63 be 	jmp	0x17cc6
   17c60:	0c 94 63 be 	jmp	0x17cc6
   17c64:	0c 94 63 be 	jmp	0x17cc6
   17c68:	0c 94 63 be 	jmp	0x17cc6
   17c6c:	0c 94 63 be 	jmp	0x17cc6
   17c70:	0c 94 63 be 	jmp	0x17cc6
   17c74:	0c 94 63 be 	jmp	0x17cc6
   17c78:	0c 94 63 be 	jmp	0x17cc6
   17c7c:	0c 94 63 be 	jmp	0x17cc6
   17c80:	0c 94 63 be 	jmp	0x17cc6
   17c84:	0c 94 63 be 	jmp	0x17cc6
   17c88:	0c 94 63 be 	jmp	0x17cc6

00017c8c <__ctors_end>:
   17c8c:	11 24       	eor	r1, r1
   17c8e:	1f be       	out	0x3f, r1	; 63
   17c90:	cc ea       	ldi	r28, 0xAC	; 172
   17c92:	dd e0       	ldi	r29, 0x0D	; 13
   17c94:	de bf       	out	0x3e, r29	; 62
   17c96:	cd bf       	out	0x3d, r28	; 61

00017c98 <__do_copy_data>:
   17c98:	1c e0       	ldi	r17, 0x0C	; 12
   17c9a:	a2 eb       	ldi	r26, 0xB2	; 178
   17c9c:	bc e0       	ldi	r27, 0x0C	; 12
   17c9e:	e4 ed       	ldi	r30, 0xD4	; 212
   17ca0:	ff e7       	ldi	r31, 0x7F	; 127
   17ca2:	01 e0       	ldi	r16, 0x01	; 1
   17ca4:	0b bf       	out	0x3b, r16	; 59
   17ca6:	02 c0       	rjmp	.+4      	; 0x17cac
   17ca8:	07 90       	elpm	r0, Z+
   17caa:	0d 92       	st	X+, r0
   17cac:	ac 3b       	cpi	r26, 0xBC	; 188
   17cae:	b1 07       	cpc	r27, r17
   17cb0:	d9 f7       	brne	.-10     	; 0x17ca8

00017cb2 <__do_clear_bss>:
   17cb2:	1d e0       	ldi	r17, 0x0D	; 13
   17cb4:	ac eb       	ldi	r26, 0xBC	; 188
   17cb6:	bc e0       	ldi	r27, 0x0C	; 12
   17cb8:	01 c0       	rjmp	.+2      	; 0x17cbc

00017cba <.do_clear_bss_loop>:
   17cba:	1d 92       	st	X+, r1

00017cbc <.do_clear_bss_start>:
   17cbc:	a8 32       	cpi	r26, 0x28	; 40
   17cbe:	b1 07       	cpc	r27, r17
   17cc0:	e1 f7       	brne	.-8      	; 0x17cba
   17cc2:	0c 94 ed be 	jmp	0x17dda

00017cc6 <__bad_interrupt>:
   17cc6:	0c 94 00 be 	jmp	0x17c00

00017cca <getCurrentThread.1404>:
thread **getCurrentThread()
{
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
   17cca:	4f 93       	push	r20
   17ccc:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   17cce:	ec e0       	ldi	r30, 0x0C	; 12
   17cd0:	fa ee       	ldi	r31, 0xEA	; 234
   17cd2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17cd4:	84 2f       	mov	r24, r20
   17cd6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17cd8:	5f 91       	pop	r21
   17cda:	4f 91       	pop	r20
   17cdc:	08 95       	ret

00017cde <getCurrentThreadIndex.1405>:
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}


void **getKernelStackPtr()
	{
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
}







uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
   17cde:	4f 93       	push	r20
   17ce0:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   17ce2:	ec e1       	ldi	r30, 0x1C	; 28
   17ce4:	fa ee       	ldi	r31, 0xEA	; 234
   17ce6:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17ce8:	84 2f       	mov	r24, r20
   17cea:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17cec:	5f 91       	pop	r21
   17cee:	4f 91       	pop	r20
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}
   17cf0:	99 27       	eor	r25, r25
   17cf2:	08 95       	ret

00017cf4 <getFileMutexAddress.1462>:
mutex *getFileMutexAddress()
{
   mutex *mfile;   
   void (*getaddrfp)(void) = (void (*)(void))GET_FILE_MUTEX_ADDRESS; 
   asm volatile("push r20" "\n\t"
   17cf4:	4f 93       	push	r20
   17cf6:	5f 93       	push	r21
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   17cf8:	e8 e2       	ldi	r30, 0x28	; 40
   17cfa:	fa ee       	ldi	r31, 0xEA	; 234
   17cfc:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
   17cfe:	84 2f       	mov	r24, r20
   17d00:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (mfile)
				 :
                );
    asm volatile("pop r21" "\n\t"
   17d02:	5f 91       	pop	r21
   17d04:	4f 91       	pop	r20
   17d06:	08 95       	ret

00017d08 <Mutex_unlock.1456>:
   17d08:	4f 93       	push	r20
   17d0a:	5f 93       	push	r21
   17d0c:	48 2f       	mov	r20, r24
   17d0e:	59 2f       	mov	r21, r25
   17d10:	e8 e1       	ldi	r30, 0x18	; 24
   17d12:	fa ee       	ldi	r31, 0xEA	; 234
   17d14:	09 95       	icall
   17d16:	5f 91       	pop	r21
   17d18:	4f 91       	pop	r20
   17d1a:	08 95       	ret

00017d1c <mystrcpy.1471>:
}


void mystrcpy(char *dest, const char *src)
{
   17d1c:	dc 01       	movw	r26, r24
   17d1e:	fb 01       	movw	r30, r22
   17d20:	02 c0       	rjmp	.+4      	; 0x17d26
	int i;
	i = 0;
	while (src[i]!='\0')
	{ dest[i] = src[i];
   17d22:	8d 93       	st	X+, r24
   17d24:	31 96       	adiw	r30, 0x01	; 1
   17d26:	80 81       	ld	r24, Z
   17d28:	88 23       	and	r24, r24
   17d2a:	d9 f7       	brne	.-10     	; 0x17d22
	i++;
	}
	dest[i] = '\0';
   17d2c:	1c 92       	st	X, r1
   17d2e:	08 95       	ret

00017d30 <yield.1403>:


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 4;
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
   17d30:	e0 e0       	ldi	r30, 0x00	; 0
   17d32:	fa ee       	ldi	r31, 0xEA	; 234
   17d34:	09 95       	icall
   17d36:	08 95       	ret

00017d38 <Barrier_block.1461>:
   17d38:	ef 92       	push	r14
   17d3a:	ff 92       	push	r15
   17d3c:	0f 93       	push	r16
   17d3e:	1f 93       	push	r17
   17d40:	f8 2e       	mov	r15, r24
   17d42:	e6 2e       	mov	r14, r22
   17d44:	0e 94 65 be 	call	0x17cca
   17d48:	dc 01       	movw	r26, r24


_atomic_t _atomic_start(void)
{
  _atomic_t result = SREG;
   17d4a:	0f b7       	in	r16, 0x3f	; 63
  asm volatile("cli" "\n\t"::);
   17d4c:	f8 94       	cli
   17d4e:	11 27       	eor	r17, r17
   17d50:	ed 91       	ld	r30, X+
   17d52:	fc 91       	ld	r31, X
   17d54:	11 97       	sbiw	r26, 0x01	; 1
   17d56:	86 e0       	ldi	r24, 0x06	; 6
   17d58:	82 83       	std	Z+2, r24	; 0x02
   17d5a:	ed 91       	ld	r30, X+
   17d5c:	fc 91       	ld	r31, X
   17d5e:	11 97       	sbiw	r26, 0x01	; 1
   17d60:	f3 8e       	std	Z+27, r15	; 0x1b
   17d62:	ed 91       	ld	r30, X+
   17d64:	fc 91       	ld	r31, X
   17d66:	e4 8e       	std	Z+28, r14	; 0x1c
   17d68:	0e 94 98 be 	call	0x17d30
  return result;
}



void _atomic_end(_atomic_t oldSreg)
{
  SREG = oldSreg;
   17d6c:	0f bf       	out	0x3f, r16	; 63
   17d6e:	1f 91       	pop	r17
   17d70:	0f 91       	pop	r16
   17d72:	ff 90       	pop	r15
   17d74:	ef 90       	pop	r14
   17d76:	08 95       	ret

00017d78 <Mutex_lock.1454>:
   17d78:	ef 92       	push	r14
   17d7a:	ff 92       	push	r15
   17d7c:	0f 93       	push	r16
   17d7e:	1f 93       	push	r17
   17d80:	cf 93       	push	r28
   17d82:	df 93       	push	r29
   17d84:	ec 01       	movw	r28, r24
   17d86:	0e 94 65 be 	call	0x17cca
   17d8a:	8c 01       	movw	r16, r24
   17d8c:	0e 94 6f be 	call	0x17cde
   17d90:	e8 2e       	mov	r14, r24
   17d92:	ff b6       	in	r15, 0x3f	; 63
   17d94:	f8 94       	cli
   17d96:	88 81       	ld	r24, Y
   17d98:	88 23       	and	r24, r24
   17d9a:	91 f0       	breq	.+36     	; 0x17dc0
   17d9c:	d8 01       	movw	r26, r16
   17d9e:	ed 91       	ld	r30, X+
   17da0:	fc 91       	ld	r31, X
   17da2:	11 97       	sbiw	r26, 0x01	; 1
   17da4:	83 e0       	ldi	r24, 0x03	; 3
   17da6:	82 83       	std	Z+2, r24	; 0x02
   17da8:	ed 91       	ld	r30, X+
   17daa:	fc 91       	ld	r31, X
   17dac:	d4 8f       	std	Z+28, r29	; 0x1c
   17dae:	c3 8f       	std	Z+27, r28	; 0x1b
   17db0:	89 81       	ldd	r24, Y+1	; 0x01
   17db2:	8f 5f       	subi	r24, 0xFF	; 255
   17db4:	89 83       	std	Y+1, r24	; 0x01
   17db6:	0e 94 98 be 	call	0x17d30
   17dba:	89 81       	ldd	r24, Y+1	; 0x01
   17dbc:	81 50       	subi	r24, 0x01	; 1
   17dbe:	89 83       	std	Y+1, r24	; 0x01
   17dc0:	81 e0       	ldi	r24, 0x01	; 1
   17dc2:	88 83       	st	Y, r24
   17dc4:	ea 82       	std	Y+2, r14	; 0x02
   17dc6:	8f 2d       	mov	r24, r15
   17dc8:	99 27       	eor	r25, r25
   17dca:	8f bf       	out	0x3f, r24	; 63
   17dcc:	df 91       	pop	r29
   17dce:	cf 91       	pop	r28
   17dd0:	1f 91       	pop	r17
   17dd2:	0f 91       	pop	r16
   17dd4:	ff 90       	pop	r15
   17dd6:	ef 90       	pop	r14
   17dd8:	08 95       	ret

00017dda <main>:
 uint8_t tempbuffer[100]; 
 

int main()
{ 
   17dda:	af 92       	push	r10
   17ddc:	bf 92       	push	r11
   17dde:	cf 92       	push	r12
   17de0:	df 92       	push	r13
   17de2:	ef 92       	push	r14
   17de4:	ff 92       	push	r15
   17de6:	0f 93       	push	r16
   17de8:	1f 93       	push	r17

thread** current_thread;
 __asm__ __volatile__("sei" ::); 
   17dea:	78 94       	sei
 
  for (i=0;i<100;i++)
   17dec:	10 92 bf 0c 	sts	0x0CBF, r1
   17df0:	10 92 be 0c 	sts	0x0CBE, r1
   17df4:	80 e0       	ldi	r24, 0x00	; 0
   17df6:	90 e0       	ldi	r25, 0x00	; 0
   17df8:	e0 ec       	ldi	r30, 0xC0	; 192
   17dfa:	fc e0       	ldi	r31, 0x0C	; 12
   tempbuffer[i] = i; 
   17dfc:	81 93       	st	Z+, r24
   17dfe:	01 96       	adiw	r24, 0x01	; 1
   17e00:	84 36       	cpi	r24, 0x64	; 100
   17e02:	91 05       	cpc	r25, r1
   17e04:	d9 f7       	brne	.-10     	; 0x17dfc
   17e06:	84 e6       	ldi	r24, 0x64	; 100
   17e08:	90 e0       	ldi	r25, 0x00	; 0
   17e0a:	90 93 bf 0c 	sts	0x0CBF, r25
   17e0e:	80 93 be 0c 	sts	0x0CBE, r24
	  
    current_thread = getCurrentThread();  
   17e12:	0e 94 65 be 	call	0x17cca
   17e16:	dc 01       	movw	r26, r24
    
(*current_thread)->ecbptr->share = 333; 
   17e18:	ed 91       	ld	r30, X+
   17e1a:	fc 91       	ld	r31, X
   17e1c:	11 97       	sbiw	r26, 0x01	; 1
   17e1e:	05 a0       	ldd	r0, Z+37	; 0x25
   17e20:	f6 a1       	ldd	r31, Z+38	; 0x26
   17e22:	e0 2d       	mov	r30, r0
   17e24:	8d e4       	ldi	r24, 0x4D	; 77
   17e26:	81 83       	std	Z+1, r24	; 0x01
   (*current_thread)->ecbptr->totalenergy =  800000; 
   17e28:	ed 91       	ld	r30, X+
   17e2a:	fc 91       	ld	r31, X
   17e2c:	05 a0       	ldd	r0, Z+37	; 0x25
   17e2e:	f6 a1       	ldd	r31, Z+38	; 0x26
   17e30:	e0 2d       	mov	r30, r0
   17e32:	80 e0       	ldi	r24, 0x00	; 0
   17e34:	95 e3       	ldi	r25, 0x35	; 53
   17e36:	ac e0       	ldi	r26, 0x0C	; 12
   17e38:	b0 e0       	ldi	r27, 0x00	; 0
   17e3a:	83 83       	std	Z+3, r24	; 0x03
   17e3c:	94 83       	std	Z+4, r25	; 0x04
   17e3e:	a5 83       	std	Z+5, r26	; 0x05
   17e40:	b6 83       	std	Z+6, r27	; 0x06
   (*current_thread)->ecbptr->remainenergy = 800000; 
   17e42:	87 83       	std	Z+7, r24	; 0x07
   17e44:	90 87       	std	Z+8, r25	; 0x08
   17e46:	a1 87       	std	Z+9, r26	; 0x09
   17e48:	b2 87       	std	Z+10, r27	; 0x0a
     
     
   sbi(MCUCR, SM0);
   17e4a:	85 b7       	in	r24, 0x35	; 53
   17e4c:	88 60       	ori	r24, 0x08	; 8
   17e4e:	85 bf       	out	0x35, r24	; 53

   sbi(MCUCR, SM1);
   17e50:	85 b7       	in	r24, 0x35	; 53
   17e52:	80 61       	ori	r24, 0x10	; 16
   17e54:	85 bf       	out	0x35, r24	; 53
   cbi(MCUCR, SM2); 
   17e56:	85 b7       	in	r24, 0x35	; 53
   17e58:	8b 7f       	andi	r24, 0xFB	; 251
   17e5a:	85 bf       	out	0x35, r24	; 53
   sbi(MCUCR, SE);
   17e5c:	85 b7       	in	r24, 0x35	; 53
   17e5e:	80 62       	ori	r24, 0x20	; 32
   17e60:	85 bf       	out	0x35, r24	; 53
   thread** current_thread;

   mutex *mfile;

   current_thread = getCurrentThread();
   17e62:	0e 94 65 be 	call	0x17cca
   17e66:	5c 01       	movw	r10, r24

   currentthreadindex = getCurrentThreadIndex();
   17e68:	0e 94 6f be 	call	0x17cde
   17e6c:	4f 93       	push	r20
   17e6e:	5f 93       	push	r21
   17e70:	e0 e2       	ldi	r30, 0x20	; 32
   17e72:	fa ee       	ldi	r31, 0xEA	; 234
   17e74:	09 95       	icall
   17e76:	c4 2e       	mov	r12, r20
   17e78:	d5 2e       	mov	r13, r21
   17e7a:	5f 91       	pop	r21
   17e7c:	4f 91       	pop	r20
   17e7e:	4f 93       	push	r20
   17e80:	5f 93       	push	r21
   17e82:	e4 e2       	ldi	r30, 0x24	; 36
   17e84:	fa ee       	ldi	r31, 0xEA	; 234
   17e86:	09 95       	icall
   17e88:	e4 2e       	mov	r14, r20
   17e8a:	f5 2e       	mov	r15, r21
   17e8c:	5f 91       	pop	r21
   17e8e:	4f 91       	pop	r20

   commonpathnameaddr =  getFilePathAddress();

   commonmodeaddr = getFileModeAddress();

   mfile = getFileMutexAddress();
   17e90:	0e 94 7a be 	call	0x17cf4
   17e94:	8c 01       	movw	r16, r24


   Mutex_lock(mfile);
   17e96:	0e 94 bc be 	call	0x17d78

   mystrcpy(commonpathnameaddr, pathname);
   17e9a:	62 eb       	ldi	r22, 0xB2	; 178
   17e9c:	7c e0       	ldi	r23, 0x0C	; 12
   17e9e:	c6 01       	movw	r24, r12
   17ea0:	0e 94 8e be 	call	0x17d1c
   mystrcpy(commonmodeaddr, mode);
   17ea4:	69 eb       	ldi	r22, 0xB9	; 185
   17ea6:	7c e0       	ldi	r23, 0x0C	; 12
   17ea8:	c7 01       	movw	r24, r14
   17eaa:	0e 94 8e be 	call	0x17d1c
   17eae:	ec e2       	ldi	r30, 0x2C	; 44
   17eb0:	fa ee       	ldi	r31, 0xEA	; 234
   17eb2:	09 95       	icall

   openFileSysCall();

   Barrier_block(7, 1);
   17eb4:	61 e0       	ldi	r22, 0x01	; 1
   17eb6:	87 e0       	ldi	r24, 0x07	; 7
   17eb8:	0e 94 9c be 	call	0x17d38
   Mutex_unlock(mfile);
   17ebc:	c8 01       	movw	r24, r16
   17ebe:	0e 94 84 be 	call	0x17d08

   return (MYFILE *)((*current_thread)->filedata.filestate.fileptr);
   17ec2:	d5 01       	movw	r26, r10
   17ec4:	ed 91       	ld	r30, X+
   17ec6:	fc 91       	ld	r31, X
   17ec8:	87 8d       	ldd	r24, Z+31	; 0x1f
   17eca:	90 a1       	ldd	r25, Z+32	; 0x20
   
   
 fileptr = mfopen("/file1", "w");
   17ecc:	90 93 bd 0c 	sts	0x0CBD, r25
   17ed0:	80 93 bc 0c 	sts	0x0CBC, r24
 

 while (1)
 {
    mfwrite(fileptr, tempbuffer, 10);
   17ed4:	c0 90 bc 0c 	lds	r12, 0x0CBC
   17ed8:	d0 90 bd 0c 	lds	r13, 0x0CBD
}



void mfclose(MYFILE *fp)
{
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   currentthreadindex = getCurrentThreadIndex();
   mfile = getFileMutexAddress();

   Mutex_lock(mfile);

   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   closeFileSysCall();

   Barrier_block(7, 2);
   Mutex_unlock(mfile);

   return;

}

void mfread(MYFILE *fp, void *buffer, int nBytes)
{
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   currentthreadindex = getCurrentThreadIndex();
   mfile = getFileMutexAddress();


   Mutex_lock(mfile);
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   (*current_thread)->filedata.filestate.bytes = nBytes;

   readFileSysCall();

   Barrier_block(7, 3);
   Mutex_unlock(mfile);

   return;

}



void mfwrite(MYFILE *fp, void *buffer, int nBytes)
{
   uint8_t currentthreadindex;
   thread** current_thread;
   mutex *mfile;

   current_thread = getCurrentThread();
   17edc:	0e 94 65 be 	call	0x17cca
   17ee0:	8c 01       	movw	r16, r24
   currentthreadindex = getCurrentThreadIndex();
   17ee2:	0e 94 6f be 	call	0x17cde
   mfile = getFileMutexAddress();
   17ee6:	0e 94 7a be 	call	0x17cf4
   17eea:	7c 01       	movw	r14, r24
   
  
     
	 (*current_thread)->ecbptr->remainenergy -= (uint16_t)FILE_WRITE * (uint16_t)nBytes;          
   17eec:	d8 01       	movw	r26, r16
   17eee:	ed 91       	ld	r30, X+
   17ef0:	fc 91       	ld	r31, X
   17ef2:	05 a0       	ldd	r0, Z+37	; 0x25
   17ef4:	f6 a1       	ldd	r31, Z+38	; 0x26
   17ef6:	e0 2d       	mov	r30, r0
   17ef8:	87 81       	ldd	r24, Z+7	; 0x07
   17efa:	90 85       	ldd	r25, Z+8	; 0x08
   17efc:	a1 85       	ldd	r26, Z+9	; 0x09
   17efe:	b2 85       	ldd	r27, Z+10	; 0x0a
   17f00:	82 52       	subi	r24, 0x22	; 34
   17f02:	9e 42       	sbci	r25, 0x2E	; 46
   17f04:	a0 40       	sbci	r26, 0x00	; 0
   17f06:	b0 40       	sbci	r27, 0x00	; 0
   17f08:	87 83       	std	Z+7, r24	; 0x07
   17f0a:	90 87       	std	Z+8, r25	; 0x08
   17f0c:	a1 87       	std	Z+9, r26	; 0x09
   17f0e:	b2 87       	std	Z+10, r27	; 0x0a


   Mutex_lock(mfile);
   17f10:	c7 01       	movw	r24, r14
   17f12:	0e 94 bc be 	call	0x17d78
   (*current_thread)->filedata.filestate.fileptr = (uint8_t*)fp;
   17f16:	d8 01       	movw	r26, r16
   17f18:	ed 91       	ld	r30, X+
   17f1a:	fc 91       	ld	r31, X
   17f1c:	11 97       	sbiw	r26, 0x01	; 1
   17f1e:	d0 a2       	std	Z+32, r13	; 0x20
   17f20:	c7 8e       	std	Z+31, r12	; 0x1f
   (*current_thread)->filedata.filestate.bufferptr = (uint8_t*)buffer;
   17f22:	ed 91       	ld	r30, X+
   17f24:	fc 91       	ld	r31, X
   17f26:	11 97       	sbiw	r26, 0x01	; 1
   17f28:	80 ec       	ldi	r24, 0xC0	; 192
   17f2a:	9c e0       	ldi	r25, 0x0C	; 12
   17f2c:	92 a3       	std	Z+34, r25	; 0x22
   17f2e:	81 a3       	std	Z+33, r24	; 0x21
   (*current_thread)->filedata.filestate.bytes = nBytes;
   17f30:	ed 91       	ld	r30, X+
   17f32:	fc 91       	ld	r31, X
   17f34:	8a e0       	ldi	r24, 0x0A	; 10
   17f36:	90 e0       	ldi	r25, 0x00	; 0
   17f38:	94 a3       	std	Z+36, r25	; 0x24
   17f3a:	83 a3       	std	Z+35, r24	; 0x23
   17f3c:	e8 e3       	ldi	r30, 0x38	; 56
   17f3e:	fa ee       	ldi	r31, 0xEA	; 234
   17f40:	09 95       	icall

   writeFileSysCall();

   Barrier_block(7, 4);
   17f42:	64 e0       	ldi	r22, 0x04	; 4
   17f44:	87 e0       	ldi	r24, 0x07	; 7
   17f46:	0e 94 9c be 	call	0x17d38
   
   Mutex_unlock(mfile);
   17f4a:	c7 01       	movw	r24, r14
   17f4c:	0e 94 84 be 	call	0x17d08
   17f50:	0e 94 65 be 	call	0x17cca
   17f54:	dc 01       	movw	r26, r24
   17f56:	ed 91       	ld	r30, X+
   17f58:	fc 91       	ld	r31, X
   17f5a:	11 97       	sbiw	r26, 0x01	; 1
   17f5c:	84 e0       	ldi	r24, 0x04	; 4
   17f5e:	82 83       	std	Z+2, r24	; 0x02
   17f60:	ed 91       	ld	r30, X+
   17f62:	fc 91       	ld	r31, X
   17f64:	84 e1       	ldi	r24, 0x14	; 20
   17f66:	90 e0       	ldi	r25, 0x00	; 0
   17f68:	94 8f       	std	Z+28, r25	; 0x1c
   17f6a:	83 8f       	std	Z+27, r24	; 0x1b
   17f6c:	0e 94 98 be 	call	0x17d30
  	mfseek(fileptr, 0, 0); 
   17f70:	e0 90 bc 0c 	lds	r14, 0x0CBC
   17f74:	f0 90 bd 0c 	lds	r15, 0x0CBD
   
   sleepThread(20);

   return;
}


void mfwrite_withoutlength(MYFILE *fp, void *buffer)
{


   uint8_t length;

   length = (uint8_t)String_length((char*)buffer);

   mfwrite(fp, buffer, length);

   return;
}






void mfseek(MYFILE *fp, int offset, int position)
{
   uint8_t currentthreadindex;
   thread** current_thread;

   current_thread = getCurrentThread();
   17f78:	0e 94 65 be 	call	0x17cca
   17f7c:	8c 01       	movw	r16, r24
   currentthreadindex = getCurrentThreadIndex();
   17f7e:	0e 94 6f be 	call	0x17cde

   (*current_thread)->filedata.fileseekstate.fileptr = (uint8_t*)fp;
   17f82:	d8 01       	movw	r26, r16
   17f84:	ed 91       	ld	r30, X+
   17f86:	fc 91       	ld	r31, X
   17f88:	11 97       	sbiw	r26, 0x01	; 1
   17f8a:	f0 a2       	std	Z+32, r15	; 0x20
   17f8c:	e7 8e       	std	Z+31, r14	; 0x1f
   (*current_thread)->filedata.fileseekstate.offset = offset;
   17f8e:	ed 91       	ld	r30, X+
   17f90:	fc 91       	ld	r31, X
   17f92:	11 97       	sbiw	r26, 0x01	; 1
   17f94:	12 a2       	std	Z+34, r1	; 0x22
   17f96:	11 a2       	std	Z+33, r1	; 0x21
   (*current_thread)->filedata.fileseekstate.position = position;
   17f98:	ed 91       	ld	r30, X+
   17f9a:	fc 91       	ld	r31, X
   17f9c:	14 a2       	std	Z+36, r1	; 0x24
   17f9e:	13 a2       	std	Z+35, r1	; 0x23
   17fa0:	ec e3       	ldi	r30, 0x3C	; 60
   17fa2:	fa ee       	ldi	r31, 0xEA	; 234
   17fa4:	09 95       	icall
   17fa6:	96 cf       	rjmp	.-212    	; 0x17ed4

00017fa8 <syscall_postThreadTask.1410>:
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
   17fa8:	e8 e6       	ldi	r30, 0x68	; 104
   17faa:	fa ee       	ldi	r31, 0xEA	; 234
   17fac:	09 95       	icall
   17fae:	08 95       	ret

00017fb0 <wakeupMe.3692>:
//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
  mythread->state = STATE_ACTIVE;
   17fb0:	e0 91 24 0d 	lds	r30, 0x0D24
   17fb4:	f0 91 25 0d 	lds	r31, 0x0D25
   17fb8:	82 e0       	ldi	r24, 0x02	; 2
   17fba:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   17fbc:	0e 94 d4 bf 	call	0x17fa8
   17fc0:	08 95       	ret

00017fc2 <wakeupMeSerial.4087>:
//wakeup the current thread once an incoming packet arrives

void wakeupMeSerial()
{
  mythreadserial->state = STATE_ACTIVE;
   17fc2:	e0 91 26 0d 	lds	r30, 0x0D26
   17fc6:	f0 91 27 0d 	lds	r31, 0x0D27
   17fca:	82 e0       	ldi	r24, 0x02	; 2
   17fcc:	82 83       	std	Z+2, r24	; 0x02
  syscall_postThreadTask();
   17fce:	0e 94 d4 bf 	call	0x17fa8
   17fd2:	08 95       	ret
