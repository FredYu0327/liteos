
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000186  0000f000  0000f000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000002  00800cbc  00800cbc  000001fa  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  000001fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  00000604  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  00000688  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  000006a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000fe2  00000000  00000000  000006c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000001d9  00000000  00000000  000016a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001fb  00000000  00000000  0000187e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000040  00000000  00000000  00001a79  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000002f9  00000000  00000000  00001ab9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000009e  00000000  00000000  00001db2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000060  00000000  00000000  00001e50  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

0000f000 <__vectors>:
    f000:	0c 94 46 78 	jmp	0xf08c	; 0xf08c <__ctors_end>
    f004:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f008:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f00c:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f010:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f014:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f018:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f01c:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f020:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f024:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f028:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f02c:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f030:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f034:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f038:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f03c:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f040:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f044:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f048:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f04c:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f050:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f054:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f058:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f05c:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f060:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f064:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f068:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f06c:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f070:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f074:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f078:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f07c:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f080:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f084:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>
    f088:	0c 94 63 78 	jmp	0xf0c6	; 0xf0c6 <__bad_interrupt>

0000f08c <__ctors_end>:
    f08c:	11 24       	eor	r1, r1
    f08e:	1f be       	out	0x3f, r1	; 63
    f090:	c2 e5       	ldi	r28, 0x52	; 82
    f092:	dd e0       	ldi	r29, 0x0D	; 13
    f094:	de bf       	out	0x3e, r29	; 62
    f096:	cd bf       	out	0x3d, r28	; 61

0000f098 <__do_copy_data>:
    f098:	1c e0       	ldi	r17, 0x0C	; 12
    f09a:	ac eb       	ldi	r26, 0xBC	; 188
    f09c:	bc e0       	ldi	r27, 0x0C	; 12
    f09e:	e6 e8       	ldi	r30, 0x86	; 134
    f0a0:	f1 ef       	ldi	r31, 0xF1	; 241
    f0a2:	00 e0       	ldi	r16, 0x00	; 0
    f0a4:	0b bf       	out	0x3b, r16	; 59
    f0a6:	02 c0       	rjmp	.+4      	; 0xf0ac <__do_copy_data+0x14>
    f0a8:	07 90       	elpm	r0, Z+
    f0aa:	0d 92       	st	X+, r0
    f0ac:	ac 3b       	cpi	r26, 0xBC	; 188
    f0ae:	b1 07       	cpc	r27, r17
    f0b0:	d9 f7       	brne	.-10     	; 0xf0a8 <__do_copy_data+0x10>

0000f0b2 <__do_clear_bss>:
    f0b2:	1c e0       	ldi	r17, 0x0C	; 12
    f0b4:	ac eb       	ldi	r26, 0xBC	; 188
    f0b6:	bc e0       	ldi	r27, 0x0C	; 12
    f0b8:	01 c0       	rjmp	.+2      	; 0xf0bc <.do_clear_bss_start>

0000f0ba <.do_clear_bss_loop>:
    f0ba:	1d 92       	st	X+, r1

0000f0bc <.do_clear_bss_start>:
    f0bc:	ae 3b       	cpi	r26, 0xBE	; 190
    f0be:	b1 07       	cpc	r27, r17
    f0c0:	e1 f7       	brne	.-8      	; 0xf0ba <.do_clear_bss_loop>
    f0c2:	0c 94 6f 78 	jmp	0xf0de	; 0xf0de <main>

0000f0c6 <__bad_interrupt>:
    f0c6:	0c 94 00 78 	jmp	0xf000	; 0xf000 <__vectors>

0000f0ca <getCurrentThread.1404>:

//Warning: this returns the address of the currentthread pointer. 

thread **getCurrentThread()
{
    f0ca:	4f 93       	push	r20
    f0cc:	5f 93       	push	r21
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    f0ce:	ec e0       	ldi	r30, 0x0C	; 12
    f0d0:	fa ee       	ldi	r31, 0xEA	; 234
    f0d2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    f0d4:	84 2f       	mov	r24, r20
    f0d6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
    f0d8:	5f 91       	pop	r21
    f0da:	4f 91       	pop	r20
    f0dc:	08 95       	ret

0000f0de <main>:
#define PRG_RDB(addr) pgm_read_byte(addr)
#endif

int main()
{
    f0de:	78 94       	sei
 uint16_t index;
 uint8_t index2; 
  thread** current_thread;
 
 __asm__ __volatile__("sei" ::); 
 

	  
    current_thread = getCurrentThread();  
    f0e0:	0e 94 65 78 	call	0xf0ca	; 0xf0ca <getCurrentThread.1404>
    f0e4:	dc 01       	movw	r26, r24
    
   (*current_thread)->ecbptr->share = 500; 
    f0e6:	ed 91       	ld	r30, X+
    f0e8:	fc 91       	ld	r31, X
    f0ea:	11 97       	sbiw	r26, 0x01	; 1
    f0ec:	05 a0       	ldd	r0, Z+37	; 0x25
    f0ee:	f6 a1       	ldd	r31, Z+38	; 0x26
    f0f0:	e0 2d       	mov	r30, r0
    f0f2:	84 ef       	ldi	r24, 0xF4	; 244
    f0f4:	81 83       	std	Z+1, r24	; 0x01
   (*current_thread)->ecbptr->totalenergy =  7500000; 
    f0f6:	ed 91       	ld	r30, X+
    f0f8:	fc 91       	ld	r31, X
    f0fa:	05 a0       	ldd	r0, Z+37	; 0x25
    f0fc:	f6 a1       	ldd	r31, Z+38	; 0x26
    f0fe:	e0 2d       	mov	r30, r0
    f100:	80 ee       	ldi	r24, 0xE0	; 224
    f102:	90 e7       	ldi	r25, 0x70	; 112
    f104:	a2 e7       	ldi	r26, 0x72	; 114
    f106:	b0 e0       	ldi	r27, 0x00	; 0
    f108:	83 83       	std	Z+3, r24	; 0x03
    f10a:	94 83       	std	Z+4, r25	; 0x04
    f10c:	a5 83       	std	Z+5, r26	; 0x05
    f10e:	b6 83       	std	Z+6, r27	; 0x06
   (*current_thread)->ecbptr->remainenergy = 7500000; 
    f110:	87 83       	std	Z+7, r24	; 0x07
    f112:	90 87       	std	Z+8, r25	; 0x08
    f114:	a1 87       	std	Z+9, r26	; 0x09
    f116:	b2 87       	std	Z+10, r27	; 0x0a
     
   sbi(MCUCR, SM0);
    f118:	85 b7       	in	r24, 0x35	; 53
    f11a:	88 60       	ori	r24, 0x08	; 8
    f11c:	85 bf       	out	0x35, r24	; 53

   sbi(MCUCR, SM1);
    f11e:	85 b7       	in	r24, 0x35	; 53
    f120:	80 61       	ori	r24, 0x10	; 16
    f122:	85 bf       	out	0x35, r24	; 53
   cbi(MCUCR, SM2); 
    f124:	85 b7       	in	r24, 0x35	; 53
    f126:	8b 7f       	andi	r24, 0xFB	; 251
    f128:	85 bf       	out	0x35, r24	; 53
   sbi(MCUCR, SE);
    f12a:	85 b7       	in	r24, 0x35	; 53
    f12c:	80 62       	ori	r24, 0x20	; 32
    f12e:	85 bf       	out	0x35, r24	; 53
    f130:	20 e0       	ldi	r18, 0x00	; 0
    f132:	30 e0       	ldi	r19, 0x00	; 0
    f134:	1c c0       	rjmp	.+56     	; 0xf16e <main+0x90>
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}


void **getKernelStackPtr()
	{
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
}







uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    f136:	0e 94 65 78 	call	0xf0ca	; 0xf0ca <getCurrentThread.1404>
    f13a:	dc 01       	movw	r26, r24
     
   (*current_thread)->state = 4;
    f13c:	ed 91       	ld	r30, X+
    f13e:	fc 91       	ld	r31, X
    f140:	11 97       	sbiw	r26, 0x01	; 1
    f142:	84 e0       	ldi	r24, 0x04	; 4
    f144:	82 83       	std	Z+2, r24	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    f146:	ed 91       	ld	r30, X+
    f148:	fc 91       	ld	r31, X
    f14a:	88 e7       	ldi	r24, 0x78	; 120
    f14c:	90 e0       	ldi	r25, 0x00	; 0
    f14e:	94 8f       	std	Z+28, r25	; 0x1c
    f150:	83 8f       	std	Z+27, r24	; 0x1b
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    f152:	e0 e0       	ldi	r30, 0x00	; 0
    f154:	fa ee       	ldi	r31, 0xEA	; 234
    f156:	09 95       	icall
    f158:	eb cf       	rjmp	.-42     	; 0xf130 <main+0x52>
   
   
   while(1)
   	{
	   
	   for (index=0;index<1200;index++)
	    for (index2=0;index2<123;index2++)
	        {
	        	__asm__ __volatile__("nop" ::); 
    f15a:	00 00       	nop
    f15c:	8f 5f       	subi	r24, 0xFF	; 255
    f15e:	8b 37       	cpi	r24, 0x7B	; 123
    f160:	e1 f7       	brne	.-8      	; 0xf15a <main+0x7c>
    f162:	2f 5f       	subi	r18, 0xFF	; 255
    f164:	3f 4f       	sbci	r19, 0xFF	; 255
    f166:	84 e0       	ldi	r24, 0x04	; 4
    f168:	20 3b       	cpi	r18, 0xB0	; 176
    f16a:	38 07       	cpc	r19, r24
    f16c:	21 f3       	breq	.-56     	; 0xf136 <main+0x58>
    f16e:	80 e0       	ldi	r24, 0x00	; 0
    f170:	f4 cf       	rjmp	.-24     	; 0xf15a <main+0x7c>

0000f172 <wakeupMe.3692>:

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
    f172:	e0 91 bc 0c 	lds	r30, 0x0CBC
    f176:	f0 91 bd 0c 	lds	r31, 0x0CBD
    f17a:	82 e0       	ldi	r24, 0x02	; 2
    f17c:	82 83       	std	Z+2, r24	; 0x02
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    f17e:	e8 e6       	ldi	r30, 0x68	; 104
    f180:	fa ee       	ldi	r31, 0xEA	; 234
    f182:	09 95       	icall
    f184:	08 95       	ret
