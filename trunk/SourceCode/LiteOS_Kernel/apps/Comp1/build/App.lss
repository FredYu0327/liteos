
App.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000186  0000c800  0000c800  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000002  00800b54  00800b54  000001fa  2**0
                  ALLOC
  2 .stab         00000408  00000000  00000000  000001fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000084  00000000  00000000  00000604  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  00000688  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000001b  00000000  00000000  000006a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000fe2  00000000  00000000  000006c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000001d9  00000000  00000000  000016a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001fb  00000000  00000000  0000187e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000040  00000000  00000000  00001a79  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000002f9  00000000  00000000  00001ab9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000009e  00000000  00000000  00001db2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000060  00000000  00000000  00001e50  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

0000c800 <__vectors>:
    c800:	0c 94 46 64 	jmp	0xc88c	; 0xc88c <__ctors_end>
    c804:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c808:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c80c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c810:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c814:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c818:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c81c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c820:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c824:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c828:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c82c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c830:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c834:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c838:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c83c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c840:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c844:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c848:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c84c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c850:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c854:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c858:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c85c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c860:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c864:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c868:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c86c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c870:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c874:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c878:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c87c:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c880:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c884:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>
    c888:	0c 94 63 64 	jmp	0xc8c6	; 0xc8c6 <__bad_interrupt>

0000c88c <__ctors_end>:
    c88c:	11 24       	eor	r1, r1
    c88e:	1f be       	out	0x3f, r1	; 63
    c890:	ca ee       	ldi	r28, 0xEA	; 234
    c892:	db e0       	ldi	r29, 0x0B	; 11
    c894:	de bf       	out	0x3e, r29	; 62
    c896:	cd bf       	out	0x3d, r28	; 61

0000c898 <__do_copy_data>:
    c898:	1b e0       	ldi	r17, 0x0B	; 11
    c89a:	a4 e5       	ldi	r26, 0x54	; 84
    c89c:	bb e0       	ldi	r27, 0x0B	; 11
    c89e:	e6 e8       	ldi	r30, 0x86	; 134
    c8a0:	f9 ec       	ldi	r31, 0xC9	; 201
    c8a2:	00 e0       	ldi	r16, 0x00	; 0
    c8a4:	0b bf       	out	0x3b, r16	; 59
    c8a6:	02 c0       	rjmp	.+4      	; 0xc8ac <__do_copy_data+0x14>
    c8a8:	07 90       	elpm	r0, Z+
    c8aa:	0d 92       	st	X+, r0
    c8ac:	a4 35       	cpi	r26, 0x54	; 84
    c8ae:	b1 07       	cpc	r27, r17
    c8b0:	d9 f7       	brne	.-10     	; 0xc8a8 <__do_copy_data+0x10>

0000c8b2 <__do_clear_bss>:
    c8b2:	1b e0       	ldi	r17, 0x0B	; 11
    c8b4:	a4 e5       	ldi	r26, 0x54	; 84
    c8b6:	bb e0       	ldi	r27, 0x0B	; 11
    c8b8:	01 c0       	rjmp	.+2      	; 0xc8bc <.do_clear_bss_start>

0000c8ba <.do_clear_bss_loop>:
    c8ba:	1d 92       	st	X+, r1

0000c8bc <.do_clear_bss_start>:
    c8bc:	a6 35       	cpi	r26, 0x56	; 86
    c8be:	b1 07       	cpc	r27, r17
    c8c0:	e1 f7       	brne	.-8      	; 0xc8ba <.do_clear_bss_loop>
    c8c2:	0c 94 6f 64 	jmp	0xc8de	; 0xc8de <main>

0000c8c6 <__bad_interrupt>:
    c8c6:	0c 94 00 64 	jmp	0xc800	; 0xc800 <__vectors>

0000c8ca <getCurrentThread.1404>:

//Warning: this returns the address of the currentthread pointer. 

thread **getCurrentThread()
{
    c8ca:	4f 93       	push	r20
    c8cc:	5f 93       	push	r21
   thread **current_thread; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
    c8ce:	ec e0       	ldi	r30, 0x0C	; 12
    c8d0:	fa ee       	ldi	r31, 0xEA	; 234
    c8d2:	09 95       	icall
   asm volatile(" mov %A0, r20" "\n\t"
    c8d4:	84 2f       	mov	r24, r20
    c8d6:	95 2f       	mov	r25, r21
	             "mov %B0, r21" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r21" "\n\t"
    c8d8:	5f 91       	pop	r21
    c8da:	4f 91       	pop	r20
    c8dc:	08 95       	ret

0000c8de <main>:
#define PRG_RDB(addr) pgm_read_byte(addr)
#endif

int main()
{
    c8de:	78 94       	sei
 uint16_t index;
 uint8_t index2; 
  thread** current_thread;
 
 __asm__ __volatile__("sei" ::); 
 

	  
    current_thread = getCurrentThread();  
    c8e0:	0e 94 65 64 	call	0xc8ca	; 0xc8ca <getCurrentThread.1404>
    c8e4:	dc 01       	movw	r26, r24
    
   (*current_thread)->ecbptr->share = 167; 
    c8e6:	ed 91       	ld	r30, X+
    c8e8:	fc 91       	ld	r31, X
    c8ea:	11 97       	sbiw	r26, 0x01	; 1
    c8ec:	05 a0       	ldd	r0, Z+37	; 0x25
    c8ee:	f6 a1       	ldd	r31, Z+38	; 0x26
    c8f0:	e0 2d       	mov	r30, r0
    c8f2:	87 ea       	ldi	r24, 0xA7	; 167
    c8f4:	81 83       	std	Z+1, r24	; 0x01
   (*current_thread)->ecbptr->totalenergy =  5000000; 
    c8f6:	ed 91       	ld	r30, X+
    c8f8:	fc 91       	ld	r31, X
    c8fa:	05 a0       	ldd	r0, Z+37	; 0x25
    c8fc:	f6 a1       	ldd	r31, Z+38	; 0x26
    c8fe:	e0 2d       	mov	r30, r0
    c900:	80 e4       	ldi	r24, 0x40	; 64
    c902:	9b e4       	ldi	r25, 0x4B	; 75
    c904:	ac e4       	ldi	r26, 0x4C	; 76
    c906:	b0 e0       	ldi	r27, 0x00	; 0
    c908:	83 83       	std	Z+3, r24	; 0x03
    c90a:	94 83       	std	Z+4, r25	; 0x04
    c90c:	a5 83       	std	Z+5, r26	; 0x05
    c90e:	b6 83       	std	Z+6, r27	; 0x06
   (*current_thread)->ecbptr->remainenergy = 5000000; 
    c910:	87 83       	std	Z+7, r24	; 0x07
    c912:	90 87       	std	Z+8, r25	; 0x08
    c914:	a1 87       	std	Z+9, r26	; 0x09
    c916:	b2 87       	std	Z+10, r27	; 0x0a
     
   sbi(MCUCR, SM0);
    c918:	85 b7       	in	r24, 0x35	; 53
    c91a:	88 60       	ori	r24, 0x08	; 8
    c91c:	85 bf       	out	0x35, r24	; 53

   sbi(MCUCR, SM1);
    c91e:	85 b7       	in	r24, 0x35	; 53
    c920:	80 61       	ori	r24, 0x10	; 16
    c922:	85 bf       	out	0x35, r24	; 53
   cbi(MCUCR, SM2); 
    c924:	85 b7       	in	r24, 0x35	; 53
    c926:	8b 7f       	andi	r24, 0xFB	; 251
    c928:	85 bf       	out	0x35, r24	; 53
   sbi(MCUCR, SE);
    c92a:	85 b7       	in	r24, 0x35	; 53
    c92c:	80 62       	ori	r24, 0x20	; 32
    c92e:	85 bf       	out	0x35, r24	; 53
    c930:	20 e0       	ldi	r18, 0x00	; 0
    c932:	30 e0       	ldi	r19, 0x00	; 0
    c934:	1c c0       	rjmp	.+56     	; 0xc96e <main+0x90>
	             "pop r20" "\n\t"
	              ::);
   return current_thread; 
}


void **getKernelStackPtr()
	{
   void **ptr;
   void (*getaddrfp)(void) = (void (*)(void))GET_KERNEL_STACK_PTR_ADDRESS; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (ptr)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return ptr; 
}







uint8_t getCurrentThreadIndex()
{
   
   uint16_t index; 
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_INDEX_FUNCTION; 
   asm volatile("push r20" "\n\t"
                "push r21" "\n\t"
                ::);
   getaddrfp();     
   asm volatile(" mov %A0, r20" "\n\t"
	             "mov %B0, r21" "\n\t"
				 :"=r" (index)
				 :
                );
    asm volatile("pop r21" "\n\t"
	             "pop r20" "\n\t"
	              ::);
   return (uint8_t)index; 
}


void sleepThread(int milliseconds)
{
/*
   void (*getaddrfp)(void) = (void (*)(void))GET_CURRENT_THREAD_ADDRESS_FUNCTION; 

   asm volatile("push r24" "\n\t"
	             "push r25" "\n\t"
	              ::);
   getaddrfp();     

   asm volatile(" mov %A0, r24" "\n\t"
	             "mov %B0, r25" "\n\t"
				 :"=r" (current_thread)
				 :
                );
    asm volatile("pop r24" "\n\t"
	             "pop r25" "\n\t"
	              ::);
 */
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
    c936:	0e 94 65 64 	call	0xc8ca	; 0xc8ca <getCurrentThread.1404>
    c93a:	dc 01       	movw	r26, r24
     
   (*current_thread)->state = 4;
    c93c:	ed 91       	ld	r30, X+
    c93e:	fc 91       	ld	r31, X
    c940:	11 97       	sbiw	r26, 0x01	; 1
    c942:	84 e0       	ldi	r24, 0x04	; 4
    c944:	82 83       	std	Z+2, r24	; 0x02
   (*current_thread)->data.sleepstate.sleeptime = milliseconds;
    c946:	ed 91       	ld	r30, X+
    c948:	fc 91       	ld	r31, X
    c94a:	80 e5       	ldi	r24, 0x50	; 80
    c94c:	90 e0       	ldi	r25, 0x00	; 0
    c94e:	94 8f       	std	Z+28, r25	; 0x1c
    c950:	83 8f       	std	Z+27, r24	; 0x1b
   
   yield(); 
}


void hibernateThread()
{
 
   thread **current_thread; 
   current_thread = getCurrentThread(); 
     
   (*current_thread)->state = 5; 
   yield(); 
}


void yield()
{
 void (*yieldfp)(void) = (void (*)(void))YIELD_FUNCTION; 
 yieldfp();                              
    c952:	e0 e0       	ldi	r30, 0x00	; 0
    c954:	fa ee       	ldi	r31, 0xEA	; 234
    c956:	09 95       	icall
    c958:	eb cf       	rjmp	.-42     	; 0xc930 <main+0x52>
   
   
   while(1)
   	{
	   
	   for (index=0;index<1200;index++)
	    for (index2=0;index2<123;index2++)
	        {
	        	__asm__ __volatile__("nop" ::); 
    c95a:	00 00       	nop
    c95c:	8f 5f       	subi	r24, 0xFF	; 255
    c95e:	8b 37       	cpi	r24, 0x7B	; 123
    c960:	e1 f7       	brne	.-8      	; 0xc95a <main+0x7c>
    c962:	2f 5f       	subi	r18, 0xFF	; 255
    c964:	3f 4f       	sbci	r19, 0xFF	; 255
    c966:	84 e0       	ldi	r24, 0x04	; 4
    c968:	20 3b       	cpi	r18, 0xB0	; 176
    c96a:	38 07       	cpc	r19, r24
    c96c:	21 f3       	breq	.-56     	; 0xc936 <main+0x58>
    c96e:	80 e0       	ldi	r24, 0x00	; 0
    c970:	f4 cf       	rjmp	.-24     	; 0xc95a <main+0x7c>

0000c972 <wakeupMe.3692>:

//wakeup the current thread once an incoming packet arrives

void wakeupMe()
{
    c972:	e0 91 54 0b 	lds	r30, 0x0B54
    c976:	f0 91 55 0b 	lds	r31, 0x0B55
    c97a:	82 e0       	ldi	r24, 0x02	; 2
    c97c:	82 83       	std	Z+2, r24	; 0x02
}



void syscall_postThreadTask()
{
 void (*postthreadfp)(void) = (void (*)(void))POST_NEW_THREAD_TASK; 
 postthreadfp();                              
    c97e:	e8 e6       	ldi	r30, 0x68	; 104
    c980:	fa ee       	ldi	r31, 0xEA	; 234
    c982:	09 95       	icall
    c984:	08 95       	ret
